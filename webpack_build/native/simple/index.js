/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/native/simple/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/babylon_math/Maths/math.scalar.ts":
/*!***********************************************!*\
  !*** ./src/babylon_math/Maths/math.scalar.ts ***!
  \***********************************************/
/*! exports provided: Scalar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scalar\", function() { return Scalar; });\n/**\r\n * Scalar computation library\r\n */\r\nclass Scalar {\r\n    /**\r\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     * @param a number\r\n     * @param b number\r\n     * @param epsilon (default = 1.401298E-45)\r\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     */\r\n    static WithinEpsilon(a, b, epsilon = 1.401298E-45) {\r\n        var num = a - b;\r\n        return -epsilon <= num && num <= epsilon;\r\n    }\r\n    /**\r\n     * Returns a string : the upper case translation of the number i to hexadecimal.\r\n     * @param i number\r\n     * @returns the upper case translation of the number i to hexadecimal.\r\n     */\r\n    static ToHex(i) {\r\n        var str = i.toString(16);\r\n        if (i <= 15) {\r\n            return (\"0\" + str).toUpperCase();\r\n        }\r\n        return str.toUpperCase();\r\n    }\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    static Sign(value) {\r\n        value = +value; // convert to a number\r\n        if (value === 0 || isNaN(value)) {\r\n            return value;\r\n        }\r\n        return value > 0 ? 1 : -1;\r\n    }\r\n    /**\r\n     * Returns the value itself if it's between min and max.\r\n     * Returns min if the value is lower than min.\r\n     * Returns max if the value is greater than max.\r\n     * @param value the value to clmap\r\n     * @param min the min value to clamp to (default: 0)\r\n     * @param max the max value to clamp to (default: 1)\r\n     * @returns the clamped value\r\n     */\r\n    static Clamp(value, min = 0, max = 1) {\r\n        return Math.min(max, Math.max(min, value));\r\n    }\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    static Log2(value) {\r\n        return Math.log(value) * Math.LOG2E;\r\n    }\r\n    /**\r\n    * Loops the value, so that it is never larger than length and never smaller than 0.\r\n    *\r\n    * This is similar to the modulo operator but it works with floating point numbers.\r\n    * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n    * With t = 5 and length = 2.5, the result would be 0.0.\r\n    * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n    * @param value the value\r\n    * @param length the length\r\n    * @returns the looped value\r\n    */\r\n    static Repeat(value, length) {\r\n        return value - Math.floor(value / length) * length;\r\n    }\r\n    /**\r\n     * Normalize the value between 0.0 and 1.0 using min and max values\r\n     * @param value value to normalize\r\n     * @param min max to normalize between\r\n     * @param max min to normalize between\r\n     * @returns the normalized value\r\n     */\r\n    static Normalize(value, min, max) {\r\n        return (value - min) / (max - min);\r\n    }\r\n    /**\r\n    * Denormalize the value from 0.0 and 1.0 using min and max values\r\n    * @param normalized value to denormalize\r\n    * @param min max to denormalize between\r\n    * @param max min to denormalize between\r\n    * @returns the denormalized value\r\n    */\r\n    static Denormalize(normalized, min, max) {\r\n        return (normalized * (max - min) + min);\r\n    }\r\n    /**\r\n    * Calculates the shortest difference between two given angles given in degrees.\r\n    * @param current current angle in degrees\r\n    * @param target target angle in degrees\r\n    * @returns the delta\r\n    */\r\n    static DeltaAngle(current, target) {\r\n        var num = Scalar.Repeat(target - current, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return num;\r\n    }\r\n    /**\r\n    * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n    * @param tx value\r\n    * @param length length\r\n    * @returns The returned value will move back and forth between 0 and length\r\n    */\r\n    static PingPong(tx, length) {\r\n        var t = Scalar.Repeat(tx, length * 2.0);\r\n        return length - Math.abs(t - length);\r\n    }\r\n    /**\r\n    * Interpolates between min and max with smoothing at the limits.\r\n    *\r\n    * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n    * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n    * @param from from\r\n    * @param to to\r\n    * @param tx value\r\n    * @returns the smooth stepped value\r\n    */\r\n    static SmoothStep(from, to, tx) {\r\n        var t = Scalar.Clamp(tx);\r\n        t = -2.0 * t * t * t + 3.0 * t * t;\r\n        return to * t + from * (1.0 - t);\r\n    }\r\n    /**\r\n    * Moves a value current towards target.\r\n    *\r\n    * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n    * Negative values of maxDelta pushes the value away from target.\r\n    * @param current current value\r\n    * @param target target value\r\n    * @param maxDelta max distance to move\r\n    * @returns resulting value\r\n    */\r\n    static MoveTowards(current, target, maxDelta) {\r\n        var result = 0;\r\n        if (Math.abs(target - current) <= maxDelta) {\r\n            result = target;\r\n        }\r\n        else {\r\n            result = current + Scalar.Sign(target - current) * maxDelta;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n    * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n    *\r\n    * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n    *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n    * @param current current value\r\n    * @param target target value\r\n    * @param maxDelta max distance to move\r\n    * @returns resulting angle\r\n    */\r\n    static MoveTowardsAngle(current, target, maxDelta) {\r\n        var num = Scalar.DeltaAngle(current, target);\r\n        var result = 0;\r\n        if (-maxDelta < num && num < maxDelta) {\r\n            result = target;\r\n        }\r\n        else {\r\n            target = current + num;\r\n            result = Scalar.MoveTowards(current, target, maxDelta);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    static Lerp(start, end, amount) {\r\n        return start + ((end - start) * amount);\r\n    }\r\n    /**\r\n    * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n    * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n    * @param start start value\r\n    * @param end target value\r\n    * @param amount amount to lerp between\r\n    * @returns the lerped value\r\n    */\r\n    static LerpAngle(start, end, amount) {\r\n        var num = Scalar.Repeat(end - start, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return start + num * Scalar.Clamp(amount);\r\n    }\r\n    /**\r\n    * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n    * @param a start value\r\n    * @param b target value\r\n    * @param value value between a and b\r\n    * @returns the inverseLerp value\r\n    */\r\n    static InverseLerp(a, b, value) {\r\n        var result = 0;\r\n        if (a != b) {\r\n            result = Scalar.Clamp((value - a) / (b - a));\r\n        }\r\n        else {\r\n            result = 0.0;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n     * @param value1 spline value\r\n     * @param tangent1 spline value\r\n     * @param value2 spline value\r\n     * @param tangent2 spline value\r\n     * @param amount input value\r\n     * @returns hermite result\r\n     */\r\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n        return (((value1 * part1) + (value2 * part2)) + (tangent1 * part3)) + (tangent2 * part4);\r\n    }\r\n    /**\r\n    * Returns a random float number between and min and max values\r\n    * @param min min value of random\r\n    * @param max max value of random\r\n    * @returns random value\r\n    */\r\n    static RandomRange(min, max) {\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        return ((Math.random() * (max - min)) + min);\r\n    }\r\n    /**\r\n    * This function returns percentage of a number in a given range.\r\n    *\r\n    * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n    * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n    * @param number to convert to percentage\r\n    * @param min min range\r\n    * @param max max range\r\n    * @returns the percentage\r\n    */\r\n    static RangeToPercent(number, min, max) {\r\n        return ((number - min) / (max - min));\r\n    }\r\n    /**\r\n    * This function returns number that corresponds to the percentage in a given range.\r\n    *\r\n    * PercentToRange(0.34,0,100) will return 34.\r\n    * @param percent to convert to number\r\n    * @param min min range\r\n    * @param max max range\r\n    * @returns the number\r\n    */\r\n    static PercentToRange(percent, min, max) {\r\n        return ((max - min) * percent + min);\r\n    }\r\n    /**\r\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n     * @param angle The angle to normalize in radian.\r\n     * @return The converted angle.\r\n     */\r\n    static NormalizeRadians(angle) {\r\n        // More precise but slower version kept for reference.\r\n        // angle = angle % Tools.TwoPi;\r\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n        //if (angle > Math.PI) {\r\n        //\tangle -= Tools.TwoPi;\r\n        //}\r\n        angle -= (Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi));\r\n        return angle;\r\n    }\r\n}\r\n/**\r\n * Two pi constants convenient for computation.\r\n */\r\nScalar.TwoPi = Math.PI * 2;\r\n\n\n//# sourceURL=webpack:///./src/babylon_math/Maths/math.scalar.ts?");

/***/ }),

/***/ "./src/babylon_math/Maths/math.ts":
/*!****************************************!*\
  !*** ./src/babylon_math/Maths/math.ts ***!
  \****************************************/
/*! exports provided: ToGammaSpace, ToLinearSpace, Epsilon, Color3, Color4, Vector2, Vector3, Vector4, Size, Quaternion, Matrix, Plane, Viewport, Frustum, Space, Axis, BezierCurve, Orientation, Angle, Arc2, Path2, Path3D, Curve3, PositionNormalVertex, PositionNormalTextureVertex, Tmp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ToGammaSpace\", function() { return ToGammaSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ToLinearSpace\", function() { return ToLinearSpace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Epsilon\", function() { return Epsilon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color3\", function() { return Color3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color4\", function() { return Color4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return Vector2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return Vector4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Size\", function() { return Size; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return Quaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix\", function() { return Matrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return Plane; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewport\", function() { return Viewport; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Frustum\", function() { return Frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Space\", function() { return Space; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Axis\", function() { return Axis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BezierCurve\", function() { return BezierCurve; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Orientation\", function() { return Orientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Angle\", function() { return Angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Arc2\", function() { return Arc2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path2\", function() { return Path2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path3D\", function() { return Path3D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Curve3\", function() { return Curve3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionNormalVertex\", function() { return PositionNormalVertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionNormalTextureVertex\", function() { return PositionNormalTextureVertex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tmp\", function() { return Tmp; });\n/* harmony import */ var _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Misc/arrayTools */ \"./src/babylon_math/Misc/arrayTools.ts\");\n/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.scalar */ \"./src/babylon_math/Maths/math.scalar.ts\");\n\r\n\r\n/**\r\n * Constant used to convert a value to gamma space\r\n * @ignorenaming\r\n */\r\nconst ToGammaSpace = 1 / 2.2;\r\n/**\r\n * Constant used to convert a value to linear space\r\n * @ignorenaming\r\n */\r\nconst ToLinearSpace = 2.2;\r\n/**\r\n * Constant used to define the minimal number value in Babylon.js\r\n * @ignorenaming\r\n */\r\nlet Epsilon = 0.001;\r\n\r\n/**\r\n * Class used to hold a RBG color\r\n */\r\nclass Color3 {\r\n    /**\r\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     */\r\n    constructor(\r\n    /**\r\n     * Defines the red component (between 0 and 1, default is 0)\r\n     */\r\n    r = 0, \r\n    /**\r\n     * Defines the green component (between 0 and 1, default is 0)\r\n     */\r\n    g = 0, \r\n    /**\r\n     * Defines the blue component (between 0 and 1, default is 0)\r\n     */\r\n    b = 0) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n    /**\r\n     * Creates a string with the Color3 current values\r\n     * @returns the string representation of the Color3 object\r\n     */\r\n    toString() {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\r\n    }\r\n    /**\r\n     * Returns the string \"Color3\"\r\n     * @returns \"Color3\"\r\n     */\r\n    getClassName() {\r\n        return \"Color3\";\r\n    }\r\n    /**\r\n     * Compute the Color3 hash code\r\n     * @returns an unique number that can be used to hash Color3 objects\r\n     */\r\n    getHashCode() {\r\n        let hash = this.r || 0;\r\n        hash = (hash * 397) ^ (this.g || 0);\r\n        hash = (hash * 397) ^ (this.b || 0);\r\n        return hash;\r\n    }\r\n    // Operators\r\n    /**\r\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color3 object\r\n     */\r\n    toArray(array, index = 0) {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Color4 object from the current Color3 and the given alpha\r\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\r\n     * @returns a new Color4 object\r\n     */\r\n    toColor4(alpha = 1) {\r\n        return new Color4(this.r, this.g, this.b, alpha);\r\n    }\r\n    /**\r\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\r\n     * @returns the new array\r\n     */\r\n    asArray() {\r\n        var result = new Array();\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n    /**\r\n     * Returns the luminance value\r\n     * @returns a float value\r\n     */\r\n    toLuminance() {\r\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\r\n    }\r\n    /**\r\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3 object\r\n     */\r\n    multiply(otherColor) {\r\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\r\n    }\r\n    /**\r\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the current Color3\r\n     */\r\n    multiplyToRef(otherColor, result) {\r\n        result.r = this.r * otherColor.r;\r\n        result.g = this.g * otherColor.g;\r\n        result.b = this.b * otherColor.b;\r\n        return this;\r\n    }\r\n    /**\r\n     * Determines equality between Color3 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    equals(otherColor) {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\r\n    }\r\n    /**\r\n     * Determines equality between the current Color3 object and a set of r,b,g values\r\n     * @param r defines the red component to check\r\n     * @param g defines the green component to check\r\n     * @param b defines the blue component to check\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    equalsFloats(r, g, b) {\r\n        return this.r === r && this.g === g && this.b === b;\r\n    }\r\n    /**\r\n     * Multiplies in place each rgb value by scale\r\n     * @param scale defines the scaling factor\r\n     * @returns the updated Color3\r\n     */\r\n    scale(scale) {\r\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\r\n    }\r\n    /**\r\n     * Multiplies the rgb values by scale and stores the result into \"result\"\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the unmodified current Color3\r\n     */\r\n    scaleToRef(scale, result) {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Scale the current Color3 values by a factor and add the result to a given Color3\r\n     * @param scale defines the scale factor\r\n     * @param result defines color to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into\r\n     * @returns the original Color3\r\n     */\r\n    clampToRef(min = 0, max = 1, result) {\r\n        result.r = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.r, min, max);\r\n        result.g = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.g, min, max);\r\n        result.b = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.b, min, max);\r\n        return this;\r\n    }\r\n    /**\r\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    add(otherColor) {\r\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\r\n    }\r\n    /**\r\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    addToRef(otherColor, result) {\r\n        result.r = this.r + otherColor.r;\r\n        result.g = this.g + otherColor.g;\r\n        result.b = this.b + otherColor.b;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    subtract(otherColor) {\r\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\r\n    }\r\n    /**\r\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    subtractToRef(otherColor, result) {\r\n        result.r = this.r - otherColor.r;\r\n        result.g = this.g - otherColor.g;\r\n        result.b = this.b - otherColor.b;\r\n        return this;\r\n    }\r\n    /**\r\n     * Copy the current object\r\n     * @returns a new Color3 copied the current one\r\n     */\r\n    clone() {\r\n        return new Color3(this.r, this.g, this.b);\r\n    }\r\n    /**\r\n     * Copies the rgb values from the source in the current Color3\r\n     * @param source defines the source Color3 object\r\n     * @returns the updated Color3 object\r\n     */\r\n    copyFrom(source) {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    copyFromFloats(r, g, b) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    set(r, g, b) {\r\n        return this.copyFromFloats(r, g, b);\r\n    }\r\n    /**\r\n     * Compute the Color3 hexadecimal code as a string\r\n     * @returns a string containing the hexadecimal representation of the Color3 object\r\n     */\r\n    toHexString() {\r\n        var intR = (this.r * 255) | 0;\r\n        var intG = (this.g * 255) | 0;\r\n        var intB = (this.b * 255) | 0;\r\n        return \"#\" + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intR) + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intG) + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intB);\r\n    }\r\n    /**\r\n     * Computes a new Color3 converted from the current one to linear space\r\n     * @returns a new Color3 object\r\n     */\r\n    toLinearSpace() {\r\n        var convertedColor = new Color3();\r\n        this.toLinearSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n    /**\r\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the linear space version\r\n     * @returns the unmodified Color3\r\n     */\r\n    toLinearSpaceToRef(convertedColor) {\r\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\r\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\r\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\r\n        return this;\r\n    }\r\n    /**\r\n     * Computes a new Color3 converted from the current one to gamma space\r\n     * @returns a new Color3 object\r\n     */\r\n    toGammaSpace() {\r\n        var convertedColor = new Color3();\r\n        this.toGammaSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n    /**\r\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the gamma space version\r\n     * @returns the unmodified Color3\r\n     */\r\n    toGammaSpaceToRef(convertedColor) {\r\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\r\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\r\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\r\n        return this;\r\n    }\r\n    /**\r\n     * Creates a new Color3 from the string containing valid hexadecimal values\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color3 object\r\n     */\r\n    static FromHexString(hex) {\r\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\r\n            return new Color3(0, 0, 0);\r\n        }\r\n        var r = parseInt(hex.substring(1, 3), 16);\r\n        var g = parseInt(hex.substring(3, 5), 16);\r\n        var b = parseInt(hex.substring(5, 7), 16);\r\n        return Color3.FromInts(r, g, b);\r\n    }\r\n    /**\r\n     * Creates a new Color3 from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Color3 object\r\n     */\r\n    static FromArray(array, offset = 0) {\r\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n    /**\r\n     * Creates a new Color3 from integer values (< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    static FromInts(r, g, b) {\r\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\r\n    }\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param start defines the start Color3 value\r\n     * @param end defines the end Color3 value\r\n     * @param amount defines the gradient value between start and end\r\n     * @returns a new Color3 object\r\n     */\r\n    static Lerp(start, end, amount) {\r\n        var result = new Color3(0.0, 0.0, 0.0);\r\n        Color3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color3 object where to store the result\r\n     */\r\n    static LerpToRef(left, right, amount, result) {\r\n        result.r = left.r + ((right.r - left.r) * amount);\r\n        result.g = left.g + ((right.g - left.g) * amount);\r\n        result.b = left.b + ((right.b - left.b) * amount);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a red color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Red() { return new Color3(1, 0, 0); }\r\n    /**\r\n     * Returns a Color3 value containing a green color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Green() { return new Color3(0, 1, 0); }\r\n    /**\r\n     * Returns a Color3 value containing a blue color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Blue() { return new Color3(0, 0, 1); }\r\n    /**\r\n     * Returns a Color3 value containing a black color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Black() { return new Color3(0, 0, 0); }\r\n    /**\r\n      * Gets a Color3 value containing a black color that must not be updated\r\n      */\r\n    static get BlackReadOnly() {\r\n        return Color3._BlackReadOnly;\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a white color\r\n     * @returns a new Color3 object\r\n     */\r\n    static White() { return new Color3(1, 1, 1); }\r\n    /**\r\n     * Returns a Color3 value containing a purple color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Purple() { return new Color3(0.5, 0, 0.5); }\r\n    /**\r\n     * Returns a Color3 value containing a magenta color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Magenta() { return new Color3(1, 0, 1); }\r\n    /**\r\n     * Returns a Color3 value containing a yellow color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Yellow() { return new Color3(1, 1, 0); }\r\n    /**\r\n     * Returns a Color3 value containing a gray color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Gray() { return new Color3(0.5, 0.5, 0.5); }\r\n    /**\r\n     * Returns a Color3 value containing a teal color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Teal() { return new Color3(0, 1.0, 1.0); }\r\n    /**\r\n     * Returns a Color3 value containing a random color\r\n     * @returns a new Color3 object\r\n     */\r\n    static Random() { return new Color3(Math.random(), Math.random(), Math.random()); }\r\n}\r\n// Statics\r\nColor3._BlackReadOnly = Color3.Black();\r\n/**\r\n * Class used to hold a RBGA color\r\n */\r\nclass Color4 {\r\n    /**\r\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     * @param a defines the alpha component (between 0 and 1, default is 1)\r\n     */\r\n    constructor(\r\n    /**\r\n     * Defines the red component (between 0 and 1, default is 0)\r\n     */\r\n    r = 0, \r\n    /**\r\n     * Defines the green component (between 0 and 1, default is 0)\r\n     */\r\n    g = 0, \r\n    /**\r\n     * Defines the blue component (between 0 and 1, default is 0)\r\n     */\r\n    b = 0, \r\n    /**\r\n     * Defines the alpha component (between 0 and 1, default is 1)\r\n     */\r\n    a = 1) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n    }\r\n    // Operators\r\n    /**\r\n     * Adds in place the given Color4 values to the current Color4 object\r\n     * @param right defines the second operand\r\n     * @returns the current updated Color4 object\r\n     */\r\n    addInPlace(right) {\r\n        this.r += right.r;\r\n        this.g += right.g;\r\n        this.b += right.b;\r\n        this.a += right.a;\r\n        return this;\r\n    }\r\n    /**\r\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\r\n     * @returns the new array\r\n     */\r\n    asArray() {\r\n        var result = new Array();\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n    /**\r\n     * Stores from the starting index in the given array the Color4 successive values\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color4 object\r\n     */\r\n    toArray(array, index = 0) {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n        array[index + 3] = this.a;\r\n        return this;\r\n    }\r\n    /**\r\n     * Determines equality between Color4 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgba values are equal to the given ones\r\n     */\r\n    equals(otherColor) {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\r\n    }\r\n    /**\r\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\r\n     * @param right defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    add(right) {\r\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\r\n    }\r\n    /**\r\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\r\n     * @param right defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    subtract(right) {\r\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\r\n    }\r\n    /**\r\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\r\n     * @param right defines the second operand\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the current Color4 object\r\n     */\r\n    subtractToRef(right, result) {\r\n        result.r = this.r - right.r;\r\n        result.g = this.g - right.g;\r\n        result.b = this.b - right.b;\r\n        result.a = this.a - right.a;\r\n        return this;\r\n    }\r\n    /**\r\n     * Creates a new Color4 with the current Color4 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color4 object\r\n     */\r\n    scale(scale) {\r\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\r\n    }\r\n    /**\r\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the current unmodified Color4\r\n     */\r\n    scaleToRef(scale, result) {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        result.a = this.a * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Scale the current Color4 values by a factor and add the result to a given Color4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the unmodified current Color4\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        result.a += this.a * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into.\r\n     * @returns the cuurent Color4\r\n     */\r\n    clampToRef(min = 0, max = 1, result) {\r\n        result.r = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.r, min, max);\r\n        result.g = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.g, min, max);\r\n        result.b = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.b, min, max);\r\n        result.a = _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].Clamp(this.a, min, max);\r\n        return this;\r\n    }\r\n    /**\r\n      * Multipy an Color4 value by another and return a new Color4 object\r\n      * @param color defines the Color4 value to multiply by\r\n      * @returns a new Color4 object\r\n      */\r\n    multiply(color) {\r\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\r\n    }\r\n    /**\r\n     * Multipy a Color4 value by another and push the result in a reference value\r\n     * @param color defines the Color4 value to multiply by\r\n     * @param result defines the Color4 to fill the result in\r\n     * @returns the result Color4\r\n     */\r\n    multiplyToRef(color, result) {\r\n        result.r = this.r * color.r;\r\n        result.g = this.g * color.g;\r\n        result.b = this.b * color.b;\r\n        result.a = this.a * color.a;\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a string with the Color4 current values\r\n     * @returns the string representation of the Color4 object\r\n     */\r\n    toString() {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\r\n    }\r\n    /**\r\n     * Returns the string \"Color4\"\r\n     * @returns \"Color4\"\r\n     */\r\n    getClassName() {\r\n        return \"Color4\";\r\n    }\r\n    /**\r\n     * Compute the Color4 hash code\r\n     * @returns an unique number that can be used to hash Color4 objects\r\n     */\r\n    getHashCode() {\r\n        let hash = this.r || 0;\r\n        hash = (hash * 397) ^ (this.g || 0);\r\n        hash = (hash * 397) ^ (this.b || 0);\r\n        hash = (hash * 397) ^ (this.a || 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Creates a new Color4 copied from the current one\r\n     * @returns a new Color4 object\r\n     */\r\n    clone() {\r\n        return new Color4(this.r, this.g, this.b, this.a);\r\n    }\r\n    /**\r\n     * Copies the given Color4 values into the current one\r\n     * @param source defines the source Color4 object\r\n     * @returns the current updated Color4 object\r\n     */\r\n    copyFrom(source) {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        this.a = source.a;\r\n        return this;\r\n    }\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    copyFromFloats(r, g, b, a) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this;\r\n    }\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    set(r, g, b, a) {\r\n        return this.copyFromFloats(r, g, b, a);\r\n    }\r\n    /**\r\n     * Compute the Color4 hexadecimal code as a string\r\n     * @returns a string containing the hexadecimal representation of the Color4 object\r\n     */\r\n    toHexString() {\r\n        var intR = (this.r * 255) | 0;\r\n        var intG = (this.g * 255) | 0;\r\n        var intB = (this.b * 255) | 0;\r\n        var intA = (this.a * 255) | 0;\r\n        return \"#\" + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intR) + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intG) + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intB) + _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].ToHex(intA);\r\n    }\r\n    /**\r\n     * Computes a new Color4 converted from the current one to linear space\r\n     * @returns a new Color4 object\r\n     */\r\n    toLinearSpace() {\r\n        var convertedColor = new Color4();\r\n        this.toLinearSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n    /**\r\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the linear space version\r\n     * @returns the unmodified Color4\r\n     */\r\n    toLinearSpaceToRef(convertedColor) {\r\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\r\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\r\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n    /**\r\n     * Computes a new Color4 converted from the current one to gamma space\r\n     * @returns a new Color4 object\r\n     */\r\n    toGammaSpace() {\r\n        var convertedColor = new Color4();\r\n        this.toGammaSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n    /**\r\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the gamma space version\r\n     * @returns the unmodified Color4\r\n     */\r\n    toGammaSpaceToRef(convertedColor) {\r\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\r\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\r\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n    // Statics\r\n    /**\r\n     * Creates a new Color4 from the string containing valid hexadecimal values\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color4 object\r\n     */\r\n    static FromHexString(hex) {\r\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 9) {\r\n            return new Color4(0.0, 0.0, 0.0, 0.0);\r\n        }\r\n        var r = parseInt(hex.substring(1, 3), 16);\r\n        var g = parseInt(hex.substring(3, 5), 16);\r\n        var b = parseInt(hex.substring(5, 7), 16);\r\n        var a = parseInt(hex.substring(7, 9), 16);\r\n        return Color4.FromInts(r, g, b, a);\r\n    }\r\n    /**\r\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @returns a new Color4 object\r\n     */\r\n    static Lerp(left, right, amount) {\r\n        var result = new Color4(0.0, 0.0, 0.0, 0.0);\r\n        Color4.LerpToRef(left, right, amount, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color4 object where to store data\r\n     */\r\n    static LerpToRef(left, right, amount, result) {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n        result.a = left.a + (right.a - left.a) * amount;\r\n    }\r\n    /**\r\n     * Creates a new Color4 from a Color3 and an alpha value\r\n     * @param color3 defines the source Color3 to read from\r\n     * @param alpha defines the alpha component (1.0 by default)\r\n     * @returns a new Color4 object\r\n     */\r\n    static FromColor3(color3, alpha = 1.0) {\r\n        return new Color4(color3.r, color3.g, color3.b, alpha);\r\n    }\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @returns a new Color4 object\r\n     */\r\n    static FromArray(array, offset = 0) {\r\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n    /**\r\n     * Creates a new Color3 from integer values (< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @param a defines the alpha component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    static FromInts(r, g, b, a) {\r\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\r\n    }\r\n    /**\r\n     * Check the content of a given array and convert it to an array containing RGBA data\r\n     * If the original array was already containing count * 4 values then it is returned directly\r\n     * @param colors defines the array to check\r\n     * @param count defines the number of RGBA data to expect\r\n     * @returns an array containing count * 4 values (RGBA)\r\n     */\r\n    static CheckColors4(colors, count) {\r\n        // Check if color3 was used\r\n        if (colors.length === count * 3) {\r\n            var colors4 = [];\r\n            for (var index = 0; index < colors.length; index += 3) {\r\n                var newIndex = (index / 3) * 4;\r\n                colors4[newIndex] = colors[index];\r\n                colors4[newIndex + 1] = colors[index + 1];\r\n                colors4[newIndex + 2] = colors[index + 2];\r\n                colors4[newIndex + 3] = 1.0;\r\n            }\r\n            return colors4;\r\n        }\r\n        return colors;\r\n    }\r\n}\r\n/**\r\n * Class representing a vector containing 2 coordinates\r\n */\r\nclass Vector2 {\r\n    /**\r\n     * Creates a new Vector2 from the given x and y coordinates\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     */\r\n    constructor(\r\n    /** defines the first coordinate */\r\n    x = 0, \r\n    /** defines the second coordinate */\r\n    y = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    /**\r\n     * Gets a string with the Vector2 coordinates\r\n     * @returns a string with the Vector2 coordinates\r\n     */\r\n    toString() {\r\n        return \"{X: \" + this.x + \" Y:\" + this.y + \"}\";\r\n    }\r\n    /**\r\n     * Gets class name\r\n     * @returns the string \"Vector2\"\r\n     */\r\n    getClassName() {\r\n        return \"Vector2\";\r\n    }\r\n    /**\r\n     * Gets current vector hash code\r\n     * @returns the Vector2 hash code as a number\r\n     */\r\n    getHashCode() {\r\n        let hash = this.x || 0;\r\n        hash = (hash * 397) ^ (this.y || 0);\r\n        return hash;\r\n    }\r\n    // Operators\r\n    /**\r\n     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.\r\n     * @param array defines the source array\r\n     * @param index defines the offset in source array\r\n     * @returns the current Vector2\r\n     */\r\n    toArray(array, index = 0) {\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Copy the current vector to an array\r\n     * @returns a new array with 2 elements: the Vector2 coordinates.\r\n     */\r\n    asArray() {\r\n        var result = new Array();\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the Vector2 coordinates with the given Vector2 coordinates\r\n     * @param source defines the source Vector2\r\n     * @returns the current updated Vector2\r\n     */\r\n    copyFrom(source) {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the Vector2 coordinates with the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns the current updated Vector2\r\n     */\r\n    copyFromFloats(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the Vector2 coordinates with the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns the current updated Vector2\r\n     */\r\n    set(x, y) {\r\n        return this.copyFromFloats(x, y);\r\n    }\r\n    /**\r\n     * Add another vector with the current one\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\r\n     */\r\n    add(otherVector) {\r\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\r\n    }\r\n    /**\r\n     * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    addToRef(otherVector, result) {\r\n        result.x = this.x + otherVector.x;\r\n        result.y = this.y + otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Set the Vector2 coordinates by adding the given Vector2 coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    addInPlace(otherVector) {\r\n        this.x += otherVector.x;\r\n        this.y += otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    addVector3(otherVector) {\r\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\r\n    }\r\n    /**\r\n     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    subtract(otherVector) {\r\n        return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\r\n    }\r\n    /**\r\n     * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    subtractToRef(otherVector, result) {\r\n        result.x = this.x - otherVector.x;\r\n        result.y = this.y - otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    subtractInPlace(otherVector) {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Multiplies in place the current Vector2 coordinates by the given ones\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    multiplyInPlace(otherVector) {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    multiply(otherVector) {\r\n        return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\r\n    }\r\n    /**\r\n     * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    multiplyToRef(otherVector, result) {\r\n        result.x = this.x * otherVector.x;\r\n        result.y = this.y * otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\r\n     * @param x defines the first coordinate\r\n     * @param y defines the second coordinate\r\n     * @returns a new Vector2\r\n     */\r\n    multiplyByFloats(x, y) {\r\n        return new Vector2(this.x * x, this.y * y);\r\n    }\r\n    /**\r\n     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @returns a new Vector2\r\n     */\r\n    divide(otherVector) {\r\n        return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\r\n    }\r\n    /**\r\n     * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\r\n     * @param otherVector defines the other vector\r\n     * @param result defines the target vector\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    divideToRef(otherVector, result) {\r\n        result.x = this.x / otherVector.x;\r\n        result.y = this.y / otherVector.y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Divides the current Vector2 coordinates by the given ones\r\n     * @param otherVector defines the other vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    divideInPlace(otherVector) {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n    /**\r\n     * Gets a new Vector2 with current Vector2 negated coordinates\r\n     * @returns a new Vector2\r\n     */\r\n    negate() {\r\n        return new Vector2(-this.x, -this.y);\r\n    }\r\n    /**\r\n     * Multiply the Vector2 coordinates by scale\r\n     * @param scale defines the scaling factor\r\n     * @returns the current updated Vector2\r\n     */\r\n    scaleInPlace(scale) {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector2 scaled by \"scale\" from the current Vector2\r\n     * @param scale defines the scaling factor\r\n     * @returns a new Vector2\r\n     */\r\n    scale(scale) {\r\n        let result = new Vector2(0, 0);\r\n        this.scaleToRef(scale, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Scale the current Vector2 values by a factor to a given Vector2\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector2 object where to store the result\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    scaleToRef(scale, result) {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Scale the current Vector2 values by a factor and add the result to a given Vector2\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector2 object where to store the result\r\n     * @returns the unmodified current Vector2\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets a boolean if two vectors are equals\r\n     * @param otherVector defines the other vector\r\n     * @returns true if the given vector coordinates strictly equal the current Vector2 ones\r\n     */\r\n    equals(otherVector) {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y;\r\n    }\r\n    /**\r\n     * Gets a boolean if two vectors are equals (using an epsilon value)\r\n     * @param otherVector defines the other vector\r\n     * @param epsilon defines the minimal distance to consider equality\r\n     * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\r\n     */\r\n    equalsWithEpsilon(otherVector, epsilon = Epsilon) {\r\n        return otherVector && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.x, otherVector.x, epsilon) && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.y, otherVector.y, epsilon);\r\n    }\r\n    /**\r\n     * Gets a new Vector2 from current Vector2 floored values\r\n     * @returns a new Vector2\r\n     */\r\n    floor() {\r\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\r\n    }\r\n    /**\r\n     * Gets a new Vector2 from current Vector2 floored values\r\n     * @returns a new Vector2\r\n     */\r\n    fract() {\r\n        return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\r\n    }\r\n    // Properties\r\n    /**\r\n     * Gets the length of the vector\r\n     * @returns the vector length (float)\r\n     */\r\n    length() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n    /**\r\n     * Gets the vector squared length\r\n     * @returns the vector squared length (float)\r\n     */\r\n    lengthSquared() {\r\n        return (this.x * this.x + this.y * this.y);\r\n    }\r\n    // Methods\r\n    /**\r\n     * Normalize the vector\r\n     * @returns the current updated Vector2\r\n     */\r\n    normalize() {\r\n        var len = this.length();\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n        var num = 1.0 / len;\r\n        this.x *= num;\r\n        this.y *= num;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets a new Vector2 copied from the Vector2\r\n     * @returns a new Vector2\r\n     */\r\n    clone() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    // Statics\r\n    /**\r\n     * Gets a new Vector2(0, 0)\r\n     * @returns a new Vector2\r\n     */\r\n    static Zero() {\r\n        return new Vector2(0, 0);\r\n    }\r\n    /**\r\n     * Gets a new Vector2(1, 1)\r\n     * @returns a new Vector2\r\n     */\r\n    static One() {\r\n        return new Vector2(1, 1);\r\n    }\r\n    /**\r\n     * Gets a new Vector2 set from the given index element of the given array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the data source\r\n     * @returns a new Vector2\r\n     */\r\n    static FromArray(array, offset = 0) {\r\n        return new Vector2(array[offset], array[offset + 1]);\r\n    }\r\n    /**\r\n     * Sets \"result\" from the given index element of the given array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the data source\r\n     * @param result defines the target vector\r\n     */\r\n    static FromArrayToRef(array, offset, result) {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n    }\r\n    /**\r\n     * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\r\n     * @param value1 defines 1st point of control\r\n     * @param value2 defines 2nd point of control\r\n     * @param value3 defines 3rd point of control\r\n     * @param value4 defines 4th point of control\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    static CatmullRom(value1, value2, value3, value4, amount) {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) +\r\n            (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) +\r\n            ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\r\n        var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) +\r\n            (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) +\r\n            ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\r\n        return new Vector2(x, y);\r\n    }\r\n    /**\r\n     * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\r\n     * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\r\n     * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\r\n     * @param value defines the value to clamp\r\n     * @param min defines the lower limit\r\n     * @param max defines the upper limit\r\n     * @returns a new Vector2\r\n     */\r\n    static Clamp(value, min, max) {\r\n        var x = value.x;\r\n        x = (x > max.x) ? max.x : x;\r\n        x = (x < min.x) ? min.x : x;\r\n        var y = value.y;\r\n        y = (y > max.y) ? max.y : y;\r\n        y = (y < min.y) ? min.y : y;\r\n        return new Vector2(x, y);\r\n    }\r\n    /**\r\n     * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value3\", \"tangent1\", \"tangent2\"\r\n     * @param value1 defines the 1st control point\r\n     * @param tangent1 defines the outgoing tangent\r\n     * @param value2 defines the 2nd control point\r\n     * @param tangent2 defines the incoming tangent\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n        var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\r\n        var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\r\n        return new Vector2(x, y);\r\n    }\r\n    /**\r\n     * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\r\n     * @param start defines the start vector\r\n     * @param end defines the end vector\r\n     * @param amount defines the interpolation factor\r\n     * @returns a new Vector2\r\n     */\r\n    static Lerp(start, end, amount) {\r\n        var x = start.x + ((end.x - start.x) * amount);\r\n        var y = start.y + ((end.y - start.y) * amount);\r\n        return new Vector2(x, y);\r\n    }\r\n    /**\r\n     * Gets the dot product of the vector \"left\" and the vector \"right\"\r\n     * @param left defines first vector\r\n     * @param right defines second vector\r\n     * @returns the dot product (float)\r\n     */\r\n    static Dot(left, right) {\r\n        return left.x * right.x + left.y * right.y;\r\n    }\r\n    /**\r\n     * Returns a new Vector2 equal to the normalized given vector\r\n     * @param vector defines the vector to normalize\r\n     * @returns a new Vector2\r\n     */\r\n    static Normalize(vector) {\r\n        var newVector = vector.clone();\r\n        newVector.normalize();\r\n        return newVector;\r\n    }\r\n    /**\r\n     * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\r\n     * @param left defines 1st vector\r\n     * @param right defines 2nd vector\r\n     * @returns a new Vector2\r\n     */\r\n    static Minimize(left, right) {\r\n        var x = (left.x < right.x) ? left.x : right.x;\r\n        var y = (left.y < right.y) ? left.y : right.y;\r\n        return new Vector2(x, y);\r\n    }\r\n    /**\r\n     * Gets a new Vecto2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\r\n     * @param left defines 1st vector\r\n     * @param right defines 2nd vector\r\n     * @returns a new Vector2\r\n     */\r\n    static Maximize(left, right) {\r\n        var x = (left.x > right.x) ? left.x : right.x;\r\n        var y = (left.y > right.y) ? left.y : right.y;\r\n        return new Vector2(x, y);\r\n    }\r\n    /**\r\n     * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\r\n     * @param vector defines the vector to transform\r\n     * @param transformation defines the matrix to apply\r\n     * @returns a new Vector2\r\n     */\r\n    static Transform(vector, transformation) {\r\n        let r = Vector2.Zero();\r\n        Vector2.TransformToRef(vector, transformation, r);\r\n        return r;\r\n    }\r\n    /**\r\n     * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\r\n     * @param vector defines the vector to transform\r\n     * @param transformation defines the matrix to apply\r\n     * @param result defines the target vector\r\n     */\r\n    static TransformToRef(vector, transformation, result) {\r\n        const m = transformation.m;\r\n        var x = (vector.x * m[0]) + (vector.y * m[4]) + m[12];\r\n        var y = (vector.x * m[1]) + (vector.y * m[5]) + m[13];\r\n        result.x = x;\r\n        result.y = y;\r\n    }\r\n    /**\r\n     * Determines if a given vector is included in a triangle\r\n     * @param p defines the vector to test\r\n     * @param p0 defines 1st triangle point\r\n     * @param p1 defines 2nd triangle point\r\n     * @param p2 defines 3rd triangle point\r\n     * @returns true if the point \"p\" is in the triangle defined by the vertors \"p0\", \"p1\", \"p2\"\r\n     */\r\n    static PointInTriangle(p, p0, p1, p2) {\r\n        let a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\r\n        let sign = a < 0 ? -1 : 1;\r\n        let s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\r\n        let t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\r\n        return s > 0 && t > 0 && (s + t) < 2 * a * sign;\r\n    }\r\n    /**\r\n     * Gets the distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns the distance between vectors\r\n     */\r\n    static Distance(value1, value2) {\r\n        return Math.sqrt(Vector2.DistanceSquared(value1, value2));\r\n    }\r\n    /**\r\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns the squared distance between vectors\r\n     */\r\n    static DistanceSquared(value1, value2) {\r\n        var x = value1.x - value2.x;\r\n        var y = value1.y - value2.y;\r\n        return (x * x) + (y * y);\r\n    }\r\n    /**\r\n     * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines first vector\r\n     * @param value2 defines second vector\r\n     * @returns a new Vector2\r\n     */\r\n    static Center(value1, value2) {\r\n        var center = value1.add(value2);\r\n        center.scaleInPlace(0.5);\r\n        return center;\r\n    }\r\n    /**\r\n     * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\r\n     * @param p defines the middle point\r\n     * @param segA defines one point of the segment\r\n     * @param segB defines the other point of the segment\r\n     * @returns the shortest distance\r\n     */\r\n    static DistanceOfPointFromSegment(p, segA, segB) {\r\n        let l2 = Vector2.DistanceSquared(segA, segB);\r\n        if (l2 === 0.0) {\r\n            return Vector2.Distance(p, segA);\r\n        }\r\n        let v = segB.subtract(segA);\r\n        let t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\r\n        let proj = segA.add(v.multiplyByFloats(t, t));\r\n        return Vector2.Distance(p, proj);\r\n    }\r\n}\r\n/**\r\n * Classed used to store (x,y,z) vector representation\r\n * A Vector3 is the main object used in 3D geometry\r\n * It can represent etiher the coordinates of a point the space, either a direction\r\n * Reminder: js uses a left handed forward facing system\r\n */\r\nclass Vector3 {\r\n    /**\r\n     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\r\n     * @param x defines the first coordinates (on X axis)\r\n     * @param y defines the second coordinates (on Y axis)\r\n     * @param z defines the third coordinates (on Z axis)\r\n     */\r\n    constructor(\r\n    /**\r\n     * Defines the first coordinates (on X axis)\r\n     */\r\n    x = 0, \r\n    /**\r\n     * Defines the second coordinates (on Y axis)\r\n     */\r\n    y = 0, \r\n    /**\r\n     * Defines the third coordinates (on Z axis)\r\n     */\r\n    z = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    /**\r\n     * Creates a string representation of the Vector3\r\n     * @returns a string with the Vector3 coordinates.\r\n     */\r\n    toString() {\r\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \"}\";\r\n    }\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"Vector3\"\r\n     */\r\n    getClassName() {\r\n        return \"Vector3\";\r\n    }\r\n    /**\r\n     * Creates the Vector3 hash code\r\n     * @returns a number which tends to be unique between Vector3 instances\r\n     */\r\n    getHashCode() {\r\n        let hash = this.x || 0;\r\n        hash = (hash * 397) ^ (this.y || 0);\r\n        hash = (hash * 397) ^ (this.z || 0);\r\n        return hash;\r\n    }\r\n    // Operators\r\n    /**\r\n     * Creates an array containing three elements : the coordinates of the Vector3\r\n     * @returns a new array of numbers\r\n     */\r\n    asArray() {\r\n        var result = [];\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n    /**\r\n     * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3\r\n     * @param array defines the destination array\r\n     * @param index defines the offset in the destination array\r\n     * @returns the current Vector3\r\n     */\r\n    toArray(array, index = 0) {\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        array[index + 2] = this.z;\r\n        return this;\r\n    }\r\n    /**\r\n     * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\r\n     * @returns a new Quaternion object, computed from the Vector3 coordinates\r\n     */\r\n    toQuaternion() {\r\n        return Quaternion.RotationYawPitchRoll(this.y, this.x, this.z);\r\n    }\r\n    /**\r\n     * Adds the given vector to the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    addInPlace(otherVector) {\r\n        return this.addInPlaceFromFloats(otherVector.x, otherVector.y, otherVector.z);\r\n    }\r\n    /**\r\n     * Adds the given coordinates to the current Vector3\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    addInPlaceFromFloats(x, y, z) {\r\n        this.x += x;\r\n        this.y += y;\r\n        this.z += z;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets a new Vector3, result of the addition the current Vector3 and the given vector\r\n     * @param otherVector defines the second operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    add(otherVector) {\r\n        return new Vector3(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\r\n    }\r\n    /**\r\n     * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    addToRef(otherVector, result) {\r\n        return result.copyFromFloats(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\r\n    }\r\n    /**\r\n     * Subtract the given vector from the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    subtractInPlace(otherVector) {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        this.z -= otherVector.z;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\r\n     * @param otherVector defines the second operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    subtract(otherVector) {\r\n        return new Vector3(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z);\r\n    }\r\n    /**\r\n     * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    subtractToRef(otherVector, result) {\r\n        return this.subtractFromFloatsToRef(otherVector.x, otherVector.y, otherVector.z, result);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the resulting Vector3\r\n     */\r\n    subtractFromFloats(x, y, z) {\r\n        return new Vector3(this.x - x, this.y - y, this.z - z);\r\n    }\r\n    /**\r\n     * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    subtractFromFloatsToRef(x, y, z, result) {\r\n        return result.copyFromFloats(this.x - x, this.y - y, this.z - z);\r\n    }\r\n    /**\r\n     * Gets a new Vector3 set with the current Vector3 negated coordinates\r\n     * @returns a new Vector3\r\n     */\r\n    negate() {\r\n        return new Vector3(-this.x, -this.y, -this.z);\r\n    }\r\n    /**\r\n     * Multiplies the Vector3 coordinates by the float \"scale\"\r\n     * @param scale defines the multiplier factor\r\n     * @returns the current updated Vector3\r\n     */\r\n    scaleInPlace(scale) {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\r\n     * @param scale defines the multiplier factor\r\n     * @returns a new Vector3\r\n     */\r\n    scale(scale) {\r\n        return new Vector3(this.x * scale, this.y * scale, this.z * scale);\r\n    }\r\n    /**\r\n     * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\r\n     * @param scale defines the multiplier factor\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    scaleToRef(scale, result) {\r\n        return result.copyFromFloats(this.x * scale, this.y * scale, this.z * scale);\r\n    }\r\n    /**\r\n     * Scale the current Vector3 values by a factor and add the result to a given Vector3\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the unmodified current Vector3\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        return result.addInPlaceFromFloats(this.x * scale, this.y * scale, this.z * scale);\r\n    }\r\n    /**\r\n     * Returns true if the current Vector3 and the given vector coordinates are strictly equal\r\n     * @param otherVector defines the second operand\r\n     * @returns true if both vectors are equals\r\n     */\r\n    equals(otherVector) {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z;\r\n    }\r\n    /**\r\n     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\r\n     * @param otherVector defines the second operand\r\n     * @param epsilon defines the minimal distance to define values as equals\r\n     * @returns true if both vectors are distant less than epsilon\r\n     */\r\n    equalsWithEpsilon(otherVector, epsilon = Epsilon) {\r\n        return otherVector && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.x, otherVector.x, epsilon) && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.y, otherVector.y, epsilon) && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.z, otherVector.z, epsilon);\r\n    }\r\n    /**\r\n     * Returns true if the current Vector3 coordinates equals the given floats\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns true if both vectors are equals\r\n     */\r\n    equalsToFloats(x, y, z) {\r\n        return this.x === x && this.y === y && this.z === z;\r\n    }\r\n    /**\r\n     * Multiplies the current Vector3 coordinates by the given ones\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    multiplyInPlace(otherVector) {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        this.z *= otherVector.z;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\r\n     * @param otherVector defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    multiply(otherVector) {\r\n        return this.multiplyByFloats(otherVector.x, otherVector.y, otherVector.z);\r\n    }\r\n    /**\r\n     * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    multiplyToRef(otherVector, result) {\r\n        return result.copyFromFloats(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the new Vector3\r\n     */\r\n    multiplyByFloats(x, y, z) {\r\n        return new Vector3(this.x * x, this.y * y, this.z * z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\r\n     * @param otherVector defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    divide(otherVector) {\r\n        return new Vector3(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\r\n    }\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\r\n     * @param otherVector defines the second operand\r\n     * @param result defines the Vector3 object where to store the result\r\n     * @returns the current Vector3\r\n     */\r\n    divideToRef(otherVector, result) {\r\n        return result.copyFromFloats(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\r\n    }\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones.\r\n     * @param otherVector defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    divideInPlace(otherVector) {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n    /**\r\n     * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    minimizeInPlace(other) {\r\n        return this.minimizeInPlaceFromFloats(other.x, other.y, other.z);\r\n    }\r\n    /**\r\n     * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    maximizeInPlace(other) {\r\n        return this.maximizeInPlaceFromFloats(other.x, other.y, other.z);\r\n    }\r\n    /**\r\n     * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    minimizeInPlaceFromFloats(x, y, z) {\r\n        if (x < this.x) {\r\n            this.x = x;\r\n        }\r\n        if (y < this.y) {\r\n            this.y = y;\r\n        }\r\n        if (z < this.z) {\r\n            this.z = z;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    maximizeInPlaceFromFloats(x, y, z) {\r\n        if (x > this.x) {\r\n            this.x = x;\r\n        }\r\n        if (y > this.y) {\r\n            this.y = y;\r\n        }\r\n        if (z > this.z) {\r\n            this.z = z;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction\r\n     * Check if is non uniform within a certain amount of decimal places to account for this\r\n     * @param epsilon the amount the values can differ\r\n     * @returns if the the vector is non uniform to a certain number of decimal places\r\n     */\r\n    isNonUniformWithinEpsilon(epsilon) {\r\n        let absX = Math.abs(this.x);\r\n        let absY = Math.abs(this.y);\r\n        if (!_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(absX, absY, epsilon)) {\r\n            return true;\r\n        }\r\n        let absZ = Math.abs(this.z);\r\n        if (!_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(absX, absZ, epsilon)) {\r\n            return true;\r\n        }\r\n        if (!_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(absY, absZ, epsilon)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\r\n     */\r\n    get isNonUniform() {\r\n        let absX = Math.abs(this.x);\r\n        let absY = Math.abs(this.y);\r\n        if (absX !== absY) {\r\n            return true;\r\n        }\r\n        let absZ = Math.abs(this.z);\r\n        if (absX !== absZ) {\r\n            return true;\r\n        }\r\n        if (absY !== absZ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Gets a new Vector3 from current Vector3 floored values\r\n     * @returns a new Vector3\r\n     */\r\n    floor() {\r\n        return new Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\r\n    }\r\n    /**\r\n     * Gets a new Vector3 from current Vector3 floored values\r\n     * @returns a new Vector3\r\n     */\r\n    fract() {\r\n        return new Vector3(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z));\r\n    }\r\n    // Properties\r\n    /**\r\n     * Gets the length of the Vector3\r\n     * @returns the length of the Vecto3\r\n     */\r\n    length() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n    }\r\n    /**\r\n     * Gets the squared length of the Vector3\r\n     * @returns squared length of the Vector3\r\n     */\r\n    lengthSquared() {\r\n        return (this.x * this.x + this.y * this.y + this.z * this.z);\r\n    }\r\n    /**\r\n     * Normalize the current Vector3.\r\n     * Please note that this is an in place operation.\r\n     * @returns the current updated Vector3\r\n     */\r\n    normalize() {\r\n        return this.normalizeFromLength(this.length());\r\n    }\r\n    /**\r\n     * Reorders the x y z properties of the vector in place\r\n     * @param order new ordering of the properties (eg. for vector 1,2,3 with \"ZYX\" will produce 3,2,1)\r\n     * @returns the current updated vector\r\n     */\r\n    reorderInPlace(order) {\r\n        order = order.toLowerCase();\r\n        if (order === \"xyz\") {\r\n            return this;\r\n        }\r\n        MathTmp.Vector3[0].copyFrom(this);\r\n        [\"x\", \"y\", \"z\"].forEach((val, i) => {\r\n            this[val] = MathTmp.Vector3[0][order[i]];\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * Rotates the vector around 0,0,0 by a quaternion\r\n     * @param quaternion the rotation quaternion\r\n     * @param result vector to store the result\r\n     * @returns the resulting vector\r\n     */\r\n    rotateByQuaternionToRef(quaternion, result) {\r\n        quaternion.toRotationMatrix(MathTmp.Matrix[0]);\r\n        Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Rotates a vector around a given point\r\n     * @param quaternion the rotation quaternion\r\n     * @param point the point to rotate around\r\n     * @param result vector to store the result\r\n     * @returns the resulting vector\r\n     */\r\n    rotateByQuaternionAroundPointToRef(quaternion, point, result) {\r\n        this.subtractToRef(point, MathTmp.Vector3[0]);\r\n        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);\r\n        point.addToRef(MathTmp.Vector3[0], result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Normalize the current Vector3 with the given input length.\r\n     * Please note that this is an in place operation.\r\n     * @param len the length of the vector\r\n     * @returns the current updated Vector3\r\n     */\r\n    normalizeFromLength(len) {\r\n        if (len === 0 || len === 1.0) {\r\n            return this;\r\n        }\r\n        return this.scaleInPlace(1.0 / len);\r\n    }\r\n    /**\r\n     * Normalize the current Vector3 to a new vector\r\n     * @returns the new Vector3\r\n     */\r\n    normalizeToNew() {\r\n        const normalized = new Vector3(0, 0, 0);\r\n        this.normalizeToRef(normalized);\r\n        return normalized;\r\n    }\r\n    /**\r\n     * Normalize the current Vector3 to the reference\r\n     * @param reference define the Vector3 to update\r\n     * @returns the updated Vector3\r\n     */\r\n    normalizeToRef(reference) {\r\n        var len = this.length();\r\n        if (len === 0 || len === 1.0) {\r\n            return reference.copyFromFloats(this.x, this.y, this.z);\r\n        }\r\n        return this.scaleToRef(1.0 / len, reference);\r\n    }\r\n    /**\r\n     * Creates a new Vector3 copied from the current Vector3\r\n     * @returns the new Vector3\r\n     */\r\n    clone() {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    /**\r\n     * Copies the given vector coordinates to the current Vector3 ones\r\n     * @param source defines the source Vector3\r\n     * @returns the current updated Vector3\r\n     */\r\n    copyFrom(source) {\r\n        return this.copyFromFloats(source.x, source.y, source.z);\r\n    }\r\n    /**\r\n     * Copies the given floats to the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    copyFromFloats(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n    /**\r\n     * Copies the given floats to the current Vector3 coordinates\r\n     * @param x defines the x coordinate of the operand\r\n     * @param y defines the y coordinate of the operand\r\n     * @param z defines the z coordinate of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    set(x, y, z) {\r\n        return this.copyFromFloats(x, y, z);\r\n    }\r\n    /**\r\n     * Copies the given float to the current Vector3 coordinates\r\n     * @param v defines the x, y and z coordinates of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    setAll(v) {\r\n        this.x = this.y = this.z = v;\r\n        return this;\r\n    }\r\n    // Statics\r\n    /**\r\n     * Get the clip factor between two vectors\r\n     * @param vector0 defines the first operand\r\n     * @param vector1 defines the second operand\r\n     * @param axis defines the axis to use\r\n     * @param size defines the size along the axis\r\n     * @returns the clip factor\r\n     */\r\n    static GetClipFactor(vector0, vector1, axis, size) {\r\n        var d0 = Vector3.Dot(vector0, axis) - size;\r\n        var d1 = Vector3.Dot(vector1, axis) - size;\r\n        var s = d0 / (d0 - d1);\r\n        return s;\r\n    }\r\n    /**\r\n     * Get angle between two vectors\r\n     * @param vector0 angle between vector0 and vector1\r\n     * @param vector1 angle between vector0 and vector1\r\n     * @param normal direction of the normal\r\n     * @return the angle between vector0 and vector1\r\n     */\r\n    static GetAngleBetweenVectors(vector0, vector1, normal) {\r\n        const v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);\r\n        const v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);\r\n        const dot = Vector3.Dot(v0, v1);\r\n        const n = MathTmp.Vector3[3];\r\n        Vector3.CrossToRef(v0, v1, n);\r\n        if (Vector3.Dot(n, normal) > 0) {\r\n            return Math.acos(dot);\r\n        }\r\n        return -Math.acos(dot);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set from the index \"offset\" of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @returns the new Vector3\r\n     */\r\n    static FromArray(array, offset = 0) {\r\n        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set from the index \"offset\" of the given Float32Array\r\n     * This function is deprecated. Use FromArray instead\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @returns the new Vector3\r\n     */\r\n    static FromFloatArray(array, offset) {\r\n        return Vector3.FromArray(array, offset);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static FromArrayToRef(array, offset, result) {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given Float32Array\r\n     * This function is deprecated.  Use FromArrayToRef instead.\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static FromFloatArrayToRef(array, offset, result) {\r\n        return Vector3.FromArrayToRef(array, offset, result);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the given floats.\r\n     * @param x defines the x coordinate of the source\r\n     * @param y defines the y coordinate of the source\r\n     * @param z defines the z coordinate of the source\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static FromFloatsToRef(x, y, z, result) {\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, 0.0)\r\n     * @returns a new empty Vector3\r\n     */\r\n    static Zero() {\r\n        return new Vector3(0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (1.0, 1.0, 1.0)\r\n     * @returns a new unit Vector3\r\n     */\r\n    static One() {\r\n        return new Vector3(1.0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 1.0, 0.0)\r\n     * @returns a new up Vector3\r\n     */\r\n    static Up() {\r\n        return new Vector3(0.0, 1.0, 0.0);\r\n    }\r\n    /**\r\n     * Gets a up Vector3 that must not be updated\r\n     */\r\n    static get UpReadOnly() {\r\n        return Vector3._UpReadOnly;\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, -1.0, 0.0)\r\n     * @returns a new down Vector3\r\n     */\r\n    static Down() {\r\n        return new Vector3(0.0, -1.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, 1.0)\r\n     * @returns a new forward Vector3\r\n     */\r\n    static Forward() {\r\n        return new Vector3(0.0, 0.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (0.0, 0.0, -1.0)\r\n     * @returns a new forward Vector3\r\n     */\r\n    static Backward() {\r\n        return new Vector3(0.0, 0.0, -1.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (1.0, 0.0, 0.0)\r\n     * @returns a new right Vector3\r\n     */\r\n    static Right() {\r\n        return new Vector3(1.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\r\n     * @returns a new left Vector3\r\n     */\r\n    static Left() {\r\n        return new Vector3(-1.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\r\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the transformed Vector3\r\n     */\r\n    static TransformCoordinates(vector, transformation) {\r\n        var result = Vector3.Zero();\r\n        Vector3.TransformCoordinatesToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\r\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static TransformCoordinatesToRef(vector, transformation, result) {\r\n        Vector3.TransformCoordinatesFromFloatsToRef(vector.x, vector.y, vector.z, transformation, result);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\r\n     * This method computes tranformed coordinates only, not transformed direction vectors\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {\r\n        const m = transformation.m;\r\n        var rx = x * m[0] + y * m[4] + z * m[8] + m[12];\r\n        var ry = x * m[1] + y * m[5] + z * m[9] + m[13];\r\n        var rz = x * m[2] + y * m[6] + z * m[10] + m[14];\r\n        var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\r\n        result.x = rx * rw;\r\n        result.y = ry * rw;\r\n        result.z = rz * rw;\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @returns the new Vector3\r\n     */\r\n    static TransformNormal(vector, transformation) {\r\n        var result = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param vector defines the Vector3 to transform\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static TransformNormalToRef(vector, transformation, result) {\r\n        this.TransformNormalFromFloatsToRef(vector.x, vector.y, vector.z, transformation, result);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\r\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\r\n     * @param x define the x coordinate of the source vector\r\n     * @param y define the y coordinate of the source vector\r\n     * @param z define the z coordinate of the source vector\r\n     * @param transformation defines the transformation matrix\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {\r\n        const m = transformation.m;\r\n        result.x = x * m[0] + y * m[4] + z * m[8];\r\n        result.y = x * m[1] + y * m[5] + z * m[9];\r\n        result.z = x * m[2] + y * m[6] + z * m[10];\r\n    }\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\r\n     * @param value1 defines the first control point\r\n     * @param value2 defines the second control point\r\n     * @param value3 defines the third control point\r\n     * @param value4 defines the fourth control point\r\n     * @param amount defines the amount on the spline to use\r\n     * @returns the new Vector3\r\n     */\r\n    static CatmullRom(value1, value2, value3, value4, amount) {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) +\r\n            (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) +\r\n            ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\r\n        var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) +\r\n            (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) +\r\n            ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\r\n        var z = 0.5 * ((((2.0 * value2.z) + ((-value1.z + value3.z) * amount)) +\r\n            (((((2.0 * value1.z) - (5.0 * value2.z)) + (4.0 * value3.z)) - value4.z) * squared)) +\r\n            ((((-value1.z + (3.0 * value2.z)) - (3.0 * value3.z)) + value4.z) * cubed));\r\n        return new Vector3(x, y, z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n     * @param value defines the current value\r\n     * @param min defines the lower range value\r\n     * @param max defines the upper range value\r\n     * @returns the new Vector3\r\n     */\r\n    static Clamp(value, min, max) {\r\n        const v = new Vector3();\r\n        Vector3.ClampToRef(value, min, max, v);\r\n        return v;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\r\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\r\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\r\n     * @param value defines the current value\r\n     * @param min defines the lower range value\r\n     * @param max defines the upper range value\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static ClampToRef(value, min, max, result) {\r\n        var x = value.x;\r\n        x = (x > max.x) ? max.x : x;\r\n        x = (x < min.x) ? min.x : x;\r\n        var y = value.y;\r\n        y = (y > max.y) ? max.y : y;\r\n        y = (y < min.y) ? min.y : y;\r\n        var z = value.z;\r\n        z = (z > max.z) ? max.z : z;\r\n        z = (z < min.z) ? min.z : z;\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent vector\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent vector\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns the new Vector3\r\n     */\r\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n        var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\r\n        var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\r\n        var z = (((value1.z * part1) + (value2.z * part2)) + (tangent1.z * part3)) + (tangent2.z * part4);\r\n        return new Vector3(x, y, z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\r\n     * @param start defines the start value\r\n     * @param end defines the end value\r\n     * @param amount max defines amount between both (between 0 and 1)\r\n     * @returns the new Vector3\r\n     */\r\n    static Lerp(start, end, amount) {\r\n        var result = new Vector3(0, 0, 0);\r\n        Vector3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\r\n     * @param start defines the start value\r\n     * @param end defines the end value\r\n     * @param amount max defines amount between both (between 0 and 1)\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static LerpToRef(start, end, amount, result) {\r\n        result.x = start.x + ((end.x - start.x) * amount);\r\n        result.y = start.y + ((end.y - start.y) * amount);\r\n        result.z = start.z + ((end.z - start.z) * amount);\r\n    }\r\n    /**\r\n     * Returns the dot product (float) between the vectors \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the dot product\r\n     */\r\n    static Dot(left, right) {\r\n        return (left.x * right.x + left.y * right.y + left.z * right.z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\r\n     * The cross product is then orthogonal to both \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the cross product\r\n     */\r\n    static Cross(left, right) {\r\n        var result = Vector3.Zero();\r\n        Vector3.CrossToRef(left, right, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\r\n     * The cross product is then orthogonal to both \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static CrossToRef(left, right, result) {\r\n        const x = left.y * right.z - left.z * right.y;\r\n        const y = left.z * right.x - left.x * right.z;\r\n        const z = left.x * right.y - left.y * right.x;\r\n        result.copyFromFloats(x, y, z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 as the normalization of the given vector\r\n     * @param vector defines the Vector3 to normalize\r\n     * @returns the new Vector3\r\n     */\r\n    static Normalize(vector) {\r\n        var result = Vector3.Zero();\r\n        Vector3.NormalizeToRef(vector, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the normalization of the given first vector\r\n     * @param vector defines the Vector3 to normalize\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static NormalizeToRef(vector, result) {\r\n        vector.normalizeToRef(result);\r\n    }\r\n    /**\r\n     * Project a Vector3 onto screen space\r\n     * @param vector defines the Vector3 to project\r\n     * @param world defines the world matrix to use\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @param viewport defines the screen viewport to use\r\n     * @returns the new Vector3\r\n     */\r\n    static Project(vector, world, transform, viewport) {\r\n        var cw = viewport.width;\r\n        var ch = viewport.height;\r\n        var cx = viewport.x;\r\n        var cy = viewport.y;\r\n        var viewportMatrix = MathTmp.Matrix[1];\r\n        Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(transform, matrix);\r\n        matrix.multiplyToRef(viewportMatrix, matrix);\r\n        return Vector3.TransformCoordinates(vector, matrix);\r\n    }\r\n    /** @hidden */\r\n    static _UnprojectFromInvertedMatrixToRef(source, matrix, result) {\r\n        Vector3.TransformCoordinatesToRef(source, matrix, result);\r\n        const m = matrix.m;\r\n        var num = source.x * m[3] + source.y * m[7] + source.z * m[11] + m[15];\r\n        if (_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(num, 1.0)) {\r\n            result.scaleInPlace(1.0 / num);\r\n        }\r\n    }\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param transform defines the transform (view x projection) matrix to use\r\n     * @returns the new Vector3\r\n     */\r\n    static UnprojectFromTransform(source, viewportWidth, viewportHeight, world, transform) {\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(transform, matrix);\r\n        matrix.invert();\r\n        source.x = source.x / viewportWidth * 2 - 1;\r\n        source.y = -(source.y / viewportHeight * 2 - 1);\r\n        const vector = new Vector3();\r\n        Vector3._UnprojectFromInvertedMatrixToRef(source, matrix, vector);\r\n        return vector;\r\n    }\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @returns the new Vector3\r\n     */\r\n    static Unproject(source, viewportWidth, viewportHeight, world, view, projection) {\r\n        let result = Vector3.Zero();\r\n        Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param source defines the screen space Vector3 to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result) {\r\n        Vector3.UnprojectFloatsToRef(source.x, source.y, source.z, viewportWidth, viewportHeight, world, view, projection, result);\r\n    }\r\n    /**\r\n     * Unproject from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param sourceZ defines the screen space z coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     * @param result defines the Vector3 where to store the result\r\n     */\r\n    static UnprojectFloatsToRef(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n        var screenSource = MathTmp.Vector3[0];\r\n        screenSource.x = sourceX / viewportWidth * 2 - 1;\r\n        screenSource.y = -(sourceY / viewportHeight * 2 - 1);\r\n        screenSource.z = 2 * sourceZ - 1.0;\r\n        Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);\r\n    }\r\n    /**\r\n     * Gets the minimal coordinate values between two Vector3\r\n     * @param left defines the first operand\r\n     * @param right defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    static Minimize(left, right) {\r\n        var min = left.clone();\r\n        min.minimizeInPlace(right);\r\n        return min;\r\n    }\r\n    /**\r\n     * Gets the maximal coordinate values between two Vector3\r\n     * @param left defines the first operand\r\n     * @param right defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    static Maximize(left, right) {\r\n        var max = left.clone();\r\n        max.maximizeInPlace(right);\r\n        return max;\r\n    }\r\n    /**\r\n     * Returns the distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the distance\r\n     */\r\n    static Distance(value1, value2) {\r\n        return Math.sqrt(Vector3.DistanceSquared(value1, value2));\r\n    }\r\n    /**\r\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the squared distance\r\n     */\r\n    static DistanceSquared(value1, value2) {\r\n        var x = value1.x - value2.x;\r\n        var y = value1.y - value2.y;\r\n        var z = value1.z - value2.z;\r\n        return (x * x) + (y * y) + (z * z);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\r\n     * @param value1 defines the first operand\r\n     * @param value2 defines the second operand\r\n     * @returns the new Vector3\r\n     */\r\n    static Center(value1, value2) {\r\n        var center = value1.add(value2);\r\n        center.scaleInPlace(0.5);\r\n        return center;\r\n    }\r\n    /**\r\n     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\r\n     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\r\n     * to something in order to rotate it from its local system to the given target system\r\n     * Note: axis1, axis2 and axis3 are normalized during this operation\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @returns a new Vector3\r\n     */\r\n    static RotationFromAxis(axis1, axis2, axis3) {\r\n        var rotation = Vector3.Zero();\r\n        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\r\n        return rotation;\r\n    }\r\n    /**\r\n     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @param ref defines the Vector3 where to store the result\r\n     */\r\n    static RotationFromAxisToRef(axis1, axis2, axis3, ref) {\r\n        var quat = MathTmp.Quaternion[0];\r\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\r\n        quat.toEulerAnglesToRef(ref);\r\n    }\r\n}\r\nVector3._UpReadOnly = Vector3.Up();\r\n/**\r\n * Vector4 class created for EulerAngle class conversion to Quaternion\r\n */\r\nclass Vector4 {\r\n    /**\r\n     * Creates a Vector4 object from the given floats.\r\n     * @param x x value of the vector\r\n     * @param y y value of the vector\r\n     * @param z z value of the vector\r\n     * @param w w value of the vector\r\n     */\r\n    constructor(\r\n    /** x value of the vector */\r\n    x, \r\n    /** y value of the vector */\r\n    y, \r\n    /** z value of the vector */\r\n    z, \r\n    /** w value of the vector */\r\n    w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n    }\r\n    /**\r\n     * Returns the string with the Vector4 coordinates.\r\n     * @returns a string containing all the vector values\r\n     */\r\n    toString() {\r\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\r\n    }\r\n    /**\r\n     * Returns the string \"Vector4\".\r\n     * @returns \"Vector4\"\r\n     */\r\n    getClassName() {\r\n        return \"Vector4\";\r\n    }\r\n    /**\r\n     * Returns the Vector4 hash code.\r\n     * @returns a unique hash code\r\n     */\r\n    getHashCode() {\r\n        let hash = this.x || 0;\r\n        hash = (hash * 397) ^ (this.y || 0);\r\n        hash = (hash * 397) ^ (this.z || 0);\r\n        hash = (hash * 397) ^ (this.w || 0);\r\n        return hash;\r\n    }\r\n    // Operators\r\n    /**\r\n     * Returns a new array populated with 4 elements : the Vector4 coordinates.\r\n     * @returns the resulting array\r\n     */\r\n    asArray() {\r\n        var result = new Array();\r\n        this.toArray(result, 0);\r\n        return result;\r\n    }\r\n    /**\r\n     * Populates the given array from the given index with the Vector4 coordinates.\r\n     * @param array array to populate\r\n     * @param index index of the array to start at (default: 0)\r\n     * @returns the Vector4.\r\n     */\r\n    toArray(array, index) {\r\n        if (index === undefined) {\r\n            index = 0;\r\n        }\r\n        array[index] = this.x;\r\n        array[index + 1] = this.y;\r\n        array[index + 2] = this.z;\r\n        array[index + 3] = this.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds the given vector to the current Vector4.\r\n     * @param otherVector the vector to add\r\n     * @returns the updated Vector4.\r\n     */\r\n    addInPlace(otherVector) {\r\n        this.x += otherVector.x;\r\n        this.y += otherVector.y;\r\n        this.z += otherVector.z;\r\n        this.w += otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\r\n     * @param otherVector the vector to add\r\n     * @returns the resulting vector\r\n     */\r\n    add(otherVector) {\r\n        return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\r\n     * @param otherVector the vector to add\r\n     * @param result the vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    addToRef(otherVector, result) {\r\n        result.x = this.x + otherVector.x;\r\n        result.y = this.y + otherVector.y;\r\n        result.z = this.z + otherVector.z;\r\n        result.w = this.w + otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Subtract in place the given vector from the current Vector4.\r\n     * @param otherVector the vector to subtract\r\n     * @returns the updated Vector4.\r\n     */\r\n    subtractInPlace(otherVector) {\r\n        this.x -= otherVector.x;\r\n        this.y -= otherVector.y;\r\n        this.z -= otherVector.z;\r\n        this.w -= otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\r\n     * @param otherVector the vector to add\r\n     * @returns the new vector with the result\r\n     */\r\n    subtract(otherVector) {\r\n        return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\r\n     * @param otherVector the vector to subtract\r\n     * @param result the vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    subtractToRef(otherVector, result) {\r\n        result.x = this.x - otherVector.x;\r\n        result.y = this.y - otherVector.y;\r\n        result.z = this.z - otherVector.z;\r\n        result.w = this.w - otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     */\r\n    /**\r\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     * @param x value to subtract\r\n     * @param y value to subtract\r\n     * @param z value to subtract\r\n     * @param w value to subtract\r\n     * @returns new vector containing the result\r\n     */\r\n    subtractFromFloats(x, y, z, w) {\r\n        return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\r\n     * @param x value to subtract\r\n     * @param y value to subtract\r\n     * @param z value to subtract\r\n     * @param w value to subtract\r\n     * @param result the vector to store the result in\r\n     * @returns the current Vector4.\r\n     */\r\n    subtractFromFloatsToRef(x, y, z, w, result) {\r\n        result.x = this.x - x;\r\n        result.y = this.y - y;\r\n        result.z = this.z - z;\r\n        result.w = this.w - w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the current Vector4 negated coordinates.\r\n     * @returns a new vector with the negated values\r\n     */\r\n    negate() {\r\n        return new Vector4(-this.x, -this.y, -this.z, -this.w);\r\n    }\r\n    /**\r\n     * Multiplies the current Vector4 coordinates by scale (float).\r\n     * @param scale the number to scale with\r\n     * @returns the updated Vector4.\r\n     */\r\n    scaleInPlace(scale) {\r\n        this.x *= scale;\r\n        this.y *= scale;\r\n        this.z *= scale;\r\n        this.w *= scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\r\n     * @param scale the number to scale with\r\n     * @returns a new vector with the result\r\n     */\r\n    scale(scale) {\r\n        return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\r\n     * @param scale the number to scale with\r\n     * @param result a vector to store the result in\r\n     * @returns the current Vector4.\r\n     */\r\n    scaleToRef(scale, result) {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        result.z = this.z * scale;\r\n        result.w = this.w * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Scale the current Vector4 values by a factor and add the result to a given Vector4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Vector4 object where to store the result\r\n     * @returns the unmodified current Vector4\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        result.z += this.z * scale;\r\n        result.w += this.w * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\r\n     * @param otherVector the vector to compare against\r\n     * @returns true if they are equal\r\n     */\r\n    equals(otherVector) {\r\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\r\n    }\r\n    /**\r\n     * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\r\n     * @param otherVector vector to compare against\r\n     * @param epsilon (Default: very small number)\r\n     * @returns true if they are equal\r\n     */\r\n    equalsWithEpsilon(otherVector, epsilon = Epsilon) {\r\n        return otherVector\r\n            && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.x, otherVector.x, epsilon)\r\n            && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.y, otherVector.y, epsilon)\r\n            && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.z, otherVector.z, epsilon)\r\n            && _math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(this.w, otherVector.w, epsilon);\r\n    }\r\n    /**\r\n     * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\r\n     * @param x x value to compare against\r\n     * @param y y value to compare against\r\n     * @param z z value to compare against\r\n     * @param w w value to compare against\r\n     * @returns true if equal\r\n     */\r\n    equalsToFloats(x, y, z, w) {\r\n        return this.x === x && this.y === y && this.z === z && this.w === w;\r\n    }\r\n    /**\r\n     * Multiplies in place the current Vector4 by the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @returns the updated Vector4.\r\n     */\r\n    multiplyInPlace(otherVector) {\r\n        this.x *= otherVector.x;\r\n        this.y *= otherVector.y;\r\n        this.z *= otherVector.z;\r\n        this.w *= otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @returns resulting new vector\r\n     */\r\n    multiply(otherVector) {\r\n        return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\r\n     * @param otherVector vector to multiple with\r\n     * @param result vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    multiplyToRef(otherVector, result) {\r\n        result.x = this.x * otherVector.x;\r\n        result.y = this.y * otherVector.y;\r\n        result.z = this.z * otherVector.z;\r\n        result.w = this.w * otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\r\n     * @param x x value multiply with\r\n     * @param y y value multiply with\r\n     * @param z z value multiply with\r\n     * @param w w value multiply with\r\n     * @returns resulting new vector\r\n     */\r\n    multiplyByFloats(x, y, z, w) {\r\n        return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\r\n     * @param otherVector vector to devide with\r\n     * @returns resulting new vector\r\n     */\r\n    divide(otherVector) {\r\n        return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\r\n     * @param otherVector vector to devide with\r\n     * @param result vector to store the result\r\n     * @returns the current Vector4.\r\n     */\r\n    divideToRef(otherVector, result) {\r\n        result.x = this.x / otherVector.x;\r\n        result.y = this.y / otherVector.y;\r\n        result.z = this.z / otherVector.z;\r\n        result.w = this.w / otherVector.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Divides the current Vector3 coordinates by the given ones.\r\n     * @param otherVector vector to devide with\r\n     * @returns the updated Vector3.\r\n     */\r\n    divideInPlace(otherVector) {\r\n        return this.divideToRef(otherVector, this);\r\n    }\r\n    /**\r\n     * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    minimizeInPlace(other) {\r\n        if (other.x < this.x) {\r\n            this.x = other.x;\r\n        }\r\n        if (other.y < this.y) {\r\n            this.y = other.y;\r\n        }\r\n        if (other.z < this.z) {\r\n            this.z = other.z;\r\n        }\r\n        if (other.w < this.w) {\r\n            this.w = other.w;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\r\n     * @param other defines the second operand\r\n     * @returns the current updated Vector4\r\n     */\r\n    maximizeInPlace(other) {\r\n        if (other.x > this.x) {\r\n            this.x = other.x;\r\n        }\r\n        if (other.y > this.y) {\r\n            this.y = other.y;\r\n        }\r\n        if (other.z > this.z) {\r\n            this.z = other.z;\r\n        }\r\n        if (other.w > this.w) {\r\n            this.w = other.w;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets a new Vector4 from current Vector4 floored values\r\n     * @returns a new Vector4\r\n     */\r\n    floor() {\r\n        return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\r\n    }\r\n    /**\r\n     * Gets a new Vector4 from current Vector3 floored values\r\n     * @returns a new Vector4\r\n     */\r\n    fract() {\r\n        return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\r\n    }\r\n    // Properties\r\n    /**\r\n     * Returns the Vector4 length (float).\r\n     * @returns the length\r\n     */\r\n    length() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n    }\r\n    /**\r\n     * Returns the Vector4 squared length (float).\r\n     * @returns the length squared\r\n     */\r\n    lengthSquared() {\r\n        return (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n    }\r\n    // Methods\r\n    /**\r\n     * Normalizes in place the Vector4.\r\n     * @returns the updated Vector4.\r\n     */\r\n    normalize() {\r\n        var len = this.length();\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n        return this.scaleInPlace(1.0 / len);\r\n    }\r\n    /**\r\n     * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\r\n     * @returns this converted to a new vector3\r\n     */\r\n    toVector3() {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 copied from the current one.\r\n     * @returns the new cloned vector\r\n     */\r\n    clone() {\r\n        return new Vector4(this.x, this.y, this.z, this.w);\r\n    }\r\n    /**\r\n     * Updates the current Vector4 with the given one coordinates.\r\n     * @param source the source vector to copy from\r\n     * @returns the updated Vector4.\r\n     */\r\n    copyFrom(source) {\r\n        this.x = source.x;\r\n        this.y = source.y;\r\n        this.z = source.z;\r\n        this.w = source.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector4 coordinates with the given floats.\r\n     * @param x float to copy from\r\n     * @param y float to copy from\r\n     * @param z float to copy from\r\n     * @param w float to copy from\r\n     * @returns the updated Vector4.\r\n     */\r\n    copyFromFloats(x, y, z, w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current Vector4 coordinates with the given floats.\r\n     * @param x float to set from\r\n     * @param y float to set from\r\n     * @param z float to set from\r\n     * @param w float to set from\r\n     * @returns the updated Vector4.\r\n     */\r\n    set(x, y, z, w) {\r\n        return this.copyFromFloats(x, y, z, w);\r\n    }\r\n    /**\r\n     * Copies the given float to the current Vector3 coordinates\r\n     * @param v defines the x, y, z and w coordinates of the operand\r\n     * @returns the current updated Vector3\r\n     */\r\n    setAll(v) {\r\n        this.x = this.y = this.z = this.w = v;\r\n        return this;\r\n    }\r\n    // Statics\r\n    /**\r\n     * Returns a new Vector4 set from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @returns the new vector\r\n     */\r\n    static FromArray(array, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the starting index of the given array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the vector to store the result in\r\n     */\r\n    static FromArrayToRef(array, offset, result) {\r\n        result.x = array[offset];\r\n        result.y = array[offset + 1];\r\n        result.z = array[offset + 2];\r\n        result.w = array[offset + 3];\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the starting index of the given Float32Array.\r\n     * @param array the array to pull values from\r\n     * @param offset the offset into the array to start at\r\n     * @param result the vector to store the result in\r\n     */\r\n    static FromFloatArrayToRef(array, offset, result) {\r\n        Vector4.FromArrayToRef(array, offset, result);\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" coordinates from the given floats.\r\n     * @param x float to set from\r\n     * @param y float to set from\r\n     * @param z float to set from\r\n     * @param w float to set from\r\n     * @param result the vector to the floats in\r\n     */\r\n    static FromFloatsToRef(x, y, z, w, result) {\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        result.w = w;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\r\n     * @returns the new vector\r\n     */\r\n    static Zero() {\r\n        return new Vector4(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\r\n     * @returns the new vector\r\n     */\r\n    static One() {\r\n        return new Vector4(1.0, 1.0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a new normalized Vector4 from the given one.\r\n     * @param vector the vector to normalize\r\n     * @returns the vector\r\n     */\r\n    static Normalize(vector) {\r\n        var result = Vector4.Zero();\r\n        Vector4.NormalizeToRef(vector, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Updates the given vector \"result\" from the normalization of the given one.\r\n     * @param vector the vector to normalize\r\n     * @param result the vector to store the result in\r\n     */\r\n    static NormalizeToRef(vector, result) {\r\n        result.copyFrom(vector);\r\n        result.normalize();\r\n    }\r\n    /**\r\n     * Returns a vector with the minimum values from the left and right vectors\r\n     * @param left left vector to minimize\r\n     * @param right right vector to minimize\r\n     * @returns a new vector with the minimum of the left and right vector values\r\n     */\r\n    static Minimize(left, right) {\r\n        var min = left.clone();\r\n        min.minimizeInPlace(right);\r\n        return min;\r\n    }\r\n    /**\r\n     * Returns a vector with the maximum values from the left and right vectors\r\n     * @param left left vector to maximize\r\n     * @param right right vector to maximize\r\n     * @returns a new vector with the maximum of the left and right vector values\r\n     */\r\n    static Maximize(left, right) {\r\n        var max = left.clone();\r\n        max.maximizeInPlace(right);\r\n        return max;\r\n    }\r\n    /**\r\n     * Returns the distance (float) between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the distance between\r\n     * @param value2 value to calulate the distance between\r\n     * @return the distance between the two vectors\r\n     */\r\n    static Distance(value1, value2) {\r\n        return Math.sqrt(Vector4.DistanceSquared(value1, value2));\r\n    }\r\n    /**\r\n     * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the distance between\r\n     * @param value2 value to calulate the distance between\r\n     * @return the distance between the two vectors squared\r\n     */\r\n    static DistanceSquared(value1, value2) {\r\n        var x = value1.x - value2.x;\r\n        var y = value1.y - value2.y;\r\n        var z = value1.z - value2.z;\r\n        var w = value1.w - value2.w;\r\n        return (x * x) + (y * y) + (z * z) + (w * w);\r\n    }\r\n    /**\r\n     * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\r\n     * @param value1 value to calulate the center between\r\n     * @param value2 value to calulate the center between\r\n     * @return the center between the two vectors\r\n     */\r\n    static Center(value1, value2) {\r\n        var center = value1.add(value2);\r\n        center.scaleInPlace(0.5);\r\n        return center;\r\n    }\r\n    /**\r\n     * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param vector the vector to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @returns the new vector\r\n     */\r\n    static TransformNormal(vector, transformation) {\r\n        var result = Vector4.Zero();\r\n        Vector4.TransformNormalToRef(vector, transformation, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param vector the vector to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @param result the vector to store the result in\r\n     */\r\n    static TransformNormalToRef(vector, transformation, result) {\r\n        const m = transformation.m;\r\n        var x = (vector.x * m[0]) + (vector.y * m[4]) + (vector.z * m[8]);\r\n        var y = (vector.x * m[1]) + (vector.y * m[5]) + (vector.z * m[9]);\r\n        var z = (vector.x * m[2]) + (vector.y * m[6]) + (vector.z * m[10]);\r\n        result.x = x;\r\n        result.y = y;\r\n        result.z = z;\r\n        result.w = vector.w;\r\n    }\r\n    /**\r\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\r\n     * This methods computes transformed normalized direction vectors only.\r\n     * @param x value to transform\r\n     * @param y value to transform\r\n     * @param z value to transform\r\n     * @param w value to transform\r\n     * @param transformation the transformation matrix to apply\r\n     * @param result the vector to store the results in\r\n     */\r\n    static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {\r\n        const m = transformation.m;\r\n        result.x = (x * m[0]) + (y * m[4]) + (z * m[8]);\r\n        result.y = (x * m[1]) + (y * m[5]) + (z * m[9]);\r\n        result.z = (x * m[2]) + (y * m[6]) + (z * m[10]);\r\n        result.w = w;\r\n    }\r\n    /**\r\n     * Creates a new Vector4 from a Vector3\r\n     * @param source defines the source data\r\n     * @param w defines the 4th component (default is 0)\r\n     * @returns a new Vector4\r\n     */\r\n    static FromVector3(source, w = 0) {\r\n        return new Vector4(source.x, source.y, source.z, w);\r\n    }\r\n}\r\n/**\r\n * Size containing widht and height\r\n */\r\nclass Size {\r\n    /**\r\n     * Creates a Size object from the given width and height (floats).\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     */\r\n    constructor(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    /**\r\n     * Returns a string with the Size width and height\r\n     * @returns a string with the Size width and height\r\n     */\r\n    toString() {\r\n        return `{W: ${this.width}, H: ${this.height}}`;\r\n    }\r\n    /**\r\n     * \"Size\"\r\n     * @returns the string \"Size\"\r\n     */\r\n    getClassName() {\r\n        return \"Size\";\r\n    }\r\n    /**\r\n     * Returns the Size hash code.\r\n     * @returns a hash code for a unique width and height\r\n     */\r\n    getHashCode() {\r\n        let hash = this.width || 0;\r\n        hash = (hash * 397) ^ (this.height || 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Updates the current size from the given one.\r\n     * @param src the given size\r\n     */\r\n    copyFrom(src) {\r\n        this.width = src.width;\r\n        this.height = src.height;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     * @returns the updated Size.\r\n     */\r\n    copyFromFloats(width, height) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width to set\r\n     * @param height height to set\r\n     * @returns the updated Size.\r\n     */\r\n    set(width, height) {\r\n        return this.copyFromFloats(width, height);\r\n    }\r\n    /**\r\n     * Multiplies the width and height by numbers\r\n     * @param w factor to multiple the width by\r\n     * @param h factor to multiple the height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    multiplyByFloats(w, h) {\r\n        return new Size(this.width * w, this.height * h);\r\n    }\r\n    /**\r\n     * Clones the size\r\n     * @returns a new Size copied from the given one.\r\n     */\r\n    clone() {\r\n        return new Size(this.width, this.height);\r\n    }\r\n    /**\r\n     * True if the current Size and the given one width and height are strictly equal.\r\n     * @param other the other size to compare against\r\n     * @returns True if the current Size and the given one width and height are strictly equal.\r\n     */\r\n    equals(other) {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        return (this.width === other.width) && (this.height === other.height);\r\n    }\r\n    /**\r\n     * The surface of the Size : width * height (float).\r\n     */\r\n    get surface() {\r\n        return this.width * this.height;\r\n    }\r\n    /**\r\n     * Create a new size of zero\r\n     * @returns a new Size set to (0.0, 0.0)\r\n     */\r\n    static Zero() {\r\n        return new Size(0.0, 0.0);\r\n    }\r\n    /**\r\n     * Sums the width and height of two sizes\r\n     * @param otherSize size to add to this size\r\n     * @returns a new Size set as the addition result of the current Size and the given one.\r\n     */\r\n    add(otherSize) {\r\n        let r = new Size(this.width + otherSize.width, this.height + otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Subtracts the width and height of two\r\n     * @param otherSize size to subtract to this size\r\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\r\n     */\r\n    subtract(otherSize) {\r\n        let r = new Size(this.width - otherSize.width, this.height - otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     * @param start starting size to lerp between\r\n     * @param end end size to lerp between\r\n     * @param amount amount to lerp between the start and end values\r\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     */\r\n    static Lerp(start, end, amount) {\r\n        var w = start.width + ((end.width - start.width) * amount);\r\n        var h = start.height + ((end.height - start.height) * amount);\r\n        return new Size(w, h);\r\n    }\r\n}\r\n/**\r\n * Class used to store quaternion data\r\n * @see https://en.wikipedia.org/wiki/Quaternion\r\n * @see http://doc.babylonjs.com/features/position,_rotation,_scaling\r\n */\r\nclass Quaternion {\r\n    /**\r\n     * Creates a new Quaternion from the given floats\r\n     * @param x defines the first component (0 by default)\r\n     * @param y defines the second component (0 by default)\r\n     * @param z defines the third component (0 by default)\r\n     * @param w defines the fourth component (1.0 by default)\r\n     */\r\n    constructor(\r\n    /** defines the first component (0 by default) */\r\n    x = 0.0, \r\n    /** defines the second component (0 by default) */\r\n    y = 0.0, \r\n    /** defines the third component (0 by default) */\r\n    z = 0.0, \r\n    /** defines the fourth component (1.0 by default) */\r\n    w = 1.0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n    }\r\n    /**\r\n     * Gets a string representation for the current quaternion\r\n     * @returns a string with the Quaternion coordinates\r\n     */\r\n    toString() {\r\n        return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\r\n    }\r\n    /**\r\n     * Gets the class name of the quaternion\r\n     * @returns the string \"Quaternion\"\r\n     */\r\n    getClassName() {\r\n        return \"Quaternion\";\r\n    }\r\n    /**\r\n     * Gets a hash code for this quaternion\r\n     * @returns the quaternion hash code\r\n     */\r\n    getHashCode() {\r\n        let hash = this.x || 0;\r\n        hash = (hash * 397) ^ (this.y || 0);\r\n        hash = (hash * 397) ^ (this.z || 0);\r\n        hash = (hash * 397) ^ (this.w || 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Copy the quaternion to an array\r\n     * @returns a new array populated with 4 elements from the quaternion coordinates\r\n     */\r\n    asArray() {\r\n        return [this.x, this.y, this.z, this.w];\r\n    }\r\n    /**\r\n     * Check if two quaternions are equals\r\n     * @param otherQuaternion defines the second operand\r\n     * @return true if the current quaternion and the given one coordinates are strictly equals\r\n     */\r\n    equals(otherQuaternion) {\r\n        return otherQuaternion && this.x === otherQuaternion.x && this.y === otherQuaternion.y && this.z === otherQuaternion.z && this.w === otherQuaternion.w;\r\n    }\r\n    /**\r\n     * Clone the current quaternion\r\n     * @returns a new quaternion copied from the current one\r\n     */\r\n    clone() {\r\n        return new Quaternion(this.x, this.y, this.z, this.w);\r\n    }\r\n    /**\r\n     * Copy a quaternion to the current one\r\n     * @param other defines the other quaternion\r\n     * @returns the updated current quaternion\r\n     */\r\n    copyFrom(other) {\r\n        this.x = other.x;\r\n        this.y = other.y;\r\n        this.z = other.z;\r\n        this.w = other.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current quaternion with the given float coordinates\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     * @param z defines the z coordinate\r\n     * @param w defines the w coordinate\r\n     * @returns the updated current quaternion\r\n     */\r\n    copyFromFloats(x, y, z, w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current quaternion from the given float coordinates\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     * @param z defines the z coordinate\r\n     * @param w defines the w coordinate\r\n     * @returns the updated current quaternion\r\n     */\r\n    set(x, y, z, w) {\r\n        return this.copyFromFloats(x, y, z, w);\r\n    }\r\n    /**\r\n     * Adds two quaternions\r\n     * @param other defines the second operand\r\n     * @returns a new quaternion as the addition result of the given one and the current quaternion\r\n     */\r\n    add(other) {\r\n        return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);\r\n    }\r\n    /**\r\n     * Add a quaternion to the current one\r\n     * @param other defines the quaternion to add\r\n     * @returns the current quaternion\r\n     */\r\n    addInPlace(other) {\r\n        this.x += other.x;\r\n        this.y += other.y;\r\n        this.z += other.z;\r\n        this.w += other.w;\r\n        return this;\r\n    }\r\n    /**\r\n     * Subtract two quaternions\r\n     * @param other defines the second operand\r\n     * @returns a new quaternion as the subtraction result of the given one from the current one\r\n     */\r\n    subtract(other) {\r\n        return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);\r\n    }\r\n    /**\r\n     * Multiplies the current quaternion by a scale factor\r\n     * @param value defines the scale factor\r\n     * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\r\n     */\r\n    scale(value) {\r\n        return new Quaternion(this.x * value, this.y * value, this.z * value, this.w * value);\r\n    }\r\n    /**\r\n     * Scale the current quaternion values by a factor and stores the result to a given quaternion\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Quaternion object where to store the result\r\n     * @returns the unmodified current quaternion\r\n     */\r\n    scaleToRef(scale, result) {\r\n        result.x = this.x * scale;\r\n        result.y = this.y * scale;\r\n        result.z = this.z * scale;\r\n        result.w = this.w * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Multiplies in place the current quaternion by a scale factor\r\n     * @param value defines the scale factor\r\n     * @returns the current modified quaternion\r\n     */\r\n    scaleInPlace(value) {\r\n        this.x *= value;\r\n        this.y *= value;\r\n        this.z *= value;\r\n        this.w *= value;\r\n        return this;\r\n    }\r\n    /**\r\n     * Scale the current quaternion values by a factor and add the result to a given quaternion\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Quaternion object where to store the result\r\n     * @returns the unmodified current quaternion\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        result.x += this.x * scale;\r\n        result.y += this.y * scale;\r\n        result.z += this.z * scale;\r\n        result.w += this.w * scale;\r\n        return this;\r\n    }\r\n    /**\r\n     * Multiplies two quaternions\r\n     * @param q1 defines the second operand\r\n     * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\r\n     */\r\n    multiply(q1) {\r\n        var result = new Quaternion(0, 0, 0, 1.0);\r\n        this.multiplyToRef(q1, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\r\n     * @param q1 defines the second operand\r\n     * @param result defines the target quaternion\r\n     * @returns the current quaternion\r\n     */\r\n    multiplyToRef(q1, result) {\r\n        var x = this.x * q1.w + this.y * q1.z - this.z * q1.y + this.w * q1.x;\r\n        var y = -this.x * q1.z + this.y * q1.w + this.z * q1.x + this.w * q1.y;\r\n        var z = this.x * q1.y - this.y * q1.x + this.z * q1.w + this.w * q1.z;\r\n        var w = -this.x * q1.x - this.y * q1.y - this.z * q1.z + this.w * q1.w;\r\n        result.copyFromFloats(x, y, z, w);\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\r\n     * @param q1 defines the second operand\r\n     * @returns the currentupdated quaternion\r\n     */\r\n    multiplyInPlace(q1) {\r\n        this.multiplyToRef(q1, this);\r\n        return this;\r\n    }\r\n    /**\r\n     * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\r\n     * @param ref defines the target quaternion\r\n     * @returns the current quaternion\r\n     */\r\n    conjugateToRef(ref) {\r\n        ref.copyFromFloats(-this.x, -this.y, -this.z, this.w);\r\n        return this;\r\n    }\r\n    /**\r\n     * Conjugates in place (1-q) the current quaternion\r\n     * @returns the current updated quaternion\r\n     */\r\n    conjugateInPlace() {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n        return this;\r\n    }\r\n    /**\r\n     * Conjugates in place (1-q) the current quaternion\r\n     * @returns a new quaternion\r\n     */\r\n    conjugate() {\r\n        var result = new Quaternion(-this.x, -this.y, -this.z, this.w);\r\n        return result;\r\n    }\r\n    /**\r\n     * Gets length of current quaternion\r\n     * @returns the quaternion length (float)\r\n     */\r\n    length() {\r\n        return Math.sqrt((this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w));\r\n    }\r\n    /**\r\n     * Normalize in place the current quaternion\r\n     * @returns the current updated quaternion\r\n     */\r\n    normalize() {\r\n        var len = this.length();\r\n        if (len === 0) {\r\n            return this;\r\n        }\r\n        var inv = 1.0 / len;\r\n        this.x *= inv;\r\n        this.y *= inv;\r\n        this.z *= inv;\r\n        this.w *= inv;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Vector3 set with the Euler angles translated from the current quaternion\r\n     * @param order is a reserved parameter and is ignore for now\r\n     * @returns a new Vector3 containing the Euler angles\r\n     */\r\n    toEulerAngles(order = \"YZX\") {\r\n        var result = Vector3.Zero();\r\n        this.toEulerAnglesToRef(result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given vector3 \"result\" with the Euler angles translated from the current quaternion\r\n     * @param result defines the vector which will be filled with the Euler angles\r\n     * @param order is a reserved parameter and is ignore for now\r\n     * @returns the current unchanged quaternion\r\n     */\r\n    toEulerAnglesToRef(result) {\r\n        var qz = this.z;\r\n        var qx = this.x;\r\n        var qy = this.y;\r\n        var qw = this.w;\r\n        var sqw = qw * qw;\r\n        var sqz = qz * qz;\r\n        var sqx = qx * qx;\r\n        var sqy = qy * qy;\r\n        var zAxisY = qy * qz - qx * qw;\r\n        var limit = .4999999;\r\n        if (zAxisY < -limit) {\r\n            result.y = 2 * Math.atan2(qy, qw);\r\n            result.x = Math.PI / 2;\r\n            result.z = 0;\r\n        }\r\n        else if (zAxisY > limit) {\r\n            result.y = 2 * Math.atan2(qy, qw);\r\n            result.x = -Math.PI / 2;\r\n            result.z = 0;\r\n        }\r\n        else {\r\n            result.z = Math.atan2(2.0 * (qx * qy + qz * qw), (-sqz - sqx + sqy + sqw));\r\n            result.x = Math.asin(-2.0 * (qz * qy - qx * qw));\r\n            result.y = Math.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw));\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the given rotation matrix with the current quaternion values\r\n     * @param result defines the target matrix\r\n     * @returns the current unchanged quaternion\r\n     */\r\n    toRotationMatrix(result) {\r\n        Matrix.FromQuaternionToRef(this, result);\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the current quaternion from the given rotation matrix values\r\n     * @param matrix defines the source matrix\r\n     * @returns the current updated quaternion\r\n     */\r\n    fromRotationMatrix(matrix) {\r\n        Quaternion.FromRotationMatrixToRef(matrix, this);\r\n        return this;\r\n    }\r\n    // Statics\r\n    /**\r\n     * Creates a new quaternion from a rotation matrix\r\n     * @param matrix defines the source matrix\r\n     * @returns a new quaternion created from the given rotation matrix values\r\n     */\r\n    static FromRotationMatrix(matrix) {\r\n        var result = new Quaternion();\r\n        Quaternion.FromRotationMatrixToRef(matrix, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Updates the given quaternion with the given rotation matrix values\r\n     * @param matrix defines the source matrix\r\n     * @param result defines the target quaternion\r\n     */\r\n    static FromRotationMatrixToRef(matrix, result) {\r\n        var data = matrix.m;\r\n        var m11 = data[0], m12 = data[4], m13 = data[8];\r\n        var m21 = data[1], m22 = data[5], m23 = data[9];\r\n        var m31 = data[2], m32 = data[6], m33 = data[10];\r\n        var trace = m11 + m22 + m33;\r\n        var s;\r\n        if (trace > 0) {\r\n            s = 0.5 / Math.sqrt(trace + 1.0);\r\n            result.w = 0.25 / s;\r\n            result.x = (m32 - m23) * s;\r\n            result.y = (m13 - m31) * s;\r\n            result.z = (m21 - m12) * s;\r\n        }\r\n        else if (m11 > m22 && m11 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n            result.w = (m32 - m23) / s;\r\n            result.x = 0.25 * s;\r\n            result.y = (m12 + m21) / s;\r\n            result.z = (m13 + m31) / s;\r\n        }\r\n        else if (m22 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n            result.w = (m13 - m31) / s;\r\n            result.x = (m12 + m21) / s;\r\n            result.y = 0.25 * s;\r\n            result.z = (m23 + m32) / s;\r\n        }\r\n        else {\r\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n            result.w = (m21 - m12) / s;\r\n            result.x = (m13 + m31) / s;\r\n            result.y = (m23 + m32) / s;\r\n            result.z = 0.25 * s;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the dot product (float) between the quaternions \"left\" and \"right\"\r\n     * @param left defines the left operand\r\n     * @param right defines the right operand\r\n     * @returns the dot product\r\n     */\r\n    static Dot(left, right) {\r\n        return (left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w);\r\n    }\r\n    /**\r\n     * Checks if the two quaternions are close to each other\r\n     * @param quat0 defines the first quaternion to check\r\n     * @param quat1 defines the second quaternion to check\r\n     * @returns true if the two quaternions are close to each other\r\n     */\r\n    static AreClose(quat0, quat1) {\r\n        let dot = Quaternion.Dot(quat0, quat1);\r\n        return dot >= 0;\r\n    }\r\n    /**\r\n     * Creates an empty quaternion\r\n     * @returns a new quaternion set to (0.0, 0.0, 0.0)\r\n     */\r\n    static Zero() {\r\n        return new Quaternion(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    /**\r\n     * Inverse a given quaternion\r\n     * @param q defines the source quaternion\r\n     * @returns a new quaternion as the inverted current quaternion\r\n     */\r\n    static Inverse(q) {\r\n        return new Quaternion(-q.x, -q.y, -q.z, q.w);\r\n    }\r\n    /**\r\n     * Inverse a given quaternion\r\n     * @param q defines the source quaternion\r\n     * @param result the quaternion the result will be stored in\r\n     * @returns the result quaternion\r\n     */\r\n    static InverseToRef(q, result) {\r\n        result.set(-q.x, -q.y, -q.z, q.w);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates an identity quaternion\r\n     * @returns the identity quaternion\r\n     */\r\n    static Identity() {\r\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\r\n    }\r\n    /**\r\n     * Gets a boolean indicating if the given quaternion is identity\r\n     * @param quaternion defines the quaternion to check\r\n     * @returns true if the quaternion is identity\r\n     */\r\n    static IsIdentity(quaternion) {\r\n        return quaternion && quaternion.x === 0 && quaternion.y === 0 && quaternion.z === 0 && quaternion.w === 1;\r\n    }\r\n    /**\r\n     * Creates a quaternion from a rotation around an axis\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle to use\r\n     * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\r\n     */\r\n    static RotationAxis(axis, angle) {\r\n        return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\r\n    }\r\n    /**\r\n     * Creates a rotation around an axis and stores it into the given quaternion\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle to use\r\n     * @param result defines the target quaternion\r\n     * @returns the target quaternion\r\n     */\r\n    static RotationAxisToRef(axis, angle, result) {\r\n        var sin = Math.sin(angle / 2);\r\n        axis.normalize();\r\n        result.w = Math.cos(angle / 2);\r\n        result.x = axis.x * sin;\r\n        result.y = axis.y * sin;\r\n        result.z = axis.z * sin;\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new quaternion from data stored into an array\r\n     * @param array defines the data source\r\n     * @param offset defines the offset in the source array where the data starts\r\n     * @returns a new quaternion\r\n     */\r\n    static FromArray(array, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n    /**\r\n     * Create a quaternion from Euler rotation angles\r\n     * @param x Pitch\r\n     * @param y Yaw\r\n     * @param z Roll\r\n     * @returns the new Quaternion\r\n     */\r\n    static FromEulerAngles(x, y, z) {\r\n        var q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, q);\r\n        return q;\r\n    }\r\n    /**\r\n     * Updates a quaternion from Euler rotation angles\r\n     * @param x Pitch\r\n     * @param y Yaw\r\n     * @param z Roll\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    static FromEulerAnglesToRef(x, y, z, result) {\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Create a quaternion from Euler rotation vector\r\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n     * @returns the new Quaternion\r\n     */\r\n    static FromEulerVector(vec) {\r\n        var q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(vec.y, vec.x, vec.z, q);\r\n        return q;\r\n    }\r\n    /**\r\n     * Updates a quaternion from Euler rotation vector\r\n     * @param vec the Euler vector (x Pitch, y Yaw, z Roll)\r\n     * @param result the quaternion to store the result\r\n     * @returns the updated quaternion\r\n     */\r\n    static FromEulerVectorToRef(vec, result) {\r\n        Quaternion.RotationYawPitchRollToRef(vec.y, vec.x, vec.z, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles (y, x, z)\r\n     * @param yaw defines the rotation around Y axis\r\n     * @param pitch defines the rotation around X axis\r\n     * @param roll defines the rotation around Z axis\r\n     * @returns the new quaternion\r\n     */\r\n    static RotationYawPitchRoll(yaw, pitch, roll) {\r\n        var q = new Quaternion();\r\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\r\n        return q;\r\n    }\r\n    /**\r\n     * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\r\n     * @param yaw defines the rotation around Y axis\r\n     * @param pitch defines the rotation around X axis\r\n     * @param roll defines the rotation around Z axis\r\n     * @param result defines the target quaternion\r\n     */\r\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\r\n        // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\r\n        var halfRoll = roll * 0.5;\r\n        var halfPitch = pitch * 0.5;\r\n        var halfYaw = yaw * 0.5;\r\n        var sinRoll = Math.sin(halfRoll);\r\n        var cosRoll = Math.cos(halfRoll);\r\n        var sinPitch = Math.sin(halfPitch);\r\n        var cosPitch = Math.cos(halfPitch);\r\n        var sinYaw = Math.sin(halfYaw);\r\n        var cosYaw = Math.cos(halfYaw);\r\n        result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n        result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n        result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n        result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n    }\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\r\n     * @param alpha defines the rotation around first axis\r\n     * @param beta defines the rotation around second axis\r\n     * @param gamma defines the rotation around third axis\r\n     * @returns the new quaternion\r\n     */\r\n    static RotationAlphaBetaGamma(alpha, beta, gamma) {\r\n        var result = new Quaternion();\r\n        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\r\n     * @param alpha defines the rotation around first axis\r\n     * @param beta defines the rotation around second axis\r\n     * @param gamma defines the rotation around third axis\r\n     * @param result defines the target quaternion\r\n     */\r\n    static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {\r\n        // Produces a quaternion from Euler angles in the z-x-z orientation\r\n        var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\r\n        var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\r\n        var halfBeta = beta * 0.5;\r\n        result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n        result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n    }\r\n    /**\r\n     * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @returns the new quaternion\r\n     */\r\n    static RotationQuaternionFromAxis(axis1, axis2, axis3) {\r\n        var quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\r\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\r\n        return quat;\r\n    }\r\n    /**\r\n     * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\r\n     * @param axis1 defines the first axis\r\n     * @param axis2 defines the second axis\r\n     * @param axis3 defines the third axis\r\n     * @param ref defines the target quaternion\r\n     */\r\n    static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {\r\n        var rotMat = MathTmp.Matrix[0];\r\n        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\r\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\r\n    }\r\n    /**\r\n     * Interpolates between two quaternions\r\n     * @param left defines first quaternion\r\n     * @param right defines second quaternion\r\n     * @param amount defines the gradient to use\r\n     * @returns the new interpolated quaternion\r\n     */\r\n    static Slerp(left, right, amount) {\r\n        var result = Quaternion.Identity();\r\n        Quaternion.SlerpToRef(left, right, amount, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Interpolates between two quaternions and stores it into a target quaternion\r\n     * @param left defines first quaternion\r\n     * @param right defines second quaternion\r\n     * @param amount defines the gradient to use\r\n     * @param result defines the target quaternion\r\n     */\r\n    static SlerpToRef(left, right, amount, result) {\r\n        var num2;\r\n        var num3;\r\n        var num4 = (((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w);\r\n        var flag = false;\r\n        if (num4 < 0) {\r\n            flag = true;\r\n            num4 = -num4;\r\n        }\r\n        if (num4 > 0.999999) {\r\n            num3 = 1 - amount;\r\n            num2 = flag ? -amount : amount;\r\n        }\r\n        else {\r\n            var num5 = Math.acos(num4);\r\n            var num6 = (1.0 / Math.sin(num5));\r\n            num3 = (Math.sin((1.0 - amount) * num5)) * num6;\r\n            num2 = flag ? ((-Math.sin(amount * num5)) * num6) : ((Math.sin(amount * num5)) * num6);\r\n        }\r\n        result.x = (num3 * left.x) + (num2 * right.x);\r\n        result.y = (num3 * left.y) + (num2 * right.y);\r\n        result.z = (num3 * left.z) + (num2 * right.z);\r\n        result.w = (num3 * left.w) + (num2 * right.w);\r\n    }\r\n    /**\r\n     * Interpolate between two quaternions using Hermite interpolation\r\n     * @param value1 defines first quaternion\r\n     * @param tangent1 defines the incoming tangent\r\n     * @param value2 defines second quaternion\r\n     * @param tangent2 defines the outgoing tangent\r\n     * @param amount defines the target quaternion\r\n     * @returns the new interpolated quaternion\r\n     */\r\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\r\n        var squared = amount * amount;\r\n        var cubed = amount * squared;\r\n        var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        var part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        var part3 = (cubed - (2.0 * squared)) + amount;\r\n        var part4 = cubed - squared;\r\n        var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\r\n        var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\r\n        var z = (((value1.z * part1) + (value2.z * part2)) + (tangent1.z * part3)) + (tangent2.z * part4);\r\n        var w = (((value1.w * part1) + (value2.w * part2)) + (tangent1.w * part3)) + (tangent2.w * part4);\r\n        return new Quaternion(x, y, z, w);\r\n    }\r\n}\r\n/**\r\n * Class used to store matrix data (4x4)\r\n */\r\nclass Matrix {\r\n    /**\r\n     * Creates an empty matrix (filled with zeros)\r\n     */\r\n    constructor() {\r\n        this._isIdentity = false;\r\n        this._isIdentityDirty = true;\r\n        this._isIdentity3x2 = true;\r\n        this._isIdentity3x2Dirty = true;\r\n        /**\r\n         * Gets the update flag of the matrix which is an unique number for the matrix.\r\n         * It will be incremented every time the matrix data change.\r\n         * You can use it to speed the comparison between two versions of the same matrix.\r\n         */\r\n        this.updateFlag = -1;\r\n        this._m = new Float32Array(16);\r\n        this._updateIdentityStatus(false);\r\n    }\r\n    /**\r\n     * Gets the internal data of the matrix\r\n     */\r\n    get m() { return this._m; }\r\n    /** @hidden */\r\n    _markAsUpdated() {\r\n        this.updateFlag = Matrix._updateFlagSeed++;\r\n        this._isIdentity = false;\r\n        this._isIdentity3x2 = false;\r\n        this._isIdentityDirty = true;\r\n        this._isIdentity3x2Dirty = true;\r\n    }\r\n    /** @hidden */\r\n    _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {\r\n        this.updateFlag = Matrix._updateFlagSeed++;\r\n        this._isIdentity = isIdentity;\r\n        this._isIdentity3x2 = isIdentity || isIdentity3x2;\r\n        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\r\n        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\r\n    }\r\n    // Properties\r\n    /**\r\n     * Check if the current matrix is identity\r\n     * @returns true is the matrix is the identity matrix\r\n     */\r\n    isIdentity() {\r\n        if (this._isIdentityDirty) {\r\n            this._isIdentityDirty = false;\r\n            const m = this._m;\r\n            this._isIdentity = (m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 &&\r\n                m[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 &&\r\n                m[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 &&\r\n                m[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0);\r\n        }\r\n        return this._isIdentity;\r\n    }\r\n    /**\r\n     * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\r\n     * @returns true is the matrix is the identity matrix\r\n     */\r\n    isIdentityAs3x2() {\r\n        if (this._isIdentity3x2Dirty) {\r\n            this._isIdentity3x2Dirty = false;\r\n            if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\r\n                this._isIdentity3x2 = false;\r\n            }\r\n            else if (this._m[1] !== 0.0 || this._m[2] !== 0.0 || this._m[3] !== 0.0 ||\r\n                this._m[4] !== 0.0 || this._m[6] !== 0.0 || this._m[7] !== 0.0 ||\r\n                this._m[8] !== 0.0 || this._m[9] !== 0.0 || this._m[10] !== 0.0 || this._m[11] !== 0.0 ||\r\n                this._m[12] !== 0.0 || this._m[13] !== 0.0 || this._m[14] !== 0.0) {\r\n                this._isIdentity3x2 = false;\r\n            }\r\n            else {\r\n                this._isIdentity3x2 = true;\r\n            }\r\n        }\r\n        return this._isIdentity3x2;\r\n    }\r\n    /**\r\n     * Gets the determinant of the matrix\r\n     * @returns the matrix determinant\r\n     */\r\n    determinant() {\r\n        if (this._isIdentity === true) {\r\n            return 1;\r\n        }\r\n        const m = this._m;\r\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\r\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\r\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\r\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\r\n        // https://en.wikipedia.org/wiki/Laplace_expansion\r\n        // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\r\n        // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\r\n        // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\r\n        // where\r\n        //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\r\n        //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\r\n        //\r\n        // Here we do that for the 1st row.\r\n        const det_22_33 = m22 * m33 - m32 * m23;\r\n        const det_21_33 = m21 * m33 - m31 * m23;\r\n        const det_21_32 = m21 * m32 - m31 * m22;\r\n        const det_20_33 = m20 * m33 - m30 * m23;\r\n        const det_20_32 = m20 * m32 - m22 * m30;\r\n        const det_20_31 = m20 * m31 - m30 * m21;\r\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\r\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\r\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\r\n        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\r\n    }\r\n    // Methods\r\n    /**\r\n     * Returns the matrix as a Float32Array\r\n     * @returns the matrix underlying array\r\n     */\r\n    toArray() {\r\n        return this._m;\r\n    }\r\n    /**\r\n     * Returns the matrix as a Float32Array\r\n    * @returns the matrix underlying array.\r\n    */\r\n    asArray() {\r\n        return this._m;\r\n    }\r\n    /**\r\n     * Inverts the current matrix in place\r\n     * @returns the current inverted matrix\r\n     */\r\n    invert() {\r\n        this.invertToRef(this);\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets all the matrix elements to zero\r\n     * @returns the current matrix\r\n     */\r\n    reset() {\r\n        Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\r\n        this._updateIdentityStatus(false);\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds the current matrix with a second one\r\n     * @param other defines the matrix to add\r\n     * @returns a new matrix as the addition of the current matrix and the given one\r\n     */\r\n    add(other) {\r\n        var result = new Matrix();\r\n        this.addToRef(other, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given matrix \"result\" to the addition of the current matrix and the given one\r\n     * @param other defines the matrix to add\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    addToRef(other, result) {\r\n        const m = this._m;\r\n        const resultM = result._m;\r\n        const otherM = other.m;\r\n        for (var index = 0; index < 16; index++) {\r\n            resultM[index] = m[index] + otherM[index];\r\n        }\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds in place the given matrix to the current matrix\r\n     * @param other defines the second operand\r\n     * @returns the current updated matrix\r\n     */\r\n    addToSelf(other) {\r\n        const m = this._m;\r\n        const otherM = other.m;\r\n        for (var index = 0; index < 16; index++) {\r\n            m[index] += otherM[index];\r\n        }\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the given matrix to the current inverted Matrix\r\n     * @param other defines the target matrix\r\n     * @returns the unmodified current matrix\r\n     */\r\n    invertToRef(other) {\r\n        if (this._isIdentity === true) {\r\n            Matrix.IdentityToRef(other);\r\n            return this;\r\n        }\r\n        // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\r\n        const m = this._m;\r\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\r\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\r\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\r\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\r\n        const det_22_33 = m22 * m33 - m32 * m23;\r\n        const det_21_33 = m21 * m33 - m31 * m23;\r\n        const det_21_32 = m21 * m32 - m31 * m22;\r\n        const det_20_33 = m20 * m33 - m30 * m23;\r\n        const det_20_32 = m20 * m32 - m22 * m30;\r\n        const det_20_31 = m20 * m31 - m30 * m21;\r\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\r\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\r\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\r\n        const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\r\n        if (det === 0) {\r\n            // not invertible\r\n            other.copyFrom(this);\r\n            return this;\r\n        }\r\n        const detInv = 1 / det;\r\n        const det_12_33 = m12 * m33 - m32 * m13;\r\n        const det_11_33 = m11 * m33 - m31 * m13;\r\n        const det_11_32 = m11 * m32 - m31 * m12;\r\n        const det_10_33 = m10 * m33 - m30 * m13;\r\n        const det_10_32 = m10 * m32 - m30 * m12;\r\n        const det_10_31 = m10 * m31 - m30 * m11;\r\n        const det_12_23 = m12 * m23 - m22 * m13;\r\n        const det_11_23 = m11 * m23 - m21 * m13;\r\n        const det_11_22 = m11 * m22 - m21 * m12;\r\n        const det_10_23 = m10 * m23 - m20 * m13;\r\n        const det_10_22 = m10 * m22 - m20 * m12;\r\n        const det_10_21 = m10 * m21 - m20 * m11;\r\n        const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\r\n        const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\r\n        const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\r\n        const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\r\n        const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\r\n        const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\r\n        const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\r\n        const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\r\n        const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\r\n        const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\r\n        const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\r\n        const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\r\n        Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\r\n        return this;\r\n    }\r\n    /**\r\n     * add a value at the specified position in the current Matrix\r\n     * @param index the index of the value within the matrix. between 0 and 15.\r\n     * @param value the value to be added\r\n     * @returns the current updated matrix\r\n     */\r\n    addAtIndex(index, value) {\r\n        this._m[index] += value;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * mutiply the specified position in the current Matrix by a value\r\n     * @param index the index of the value within the matrix. between 0 and 15.\r\n     * @param value the value to be added\r\n     * @returns the current updated matrix\r\n     */\r\n    multiplyAtIndex(index, value) {\r\n        this._m[index] *= value;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Inserts the translation vector (using 3 floats) in the current matrix\r\n     * @param x defines the 1st component of the translation\r\n     * @param y defines the 2nd component of the translation\r\n     * @param z defines the 3rd component of the translation\r\n     * @returns the current updated matrix\r\n     */\r\n    setTranslationFromFloats(x, y, z) {\r\n        this._m[12] = x;\r\n        this._m[13] = y;\r\n        this._m[14] = z;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds the translation vector (using 3 floats) in the current matrix\r\n     * @param x defines the 1st component of the translation\r\n     * @param y defines the 2nd component of the translation\r\n     * @param z defines the 3rd component of the translation\r\n     * @returns the current updated matrix\r\n     */\r\n    addTranslationFromFloats(x, y, z) {\r\n        this._m[12] += x;\r\n        this._m[13] += y;\r\n        this._m[14] += z;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Inserts the translation vector in the current matrix\r\n     * @param vector3 defines the translation to insert\r\n     * @returns the current updated matrix\r\n     */\r\n    setTranslation(vector3) {\r\n        return this.setTranslationFromFloats(vector3.x, vector3.y, vector3.z);\r\n    }\r\n    /**\r\n     * Gets the translation value of the current matrix\r\n     * @returns a new Vector3 as the extracted translation from the matrix\r\n     */\r\n    getTranslation() {\r\n        return new Vector3(this._m[12], this._m[13], this._m[14]);\r\n    }\r\n    /**\r\n     * Fill a Vector3 with the extracted translation from the matrix\r\n     * @param result defines the Vector3 where to store the translation\r\n     * @returns the current matrix\r\n     */\r\n    getTranslationToRef(result) {\r\n        result.x = this._m[12];\r\n        result.y = this._m[13];\r\n        result.z = this._m[14];\r\n        return this;\r\n    }\r\n    /**\r\n     * Remove rotation and scaling part from the matrix\r\n     * @returns the updated matrix\r\n     */\r\n    removeRotationAndScaling() {\r\n        const m = this.m;\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\r\n        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\r\n        return this;\r\n    }\r\n    /**\r\n     * Multiply two matrices\r\n     * @param other defines the second operand\r\n     * @returns a new matrix set with the multiplication result of the current Matrix and the given one\r\n     */\r\n    multiply(other) {\r\n        var result = new Matrix();\r\n        this.multiplyToRef(other, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Copy the current matrix from the given one\r\n     * @param other defines the source matrix\r\n     * @returns the current updated matrix\r\n     */\r\n    copyFrom(other) {\r\n        other.copyToArray(this._m);\r\n        const o = other;\r\n        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\r\n        return this;\r\n    }\r\n    /**\r\n     * Populates the given array from the starting index with the current matrix values\r\n     * @param array defines the target array\r\n     * @param offset defines the offset in the target array where to start storing values\r\n     * @returns the current matrix\r\n     */\r\n    copyToArray(array, offset = 0) {\r\n        for (var index = 0; index < 16; index++) {\r\n            array[offset + index] = this._m[index];\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\r\n     * @param other defines the second operand\r\n     * @param result defines the matrix where to store the multiplication\r\n     * @returns the current matrix\r\n     */\r\n    multiplyToRef(other, result) {\r\n        if (this._isIdentity) {\r\n            result.copyFrom(other);\r\n            return this;\r\n        }\r\n        if (other._isIdentity) {\r\n            result.copyFrom(this);\r\n            return this;\r\n        }\r\n        this.multiplyToArray(other, result._m, 0);\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the Float32Array \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\r\n     * @param other defines the second operand\r\n     * @param result defines the array where to store the multiplication\r\n     * @param offset defines the offset in the target array where to start storing values\r\n     * @returns the current matrix\r\n     */\r\n    multiplyToArray(other, result, offset) {\r\n        const m = this._m;\r\n        const otherM = other.m;\r\n        var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];\r\n        var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];\r\n        var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];\r\n        var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];\r\n        var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];\r\n        var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];\r\n        var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];\r\n        var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];\r\n        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\r\n        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\r\n        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\r\n        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\r\n        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\r\n        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\r\n        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\r\n        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\r\n        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\r\n        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\r\n        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\r\n        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\r\n        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\r\n        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\r\n        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\r\n        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\r\n        return this;\r\n    }\r\n    /**\r\n     * Check equality between this matrix and a second one\r\n     * @param value defines the second matrix to compare\r\n     * @returns true is the current matrix and the given one values are strictly equal\r\n     */\r\n    equals(value) {\r\n        const other = value;\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        if (this._isIdentity || other._isIdentity) {\r\n            if (!this._isIdentityDirty && !other._isIdentityDirty) {\r\n                return this._isIdentity && other._isIdentity;\r\n            }\r\n        }\r\n        const m = this.m;\r\n        const om = other.m;\r\n        return (m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] &&\r\n            m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] &&\r\n            m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] &&\r\n            m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15]);\r\n    }\r\n    /**\r\n     * Clone the current matrix\r\n     * @returns a new matrix from the current matrix\r\n     */\r\n    clone() {\r\n        const matrix = new Matrix();\r\n        matrix.copyFrom(this);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Returns the name of the current matrix class\r\n     * @returns the string \"Matrix\"\r\n     */\r\n    getClassName() {\r\n        return \"Matrix\";\r\n    }\r\n    /**\r\n     * Gets the hash code of the current matrix\r\n     * @returns the hash code\r\n     */\r\n    getHashCode() {\r\n        let hash = this._m[0] || 0;\r\n        for (let i = 1; i < 16; i++) {\r\n            hash = (hash * 397) ^ (this._m[i] || 0);\r\n        }\r\n        return hash;\r\n    }\r\n    /**\r\n     * Decomposes the current Matrix into a translation, rotation and scaling components\r\n     * @param scale defines the scale vector3 given as a reference to update\r\n     * @param rotation defines the rotation quaternion given as a reference to update\r\n     * @param translation defines the translation vector3 given as a reference to update\r\n     * @returns true if operation was successful\r\n     */\r\n    decompose(scale, rotation, translation) {\r\n        if (this._isIdentity) {\r\n            if (translation) {\r\n                translation.setAll(0);\r\n            }\r\n            if (scale) {\r\n                scale.setAll(1);\r\n            }\r\n            if (rotation) {\r\n                rotation.copyFromFloats(0, 0, 0, 1);\r\n            }\r\n            return true;\r\n        }\r\n        const m = this._m;\r\n        if (translation) {\r\n            translation.copyFromFloats(m[12], m[13], m[14]);\r\n        }\r\n        scale = scale || MathTmp.Vector3[0];\r\n        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\r\n        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\r\n        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\r\n        if (this.determinant() <= 0) {\r\n            scale.y *= -1;\r\n        }\r\n        if (scale.x === 0 || scale.y === 0 || scale.z === 0) {\r\n            if (rotation) {\r\n                rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\r\n            }\r\n            return false;\r\n        }\r\n        if (rotation) {\r\n            const sx = 1 / scale.x, sy = 1 / scale.y, sz = 1 / scale.z;\r\n            Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, MathTmp.Matrix[0]);\r\n            Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets specific row of the matrix\r\n     * @param index defines the number of the row to get\r\n     * @returns the index-th row of the current matrix as a new Vector4\r\n     */\r\n    getRow(index) {\r\n        if (index < 0 || index > 3) {\r\n            return null;\r\n        }\r\n        var i = index * 4;\r\n        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\r\n    }\r\n    /**\r\n     * Sets the index-th row of the current matrix to the vector4 values\r\n     * @param index defines the number of the row to set\r\n     * @param row defines the target vector4\r\n     * @returns the updated current matrix\r\n     */\r\n    setRow(index, row) {\r\n        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\r\n    }\r\n    /**\r\n     * Compute the transpose of the matrix\r\n     * @returns the new transposed matrix\r\n     */\r\n    transpose() {\r\n        return Matrix.Transpose(this);\r\n    }\r\n    /**\r\n     * Compute the transpose of the matrix and store it in a given matrix\r\n     * @param result defines the target matrix\r\n     * @returns the current matrix\r\n     */\r\n    transposeToRef(result) {\r\n        Matrix.TransposeToRef(this, result);\r\n        return this;\r\n    }\r\n    /**\r\n     * Sets the index-th row of the current matrix with the given 4 x float values\r\n     * @param index defines the row index\r\n     * @param x defines the x component to set\r\n     * @param y defines the y component to set\r\n     * @param z defines the z component to set\r\n     * @param w defines the w component to set\r\n     * @returns the updated current matrix\r\n     */\r\n    setRowFromFloats(index, x, y, z, w) {\r\n        if (index < 0 || index > 3) {\r\n            return this;\r\n        }\r\n        var i = index * 4;\r\n        this._m[i + 0] = x;\r\n        this._m[i + 1] = y;\r\n        this._m[i + 2] = z;\r\n        this._m[i + 3] = w;\r\n        this._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Compute a new matrix set with the current matrix values multiplied by scale (float)\r\n     * @param scale defines the scale factor\r\n     * @returns a new matrix\r\n     */\r\n    scale(scale) {\r\n        var result = new Matrix();\r\n        this.scaleToRef(scale, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Scale the current matrix values by a factor to a given result matrix\r\n     * @param scale defines the scale factor\r\n     * @param result defines the matrix to store the result\r\n     * @returns the current matrix\r\n     */\r\n    scaleToRef(scale, result) {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] = this._m[index] * scale;\r\n        }\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Scale the current matrix values by a factor and add the result to a given matrix\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Matrix to store the result\r\n     * @returns the current matrix\r\n     */\r\n    scaleAndAddToRef(scale, result) {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] += this._m[index] * scale;\r\n        }\r\n        result._markAsUpdated();\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\r\n     * @param ref matrix to store the result\r\n     */\r\n    toNormalMatrix(ref) {\r\n        const tmp = MathTmp.Matrix[0];\r\n        this.invertToRef(tmp);\r\n        tmp.transposeToRef(ref);\r\n        var m = ref._m;\r\n        Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\r\n    }\r\n    /**\r\n     * Gets only rotation part of the current matrix\r\n     * @returns a new matrix sets to the extracted rotation matrix from the current one\r\n     */\r\n    getRotationMatrix() {\r\n        var result = new Matrix();\r\n        this.getRotationMatrixToRef(result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Extracts the rotation matrix from the current one and sets it as the given \"result\"\r\n     * @param result defines the target matrix to store data to\r\n     * @returns the current matrix\r\n     */\r\n    getRotationMatrixToRef(result) {\r\n        const scale = MathTmp.Vector3[0];\r\n        if (!this.decompose(scale)) {\r\n            Matrix.IdentityToRef(result);\r\n            return this;\r\n        }\r\n        const m = this._m;\r\n        const sx = 1 / scale.x, sy = 1 / scale.y, sz = 1 / scale.z;\r\n        Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        return this;\r\n    }\r\n    /**\r\n     * Toggles model matrix from being right handed to left handed in place and vice versa\r\n     */\r\n    toggleModelMatrixHandInPlace() {\r\n        const m = this._m;\r\n        m[2] *= -1;\r\n        m[6] *= -1;\r\n        m[8] *= -1;\r\n        m[9] *= -1;\r\n        m[14] *= -1;\r\n        this._markAsUpdated();\r\n    }\r\n    /**\r\n     * Toggles projection matrix from being right handed to left handed in place and vice versa\r\n     */\r\n    toggleProjectionMatrixHandInPlace() {\r\n        var m = this._m;\r\n        m[8] *= -1;\r\n        m[9] *= -1;\r\n        m[10] *= -1;\r\n        m[11] *= -1;\r\n        this._markAsUpdated();\r\n    }\r\n    // Statics\r\n    /**\r\n     * Creates a matrix from an array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Matrix set from the starting index of the given array\r\n     */\r\n    static FromArray(array, offset = 0) {\r\n        var result = new Matrix();\r\n        Matrix.FromArrayToRef(array, offset, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Copy the content of an array into a given matrix\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @param result defines the target matrix\r\n     */\r\n    static FromArrayToRef(array, offset, result) {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] = array[index + offset];\r\n        }\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Stores an array into a matrix after having multiplied each component by a given factor\r\n     * @param array defines the source array\r\n     * @param offset defines the offset in the source array\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the target matrix\r\n     */\r\n    static FromFloat32ArrayToRefScaled(array, offset, scale, result) {\r\n        for (var index = 0; index < 16; index++) {\r\n            result._m[index] = array[index + offset] * scale;\r\n        }\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Gets an identity matrix that must not be updated\r\n     */\r\n    static get IdentityReadOnly() {\r\n        return Matrix._identityReadOnly;\r\n    }\r\n    /**\r\n     * Stores a list of values (16) inside a given matrix\r\n     * @param initialM11 defines 1st value of 1st row\r\n     * @param initialM12 defines 2nd value of 1st row\r\n     * @param initialM13 defines 3rd value of 1st row\r\n     * @param initialM14 defines 4th value of 1st row\r\n     * @param initialM21 defines 1st value of 2nd row\r\n     * @param initialM22 defines 2nd value of 2nd row\r\n     * @param initialM23 defines 3rd value of 2nd row\r\n     * @param initialM24 defines 4th value of 2nd row\r\n     * @param initialM31 defines 1st value of 3rd row\r\n     * @param initialM32 defines 2nd value of 3rd row\r\n     * @param initialM33 defines 3rd value of 3rd row\r\n     * @param initialM34 defines 4th value of 3rd row\r\n     * @param initialM41 defines 1st value of 4th row\r\n     * @param initialM42 defines 2nd value of 4th row\r\n     * @param initialM43 defines 3rd value of 4th row\r\n     * @param initialM44 defines 4th value of 4th row\r\n     * @param result defines the target matrix\r\n     */\r\n    static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\r\n        const m = result._m;\r\n        m[0] = initialM11;\r\n        m[1] = initialM12;\r\n        m[2] = initialM13;\r\n        m[3] = initialM14;\r\n        m[4] = initialM21;\r\n        m[5] = initialM22;\r\n        m[6] = initialM23;\r\n        m[7] = initialM24;\r\n        m[8] = initialM31;\r\n        m[9] = initialM32;\r\n        m[10] = initialM33;\r\n        m[11] = initialM34;\r\n        m[12] = initialM41;\r\n        m[13] = initialM42;\r\n        m[14] = initialM43;\r\n        m[15] = initialM44;\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Creates new matrix from a list of values (16)\r\n     * @param initialM11 defines 1st value of 1st row\r\n     * @param initialM12 defines 2nd value of 1st row\r\n     * @param initialM13 defines 3rd value of 1st row\r\n     * @param initialM14 defines 4th value of 1st row\r\n     * @param initialM21 defines 1st value of 2nd row\r\n     * @param initialM22 defines 2nd value of 2nd row\r\n     * @param initialM23 defines 3rd value of 2nd row\r\n     * @param initialM24 defines 4th value of 2nd row\r\n     * @param initialM31 defines 1st value of 3rd row\r\n     * @param initialM32 defines 2nd value of 3rd row\r\n     * @param initialM33 defines 3rd value of 3rd row\r\n     * @param initialM34 defines 4th value of 3rd row\r\n     * @param initialM41 defines 1st value of 4th row\r\n     * @param initialM42 defines 2nd value of 4th row\r\n     * @param initialM43 defines 3rd value of 4th row\r\n     * @param initialM44 defines 4th value of 4th row\r\n     * @returns the new matrix\r\n     */\r\n    static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\r\n        var result = new Matrix();\r\n        const m = result._m;\r\n        m[0] = initialM11;\r\n        m[1] = initialM12;\r\n        m[2] = initialM13;\r\n        m[3] = initialM14;\r\n        m[4] = initialM21;\r\n        m[5] = initialM22;\r\n        m[6] = initialM23;\r\n        m[7] = initialM24;\r\n        m[8] = initialM31;\r\n        m[9] = initialM32;\r\n        m[10] = initialM33;\r\n        m[11] = initialM34;\r\n        m[12] = initialM41;\r\n        m[13] = initialM42;\r\n        m[14] = initialM43;\r\n        m[15] = initialM44;\r\n        result._markAsUpdated();\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n     * @param scale defines the scale vector3\r\n     * @param rotation defines the rotation quaternion\r\n     * @param translation defines the translation vector3\r\n     * @returns a new matrix\r\n     */\r\n    static Compose(scale, rotation, translation) {\r\n        var result = new Matrix();\r\n        Matrix.ComposeToRef(scale, rotation, translation, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\r\n     * @param scale defines the scale vector3\r\n     * @param rotation defines the rotation quaternion\r\n     * @param translation defines the translation vector3\r\n     * @param result defines the target matrix\r\n     */\r\n    static ComposeToRef(scale, rotation, translation, result) {\r\n        let m = result._m;\r\n        var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;\r\n        var x2 = x + x, y2 = y + y, z2 = z + z;\r\n        var xx = x * x2, xy = x * y2, xz = x * z2;\r\n        var yy = y * y2, yz = y * z2, zz = z * z2;\r\n        var wx = w * x2, wy = w * y2, wz = w * z2;\r\n        var sx = scale.x, sy = scale.y, sz = scale.z;\r\n        m[0] = (1 - (yy + zz)) * sx;\r\n        m[1] = (xy + wz) * sx;\r\n        m[2] = (xz - wy) * sx;\r\n        m[3] = 0;\r\n        m[4] = (xy - wz) * sy;\r\n        m[5] = (1 - (xx + zz)) * sy;\r\n        m[6] = (yz + wx) * sy;\r\n        m[7] = 0;\r\n        m[8] = (xz + wy) * sz;\r\n        m[9] = (yz - wx) * sz;\r\n        m[10] = (1 - (xx + yy)) * sz;\r\n        m[11] = 0;\r\n        m[12] = translation.x;\r\n        m[13] = translation.y;\r\n        m[14] = translation.z;\r\n        m[15] = 1;\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Creates a new identity matrix\r\n     * @returns a new identity matrix\r\n     */\r\n    static Identity() {\r\n        const identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n        identity._updateIdentityStatus(true);\r\n        return identity;\r\n    }\r\n    /**\r\n     * Creates a new identity matrix and stores the result in a given matrix\r\n     * @param result defines the target matrix\r\n     */\r\n    static IdentityToRef(result) {\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        result._updateIdentityStatus(true);\r\n    }\r\n    /**\r\n     * Creates a new zero matrix\r\n     * @returns a new zero matrix\r\n     */\r\n    static Zero() {\r\n        const zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\r\n        zero._updateIdentityStatus(false);\r\n        return zero;\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the X axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    static RotationX(angle) {\r\n        var result = new Matrix();\r\n        Matrix.RotationXToRef(angle, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new matrix as the invert of a given matrix\r\n     * @param source defines the source matrix\r\n     * @returns the new matrix\r\n     */\r\n    static Invert(source) {\r\n        var result = new Matrix();\r\n        source.invertToRef(result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    static RotationXToRef(angle, result) {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    static RotationY(angle) {\r\n        var result = new Matrix();\r\n        Matrix.RotationYToRef(angle, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    static RotationYToRef(angle, result) {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    static RotationZ(angle) {\r\n        var result = new Matrix();\r\n        Matrix.RotationZToRef(angle, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    static RotationZToRef(angle, result) {\r\n        var s = Math.sin(angle);\r\n        var c = Math.cos(angle);\r\n        Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        result._updateIdentityStatus(c === 1 && s === 0);\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the given axis\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle (in radians) to use\r\n     * @return the new matrix\r\n     */\r\n    static RotationAxis(axis, angle) {\r\n        var result = new Matrix();\r\n        Matrix.RotationAxisToRef(axis, angle, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\r\n     * @param axis defines the axis to use\r\n     * @param angle defines the angle (in radians) to use\r\n     * @param result defines the target matrix\r\n     */\r\n    static RotationAxisToRef(axis, angle, result) {\r\n        var s = Math.sin(-angle);\r\n        var c = Math.cos(-angle);\r\n        var c1 = 1 - c;\r\n        axis.normalize();\r\n        const m = result._m;\r\n        m[0] = (axis.x * axis.x) * c1 + c;\r\n        m[1] = (axis.x * axis.y) * c1 - (axis.z * s);\r\n        m[2] = (axis.x * axis.z) * c1 + (axis.y * s);\r\n        m[3] = 0.0;\r\n        m[4] = (axis.y * axis.x) * c1 + (axis.z * s);\r\n        m[5] = (axis.y * axis.y) * c1 + c;\r\n        m[6] = (axis.y * axis.z) * c1 - (axis.x * s);\r\n        m[7] = 0.0;\r\n        m[8] = (axis.z * axis.x) * c1 - (axis.y * s);\r\n        m[9] = (axis.z * axis.y) * c1 + (axis.x * s);\r\n        m[10] = (axis.z * axis.z) * c1 + c;\r\n        m[11] = 0.0;\r\n        m[12] = 0.0;\r\n        m[13] = 0.0;\r\n        m[14] = 0.0;\r\n        m[15] = 1.0;\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Takes normalised vectors and returns a rotation matrix to align \"from\" with \"to\".\r\n     * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm\r\n     * @param from defines the vector to align\r\n     * @param to defines the vector to align to\r\n     * @param result defines the target matrix\r\n     */\r\n    static RotationAlignToRef(from, to, result) {\r\n        const v = Vector3.Cross(to, from);\r\n        const c = Vector3.Dot(to, from);\r\n        const k = 1 / (1 + c);\r\n        const m = result._m;\r\n        m[0] = v.x * v.x * k + c;\r\n        m[1] = v.y * v.x * k - v.z;\r\n        m[2] = v.z * v.x * k + v.y;\r\n        m[3] = 0;\r\n        m[4] = v.x * v.y * k + v.z;\r\n        m[5] = v.y * v.y * k + c;\r\n        m[6] = v.z * v.y * k - v.x;\r\n        m[7] = 0;\r\n        m[8] = v.x * v.z * k - v.y;\r\n        m[9] = v.y * v.z * k + v.x;\r\n        m[10] = v.z * v.z * k + c;\r\n        m[11] = 0;\r\n        m[12] = 0;\r\n        m[13] = 0;\r\n        m[14] = 0;\r\n        m[15] = 1;\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Creates a rotation matrix\r\n     * @param yaw defines the yaw angle in radians (Y axis)\r\n     * @param pitch defines the pitch angle in radians (X axis)\r\n     * @param roll defines the roll angle in radians (X axis)\r\n     * @returns the new rotation matrix\r\n     */\r\n    static RotationYawPitchRoll(yaw, pitch, roll) {\r\n        var result = new Matrix();\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a rotation matrix and stores it in a given matrix\r\n     * @param yaw defines the yaw angle in radians (Y axis)\r\n     * @param pitch defines the pitch angle in radians (X axis)\r\n     * @param roll defines the roll angle in radians (X axis)\r\n     * @param result defines the target matrix\r\n     */\r\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\r\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);\r\n        MathTmp.Quaternion[0].toRotationMatrix(result);\r\n    }\r\n    /**\r\n     * Creates a scaling matrix\r\n     * @param x defines the scale factor on X axis\r\n     * @param y defines the scale factor on Y axis\r\n     * @param z defines the scale factor on Z axis\r\n     * @returns the new matrix\r\n     */\r\n    static Scaling(x, y, z) {\r\n        var result = new Matrix();\r\n        Matrix.ScalingToRef(x, y, z, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a scaling matrix and stores it in a given matrix\r\n     * @param x defines the scale factor on X axis\r\n     * @param y defines the scale factor on Y axis\r\n     * @param z defines the scale factor on Z axis\r\n     * @param result defines the target matrix\r\n     */\r\n    static ScalingToRef(x, y, z, result) {\r\n        Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\r\n    }\r\n    /**\r\n     * Creates a translation matrix\r\n     * @param x defines the translation on X axis\r\n     * @param y defines the translation on Y axis\r\n     * @param z defines the translationon Z axis\r\n     * @returns the new matrix\r\n     */\r\n    static Translation(x, y, z) {\r\n        var result = new Matrix();\r\n        Matrix.TranslationToRef(x, y, z, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a translation matrix and stores it in a given matrix\r\n     * @param x defines the translation on X axis\r\n     * @param y defines the translation on Y axis\r\n     * @param z defines the translationon Z axis\r\n     * @param result defines the target matrix\r\n     */\r\n    static TranslationToRef(x, y, z, result) {\r\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\r\n        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\r\n    }\r\n    /**\r\n     * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n     * @param startValue defines the start value\r\n     * @param endValue defines the end value\r\n     * @param gradient defines the gradient factor\r\n     * @returns the new matrix\r\n     */\r\n    static Lerp(startValue, endValue, gradient) {\r\n        var result = new Matrix();\r\n        Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\r\n     * @param startValue defines the start value\r\n     * @param endValue defines the end value\r\n     * @param gradient defines the gradient factor\r\n     * @param result defines the Matrix object where to store data\r\n     */\r\n    static LerpToRef(startValue, endValue, gradient, result) {\r\n        const resultM = result._m;\r\n        const startM = startValue.m;\r\n        const endM = endValue.m;\r\n        for (var index = 0; index < 16; index++) {\r\n            resultM[index] = startM[index] * (1.0 - gradient) + endM[index] * gradient;\r\n        }\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Builds a new matrix whose values are computed by:\r\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n     * @param startValue defines the first matrix\r\n     * @param endValue defines the second matrix\r\n     * @param gradient defines the gradient between the two matrices\r\n     * @returns the new matrix\r\n     */\r\n    static DecomposeLerp(startValue, endValue, gradient) {\r\n        var result = new Matrix();\r\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Update a matrix to values which are computed by:\r\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\r\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\r\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\r\n     * @param startValue defines the first matrix\r\n     * @param endValue defines the second matrix\r\n     * @param gradient defines the gradient between the two matrices\r\n     * @param result defines the target matrix\r\n     */\r\n    static DecomposeLerpToRef(startValue, endValue, gradient, result) {\r\n        var startScale = MathTmp.Vector3[0];\r\n        var startRotation = MathTmp.Quaternion[0];\r\n        var startTranslation = MathTmp.Vector3[1];\r\n        startValue.decompose(startScale, startRotation, startTranslation);\r\n        var endScale = MathTmp.Vector3[2];\r\n        var endRotation = MathTmp.Quaternion[1];\r\n        var endTranslation = MathTmp.Vector3[3];\r\n        endValue.decompose(endScale, endRotation, endTranslation);\r\n        var resultScale = MathTmp.Vector3[4];\r\n        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\r\n        var resultRotation = MathTmp.Quaternion[2];\r\n        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\r\n        var resultTranslation = MathTmp.Vector3[5];\r\n        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\r\n        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\r\n    }\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n     * This function works in left handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @returns the new matrix\r\n     */\r\n    static LookAtLH(eye, target, up) {\r\n        var result = new Matrix();\r\n        Matrix.LookAtLHToRef(eye, target, up, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n     * This function works in left handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @param result defines the target matrix\r\n     */\r\n    static LookAtLHToRef(eye, target, up, result) {\r\n        const xAxis = MathTmp.Vector3[0];\r\n        const yAxis = MathTmp.Vector3[1];\r\n        const zAxis = MathTmp.Vector3[2];\r\n        // Z axis\r\n        target.subtractToRef(eye, zAxis);\r\n        zAxis.normalize();\r\n        // X axis\r\n        Vector3.CrossToRef(up, zAxis, xAxis);\r\n        const xSquareLength = xAxis.lengthSquared();\r\n        if (xSquareLength === 0) {\r\n            xAxis.x = 1.0;\r\n        }\r\n        else {\r\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\r\n        }\r\n        // Y axis\r\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\r\n        yAxis.normalize();\r\n        // Eye angles\r\n        var ex = -Vector3.Dot(xAxis, eye);\r\n        var ey = -Vector3.Dot(yAxis, eye);\r\n        var ez = -Vector3.Dot(zAxis, eye);\r\n        Matrix.FromValuesToRef(xAxis.x, yAxis.x, zAxis.x, 0.0, xAxis.y, yAxis.y, zAxis.y, 0.0, xAxis.z, yAxis.z, zAxis.z, 0.0, ex, ey, ez, 1.0, result);\r\n    }\r\n    /**\r\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\r\n     * This function works in right handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @returns the new matrix\r\n     */\r\n    static LookAtRH(eye, target, up) {\r\n        var result = new Matrix();\r\n        Matrix.LookAtRHToRef(eye, target, up, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\r\n     * This function works in right handed mode\r\n     * @param eye defines the final position of the entity\r\n     * @param target defines where the entity should look at\r\n     * @param up defines the up vector for the entity\r\n     * @param result defines the target matrix\r\n     */\r\n    static LookAtRHToRef(eye, target, up, result) {\r\n        const xAxis = MathTmp.Vector3[0];\r\n        const yAxis = MathTmp.Vector3[1];\r\n        const zAxis = MathTmp.Vector3[2];\r\n        // Z axis\r\n        eye.subtractToRef(target, zAxis);\r\n        zAxis.normalize();\r\n        // X axis\r\n        Vector3.CrossToRef(up, zAxis, xAxis);\r\n        const xSquareLength = xAxis.lengthSquared();\r\n        if (xSquareLength === 0) {\r\n            xAxis.x = 1.0;\r\n        }\r\n        else {\r\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\r\n        }\r\n        // Y axis\r\n        Vector3.CrossToRef(zAxis, xAxis, yAxis);\r\n        yAxis.normalize();\r\n        // Eye angles\r\n        var ex = -Vector3.Dot(xAxis, eye);\r\n        var ey = -Vector3.Dot(yAxis, eye);\r\n        var ez = -Vector3.Dot(zAxis, eye);\r\n        Matrix.FromValuesToRef(xAxis.x, yAxis.x, zAxis.x, 0.0, xAxis.y, yAxis.y, zAxis.y, 0.0, xAxis.z, yAxis.z, zAxis.z, 0.0, ex, ey, ez, 1.0, result);\r\n    }\r\n    /**\r\n     * Create a left-handed orthographic projection matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed orthographic projection matrix\r\n     */\r\n    static OrthoLH(width, height, znear, zfar) {\r\n        var matrix = new Matrix();\r\n        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Store a left-handed orthographic projection to a given matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     */\r\n    static OrthoLHToRef(width, height, znear, zfar, result) {\r\n        let n = znear;\r\n        let f = zfar;\r\n        let a = 2.0 / width;\r\n        let b = 2.0 / height;\r\n        let c = 2.0 / (f - n);\r\n        let d = -(f + n) / (f - n);\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\r\n        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\r\n    }\r\n    /**\r\n     * Create a left-handed orthographic projection matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed orthographic projection matrix\r\n     */\r\n    static OrthoOffCenterLH(left, right, bottom, top, znear, zfar) {\r\n        var matrix = new Matrix();\r\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Stores a left-handed orthographic projection into a given matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     */\r\n    static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result) {\r\n        let n = znear;\r\n        let f = zfar;\r\n        let a = 2.0 / (right - left);\r\n        let b = 2.0 / (top - bottom);\r\n        let c = 2.0 / (f - n);\r\n        let d = -(f + n) / (f - n);\r\n        let i0 = (left + right) / (left - right);\r\n        let i1 = (top + bottom) / (bottom - top);\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Creates a right-handed orthographic projection matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a right-handed orthographic projection matrix\r\n     */\r\n    static OrthoOffCenterRH(left, right, bottom, top, znear, zfar) {\r\n        var matrix = new Matrix();\r\n        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Stores a right-handed orthographic projection into a given matrix\r\n     * @param left defines the viewport left coordinate\r\n     * @param right defines the viewport right coordinate\r\n     * @param bottom defines the viewport bottom coordinate\r\n     * @param top defines the viewport top coordinate\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     */\r\n    static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result) {\r\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);\r\n        result._m[10] *= -1; // No need to call _markAsUpdated as previous function already called it and let _isIdentityDirty to true\r\n    }\r\n    /**\r\n     * Creates a left-handed perspective projection matrix\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed perspective projection matrix\r\n     */\r\n    static PerspectiveLH(width, height, znear, zfar) {\r\n        var matrix = new Matrix();\r\n        let n = znear;\r\n        let f = zfar;\r\n        let a = 2.0 * n / width;\r\n        let b = 2.0 * n / height;\r\n        let c = (f + n) / (f - n);\r\n        let d = -2.0 * f * n / (f - n);\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\r\n        matrix._updateIdentityStatus(false);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Creates a left-handed perspective projection matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a left-handed perspective projection matrix\r\n     */\r\n    static PerspectiveFovLH(fov, aspect, znear, zfar) {\r\n        var matrix = new Matrix();\r\n        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Stores a left-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     */\r\n    static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true) {\r\n        let n = znear;\r\n        let f = zfar;\r\n        let t = 1.0 / (Math.tan(fov * 0.5));\r\n        let a = isVerticalFovFixed ? (t / aspect) : t;\r\n        let b = isVerticalFovFixed ? t : (t * aspect);\r\n        let c = (f + n) / (f - n);\r\n        let d = -2.0 * f * n / (f - n);\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\r\n        result._updateIdentityStatus(false);\r\n    }\r\n    /**\r\n     * Creates a right-handed perspective projection matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @returns a new matrix as a right-handed perspective projection matrix\r\n     */\r\n    static PerspectiveFovRH(fov, aspect, znear, zfar) {\r\n        var matrix = new Matrix();\r\n        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Stores a right-handed perspective projection into a given matrix\r\n     * @param fov defines the horizontal field of view\r\n     * @param aspect defines the aspect ratio\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally\r\n     */\r\n    static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true) {\r\n        //alternatively this could be expressed as:\r\n        //    m = PerspectiveFovLHToRef\r\n        //    m[10] *= -1.0;\r\n        //    m[11] *= -1.0;\r\n        let n = znear;\r\n        let f = zfar;\r\n        let t = 1.0 / (Math.tan(fov * 0.5));\r\n        let a = isVerticalFovFixed ? (t / aspect) : t;\r\n        let b = isVerticalFovFixed ? t : (t * aspect);\r\n        let c = -(f + n) / (f - n);\r\n        let d = -2 * f * n / (f - n);\r\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\r\n        result._updateIdentityStatus(false);\r\n    }\r\n    /**\r\n     * Stores a perspective projection for WebVR info a given matrix\r\n     * @param fov defines the field of view\r\n     * @param znear defines the near clip plane\r\n     * @param zfar defines the far clip plane\r\n     * @param result defines the target matrix\r\n     * @param rightHanded defines if the matrix must be in right-handed mode (false by default)\r\n     */\r\n    static PerspectiveFovWebVRToRef(fov, znear, zfar, result, rightHanded = false) {\r\n        var rightHandedFactor = rightHanded ? -1 : 1;\r\n        var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\r\n        var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\r\n        var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\r\n        var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\r\n        var xScale = 2.0 / (leftTan + rightTan);\r\n        var yScale = 2.0 / (upTan + downTan);\r\n        const m = result._m;\r\n        m[0] = xScale;\r\n        m[1] = m[2] = m[3] = m[4] = 0.0;\r\n        m[5] = yScale;\r\n        m[6] = m[7] = 0.0;\r\n        m[8] = ((leftTan - rightTan) * xScale * 0.5);\r\n        m[9] = -((upTan - downTan) * yScale * 0.5);\r\n        m[10] = -zfar / (znear - zfar);\r\n        m[11] = 1.0 * rightHandedFactor;\r\n        m[12] = m[13] = m[15] = 0.0;\r\n        m[14] = -(2.0 * zfar * znear) / (zfar - znear);\r\n        result._markAsUpdated();\r\n    }\r\n    /**\r\n     * Computes a complete transformation matrix\r\n     * @param viewport defines the viewport to use\r\n     * @param world defines the world matrix\r\n     * @param view defines the view matrix\r\n     * @param projection defines the projection matrix\r\n     * @param zmin defines the near clip plane\r\n     * @param zmax defines the far clip plane\r\n     * @returns the transformation matrix\r\n     */\r\n    static GetFinalMatrix(viewport, world, view, projection, zmin, zmax) {\r\n        var cw = viewport.width;\r\n        var ch = viewport.height;\r\n        var cx = viewport.x;\r\n        var cy = viewport.y;\r\n        var viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1.0);\r\n        var matrix = MathTmp.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        return matrix.multiply(viewportMatrix);\r\n    }\r\n    /**\r\n     * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array\r\n     * @param matrix defines the matrix to use\r\n     * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix\r\n     */\r\n    static GetAsMatrix2x2(matrix) {\r\n        const m = matrix.m;\r\n        return new Float32Array([m[0], m[1], m[4], m[5]]);\r\n    }\r\n    /**\r\n     * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array\r\n     * @param matrix defines the matrix to use\r\n     * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix\r\n     */\r\n    static GetAsMatrix3x3(matrix) {\r\n        const m = matrix.m;\r\n        return new Float32Array([\r\n            m[0], m[1], m[2],\r\n            m[4], m[5], m[6],\r\n            m[8], m[9], m[10]\r\n        ]);\r\n    }\r\n    /**\r\n     * Compute the transpose of a given matrix\r\n     * @param matrix defines the matrix to transpose\r\n     * @returns the new matrix\r\n     */\r\n    static Transpose(matrix) {\r\n        var result = new Matrix();\r\n        Matrix.TransposeToRef(matrix, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * Compute the transpose of a matrix and store it in a target matrix\r\n     * @param matrix defines the matrix to transpose\r\n     * @param result defines the target matrix\r\n     */\r\n    static TransposeToRef(matrix, result) {\r\n        const rm = result._m;\r\n        const mm = matrix.m;\r\n        rm[0] = mm[0];\r\n        rm[1] = mm[4];\r\n        rm[2] = mm[8];\r\n        rm[3] = mm[12];\r\n        rm[4] = mm[1];\r\n        rm[5] = mm[5];\r\n        rm[6] = mm[9];\r\n        rm[7] = mm[13];\r\n        rm[8] = mm[2];\r\n        rm[9] = mm[6];\r\n        rm[10] = mm[10];\r\n        rm[11] = mm[14];\r\n        rm[12] = mm[3];\r\n        rm[13] = mm[7];\r\n        rm[14] = mm[11];\r\n        rm[15] = mm[15];\r\n        // identity-ness does not change when transposing\r\n        result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\r\n    }\r\n    /**\r\n     * Computes a reflection matrix from a plane\r\n     * @param plane defines the reflection plane\r\n     * @returns a new matrix\r\n     */\r\n    static Reflection(plane) {\r\n        var matrix = new Matrix();\r\n        Matrix.ReflectionToRef(plane, matrix);\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a reflection matrix from a plane\r\n     * @param plane defines the reflection plane\r\n     * @param result defines the target matrix\r\n     */\r\n    static ReflectionToRef(plane, result) {\r\n        plane.normalize();\r\n        var x = plane.normal.x;\r\n        var y = plane.normal.y;\r\n        var z = plane.normal.z;\r\n        var temp = -2 * x;\r\n        var temp2 = -2 * y;\r\n        var temp3 = -2 * z;\r\n        Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\r\n    }\r\n    /**\r\n     * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\r\n     * @param xaxis defines the value of the 1st axis\r\n     * @param yaxis defines the value of the 2nd axis\r\n     * @param zaxis defines the value of the 3rd axis\r\n     * @param result defines the target matrix\r\n     */\r\n    static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {\r\n        Matrix.FromValuesToRef(xaxis.x, xaxis.y, xaxis.z, 0.0, yaxis.x, yaxis.y, yaxis.z, 0.0, zaxis.x, zaxis.y, zaxis.z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\r\n    }\r\n    /**\r\n     * Creates a rotation matrix from a quaternion and stores it in a target matrix\r\n     * @param quat defines the quaternion to use\r\n     * @param result defines the target matrix\r\n     */\r\n    static FromQuaternionToRef(quat, result) {\r\n        var xx = quat.x * quat.x;\r\n        var yy = quat.y * quat.y;\r\n        var zz = quat.z * quat.z;\r\n        var xy = quat.x * quat.y;\r\n        var zw = quat.z * quat.w;\r\n        var zx = quat.z * quat.x;\r\n        var yw = quat.y * quat.w;\r\n        var yz = quat.y * quat.z;\r\n        var xw = quat.x * quat.w;\r\n        result._m[0] = 1.0 - (2.0 * (yy + zz));\r\n        result._m[1] = 2.0 * (xy + zw);\r\n        result._m[2] = 2.0 * (zx - yw);\r\n        result._m[3] = 0.0;\r\n        result._m[4] = 2.0 * (xy - zw);\r\n        result._m[5] = 1.0 - (2.0 * (zz + xx));\r\n        result._m[6] = 2.0 * (yz + xw);\r\n        result._m[7] = 0.0;\r\n        result._m[8] = 2.0 * (zx + yw);\r\n        result._m[9] = 2.0 * (yz - xw);\r\n        result._m[10] = 1.0 - (2.0 * (yy + xx));\r\n        result._m[11] = 0.0;\r\n        result._m[12] = 0.0;\r\n        result._m[13] = 0.0;\r\n        result._m[14] = 0.0;\r\n        result._m[15] = 1.0;\r\n        result._markAsUpdated();\r\n    }\r\n}\r\nMatrix._updateFlagSeed = 0;\r\nMatrix._identityReadOnly = Matrix.Identity();\r\n/**\r\n * Represens a plane by the equation ax + by + cz + d = 0\r\n */\r\nclass Plane {\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a, b, c, d) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    asArray() {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    clone() {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    getClassName() {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    getHashCode() {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d || 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    normalize() {\r\n        var norm = (Math.sqrt((this.normal.x * this.normal.x) + (this.normal.y * this.normal.y) + (this.normal.z * this.normal.z)));\r\n        var magnitude = 0.0;\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    transform(transformation) {\r\n        const transposedMatrix = MathTmp.Matrix[0];\r\n        Matrix.TransposeToRef(transformation, transposedMatrix);\r\n        const m = transposedMatrix.m;\r\n        var x = this.normal.x;\r\n        var y = this.normal.y;\r\n        var z = this.normal.z;\r\n        var d = this.d;\r\n        var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n    /**\r\n     * Calcualtte the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    dotCoordinate(point) {\r\n        return ((((this.normal.x * point.x) + (this.normal.y * point.y)) + (this.normal.z * point.z)) + this.d);\r\n    }\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to contruct the plane\r\n     * @param point2 one of the points used to contruct the plane\r\n     * @param point3 one of the points used to contruct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    copyFromPoints(point1, point2, point3) {\r\n        var x1 = point2.x - point1.x;\r\n        var y1 = point2.y - point1.y;\r\n        var z1 = point2.z - point1.z;\r\n        var x2 = point3.x - point1.x;\r\n        var y2 = point3.y - point1.y;\r\n        var z2 = point3.z - point1.z;\r\n        var yz = (y1 * z2) - (z1 * y2);\r\n        var xz = (z1 * x2) - (x1 * z2);\r\n        var xy = (x1 * y2) - (y1 * x2);\r\n        var pyth = (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\r\n        var invPyth;\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        }\r\n        else {\r\n            invPyth = 0.0;\r\n        }\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -((this.normal.x * point1.x) + (this.normal.y * point1.y) + (this.normal.z * point1.z));\r\n        return this;\r\n    }\r\n    /**\r\n     * Checks if the plane is facing a given direction\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True is the vector \"direction\"  is the same side than the plane normal.\r\n     */\r\n    isFrontFacingTo(direction, epsilon) {\r\n        var dot = Vector3.Dot(this.normal, direction);\r\n        return (dot <= epsilon);\r\n    }\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    signedDistanceTo(point) {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array) {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1, point2, point3) {\r\n        var result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     * Note : the vector \"normal\" is updated because normalized.\r\n     */\r\n    static FromPositionAndNormal(origin, normal) {\r\n        var result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        normal.normalize();\r\n        result.normal = normal;\r\n        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return result;\r\n    }\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\r\n        var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n/**\r\n * Class used to represent a viewport on screen\r\n */\r\nclass Viewport {\r\n    /**\r\n     * Creates a Viewport object located at (x, y) and sized (width, height)\r\n     * @param x defines viewport left coordinate\r\n     * @param y defines viewport top coordinate\r\n     * @param width defines the viewport width\r\n     * @param height defines the viewport height\r\n     */\r\n    constructor(\r\n    /** viewport left coordinate */\r\n    x, \r\n    /** viewport top coordinate */\r\n    y, \r\n    /**viewport width */\r\n    width, \r\n    /** viewport height */\r\n    height) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    /**\r\n     * Creates a new viewport using absolute sizing (from 0-> width, 0-> height instead of 0->1)\r\n     * @param renderWidth defines the rendering width\r\n     * @param renderHeight defines the rendering height\r\n     * @returns a new Viewport\r\n     */\r\n    toGlobal(renderWidth, renderHeight) {\r\n        return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);\r\n    }\r\n    /**\r\n     * Stores absolute viewport value into a target viewport (from 0-> width, 0-> height instead of 0->1)\r\n     * @param renderWidth defines the rendering width\r\n     * @param renderHeight defines the rendering height\r\n     * @param ref defines the target viewport\r\n     * @returns the current viewport\r\n     */\r\n    toGlobalToRef(renderWidth, renderHeight, ref) {\r\n        ref.x = this.x * renderWidth;\r\n        ref.y = this.y * renderHeight;\r\n        ref.width = this.width * renderWidth;\r\n        ref.height = this.height * renderHeight;\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a new Viewport copied from the current one\r\n     * @returns a new Viewport\r\n     */\r\n    clone() {\r\n        return new Viewport(this.x, this.y, this.width, this.height);\r\n    }\r\n}\r\n/**\r\n * Reprasents a camera frustum\r\n */\r\nclass Frustum {\r\n    /**\r\n     * Gets the planes representing the frustum\r\n     * @param transform matrix to be applied to the returned planes\r\n     * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\r\n     */\r\n    static GetPlanes(transform) {\r\n        var frustumPlanes = [];\r\n        for (var index = 0; index < 6; index++) {\r\n            frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\r\n        }\r\n        Frustum.GetPlanesToRef(transform, frustumPlanes);\r\n        return frustumPlanes;\r\n    }\r\n    /**\r\n     * Gets the near frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resuling frustum plane\r\n     */\r\n    static GetNearPlaneToRef(transform, frustumPlane) {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[2];\r\n        frustumPlane.normal.y = m[7] + m[6];\r\n        frustumPlane.normal.z = m[11] + m[10];\r\n        frustumPlane.d = m[15] + m[14];\r\n        frustumPlane.normalize();\r\n    }\r\n    /**\r\n     * Gets the far frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resuling frustum plane\r\n     */\r\n    static GetFarPlaneToRef(transform, frustumPlane) {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[2];\r\n        frustumPlane.normal.y = m[7] - m[6];\r\n        frustumPlane.normal.z = m[11] - m[10];\r\n        frustumPlane.d = m[15] - m[14];\r\n        frustumPlane.normalize();\r\n    }\r\n    /**\r\n     * Gets the left frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resuling frustum plane\r\n     */\r\n    static GetLeftPlaneToRef(transform, frustumPlane) {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[0];\r\n        frustumPlane.normal.y = m[7] + m[4];\r\n        frustumPlane.normal.z = m[11] + m[8];\r\n        frustumPlane.d = m[15] + m[12];\r\n        frustumPlane.normalize();\r\n    }\r\n    /**\r\n     * Gets the right frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resuling frustum plane\r\n     */\r\n    static GetRightPlaneToRef(transform, frustumPlane) {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[0];\r\n        frustumPlane.normal.y = m[7] - m[4];\r\n        frustumPlane.normal.z = m[11] - m[8];\r\n        frustumPlane.d = m[15] - m[12];\r\n        frustumPlane.normalize();\r\n    }\r\n    /**\r\n     * Gets the top frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resuling frustum plane\r\n     */\r\n    static GetTopPlaneToRef(transform, frustumPlane) {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] - m[1];\r\n        frustumPlane.normal.y = m[7] - m[5];\r\n        frustumPlane.normal.z = m[11] - m[9];\r\n        frustumPlane.d = m[15] - m[13];\r\n        frustumPlane.normalize();\r\n    }\r\n    /**\r\n     * Gets the bottom frustum plane transformed by the transform matrix\r\n     * @param transform transformation matrix to be applied to the resulting frustum plane\r\n     * @param frustumPlane the resuling frustum plane\r\n     */\r\n    static GetBottomPlaneToRef(transform, frustumPlane) {\r\n        const m = transform.m;\r\n        frustumPlane.normal.x = m[3] + m[1];\r\n        frustumPlane.normal.y = m[7] + m[5];\r\n        frustumPlane.normal.z = m[11] + m[9];\r\n        frustumPlane.d = m[15] + m[13];\r\n        frustumPlane.normalize();\r\n    }\r\n    /**\r\n     * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\r\n     * @param transform transformation matrix to be applied to the resulting frustum planes\r\n     * @param frustumPlanes the resuling frustum planes\r\n     */\r\n    static GetPlanesToRef(transform, frustumPlanes) {\r\n        // Near\r\n        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\r\n        // Far\r\n        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\r\n        // Left\r\n        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\r\n        // Right\r\n        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\r\n        // Top\r\n        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\r\n        // Bottom\r\n        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\r\n    }\r\n}\r\n/** Defines supported spaces */\r\nvar Space;\r\n(function (Space) {\r\n    /** Local (object) space */\r\n    Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\r\n    /** World space */\r\n    Space[Space[\"WORLD\"] = 1] = \"WORLD\";\r\n    /** Bone space */\r\n    Space[Space[\"BONE\"] = 2] = \"BONE\";\r\n})(Space || (Space = {}));\r\n/** Defines the 3 main axes */\r\nclass Axis {\r\n}\r\n/** X axis */\r\nAxis.X = new Vector3(1.0, 0.0, 0.0);\r\n/** Y axis */\r\nAxis.Y = new Vector3(0.0, 1.0, 0.0);\r\n/** Z axis */\r\nAxis.Z = new Vector3(0.0, 0.0, 1.0);\r\n/** Class used to represent a Bezier curve */\r\nclass BezierCurve {\r\n    /**\r\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\r\n     * @param t defines the time\r\n     * @param x1 defines the left coordinate on X axis\r\n     * @param y1 defines the left coordinate on Y axis\r\n     * @param x2 defines the right coordinate on X axis\r\n     * @param y2 defines the right coordinate on Y axis\r\n     * @returns the interpolated value\r\n     */\r\n    static Interpolate(t, x1, y1, x2, y2) {\r\n        // Extract X (which is equal to time here)\r\n        var f0 = 1 - 3 * x2 + 3 * x1;\r\n        var f1 = 3 * x2 - 6 * x1;\r\n        var f2 = 3 * x1;\r\n        var refinedT = t;\r\n        for (var i = 0; i < 5; i++) {\r\n            var refinedT2 = refinedT * refinedT;\r\n            var refinedT3 = refinedT2 * refinedT;\r\n            var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\r\n            var slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\r\n            refinedT -= (x - t) * slope;\r\n            refinedT = Math.min(1, Math.max(0, refinedT));\r\n        }\r\n        // Resolve cubic bezier for the given x\r\n        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 +\r\n            3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 +\r\n            Math.pow(refinedT, 3);\r\n    }\r\n}\r\n/**\r\n * Defines potential orientation for back face culling\r\n */\r\nvar Orientation;\r\n(function (Orientation) {\r\n    /**\r\n     * Clockwise\r\n     */\r\n    Orientation[Orientation[\"CW\"] = 0] = \"CW\";\r\n    /** Counter clockwise */\r\n    Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\r\n})(Orientation || (Orientation = {}));\r\n/**\r\n * Defines angle representation\r\n */\r\nclass Angle {\r\n    /**\r\n     * Creates an Angle object of \"radians\" radians (float).\r\n     * @param radians the angle in radians\r\n     */\r\n    constructor(radians) {\r\n        this._radians = radians;\r\n        if (this._radians < 0.0) {\r\n            this._radians += (2.0 * Math.PI);\r\n        }\r\n    }\r\n    /**\r\n     * Get value in degrees\r\n     * @returns the Angle value in degrees (float)\r\n     */\r\n    degrees() {\r\n        return this._radians * 180.0 / Math.PI;\r\n    }\r\n    /**\r\n     * Get value in radians\r\n     * @returns the Angle value in radians (float)\r\n     */\r\n    radians() {\r\n        return this._radians;\r\n    }\r\n    /**\r\n     * Gets a new Angle object valued with the angle value in radians between the two given vectors\r\n     * @param a defines first vector\r\n     * @param b defines second vector\r\n     * @returns a new Angle\r\n     */\r\n    static BetweenTwoPoints(a, b) {\r\n        var delta = b.subtract(a);\r\n        var theta = Math.atan2(delta.y, delta.x);\r\n        return new Angle(theta);\r\n    }\r\n    /**\r\n     * Gets a new Angle object from the given float in radians\r\n     * @param radians defines the angle value in radians\r\n     * @returns a new Angle\r\n     */\r\n    static FromRadians(radians) {\r\n        return new Angle(radians);\r\n    }\r\n    /**\r\n     * Gets a new Angle object from the given float in degrees\r\n     * @param degrees defines the angle value in degrees\r\n     * @returns a new Angle\r\n     */\r\n    static FromDegrees(degrees) {\r\n        return new Angle(degrees * Math.PI / 180.0);\r\n    }\r\n}\r\n/**\r\n * This represents an arc in a 2d space.\r\n */\r\nclass Arc2 {\r\n    /**\r\n     * Creates an Arc object from the three given points : start, middle and end.\r\n     * @param startPoint Defines the start point of the arc\r\n     * @param midPoint Defines the midlle point of the arc\r\n     * @param endPoint Defines the end point of the arc\r\n     */\r\n    constructor(\r\n    /** Defines the start point of the arc */\r\n    startPoint, \r\n    /** Defines the mid point of the arc */\r\n    midPoint, \r\n    /** Defines the end point of the arc */\r\n    endPoint) {\r\n        this.startPoint = startPoint;\r\n        this.midPoint = midPoint;\r\n        this.endPoint = endPoint;\r\n        var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\r\n        var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2.;\r\n        var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2.;\r\n        var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\r\n        this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\r\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\r\n        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\r\n        var a1 = this.startAngle.degrees();\r\n        var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\r\n        var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\r\n        // angles correction\r\n        if (a2 - a1 > +180.0) {\r\n            a2 -= 360.0;\r\n        }\r\n        if (a2 - a1 < -180.0) {\r\n            a2 += 360.0;\r\n        }\r\n        if (a3 - a2 > +180.0) {\r\n            a3 -= 360.0;\r\n        }\r\n        if (a3 - a2 < -180.0) {\r\n            a3 += 360.0;\r\n        }\r\n        this.orientation = (a2 - a1) < 0 ? Orientation.CW : Orientation.CCW;\r\n        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\r\n    }\r\n}\r\n/**\r\n * Represents a 2D path made up of multiple 2D points\r\n */\r\nclass Path2 {\r\n    /**\r\n     * Creates a Path2 object from the starting 2D coordinates x and y.\r\n     * @param x the starting points x value\r\n     * @param y the starting points y value\r\n     */\r\n    constructor(x, y) {\r\n        this._points = new Array();\r\n        this._length = 0.0;\r\n        /**\r\n         * If the path start and end point are the same\r\n         */\r\n        this.closed = false;\r\n        this._points.push(new Vector2(x, y));\r\n    }\r\n    /**\r\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\r\n     * @param x the added points x value\r\n     * @param y the added points y value\r\n     * @returns the updated Path2.\r\n     */\r\n    addLineTo(x, y) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        var newPoint = new Vector2(x, y);\r\n        var previousPoint = this._points[this._points.length - 1];\r\n        this._points.push(newPoint);\r\n        this._length += newPoint.subtract(previousPoint).length();\r\n        return this;\r\n    }\r\n    /**\r\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\r\n     * @param midX middle point x value\r\n     * @param midY middle point y value\r\n     * @param endX end point x value\r\n     * @param endY end point y value\r\n     * @param numberOfSegments (default: 36)\r\n     * @returns the updated Path2.\r\n     */\r\n    addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {\r\n        if (this.closed) {\r\n            return this;\r\n        }\r\n        var startPoint = this._points[this._points.length - 1];\r\n        var midPoint = new Vector2(midX, midY);\r\n        var endPoint = new Vector2(endX, endY);\r\n        var arc = new Arc2(startPoint, midPoint, endPoint);\r\n        var increment = arc.angle.radians() / numberOfSegments;\r\n        if (arc.orientation === Orientation.CW) {\r\n            increment *= -1;\r\n        }\r\n        var currentAngle = arc.startAngle.radians() + increment;\r\n        for (var i = 0; i < numberOfSegments; i++) {\r\n            var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\r\n            var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\r\n            this.addLineTo(x, y);\r\n            currentAngle += increment;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Closes the Path2.\r\n     * @returns the Path2.\r\n     */\r\n    close() {\r\n        this.closed = true;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the sum of the distance between each sequential point in the path\r\n     * @returns the Path2 total length (float).\r\n     */\r\n    length() {\r\n        var result = this._length;\r\n        if (!this.closed) {\r\n            var lastPoint = this._points[this._points.length - 1];\r\n            var firstPoint = this._points[0];\r\n            result += (firstPoint.subtract(lastPoint).length());\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Gets the points which construct the path\r\n     * @returns the Path2 internal array of points.\r\n     */\r\n    getPoints() {\r\n        return this._points;\r\n    }\r\n    /**\r\n     * Retreives the point at the distance aways from the starting point\r\n     * @param normalizedLengthPosition the length along the path to retreive the point from\r\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\r\n     */\r\n    getPointAtLengthPosition(normalizedLengthPosition) {\r\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\r\n            return Vector2.Zero();\r\n        }\r\n        var lengthPosition = normalizedLengthPosition * this.length();\r\n        var previousOffset = 0;\r\n        for (var i = 0; i < this._points.length; i++) {\r\n            var j = (i + 1) % this._points.length;\r\n            var a = this._points[i];\r\n            var b = this._points[j];\r\n            var bToA = b.subtract(a);\r\n            var nextOffset = (bToA.length() + previousOffset);\r\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\r\n                var dir = bToA.normalize();\r\n                var localOffset = lengthPosition - previousOffset;\r\n                return new Vector2(a.x + (dir.x * localOffset), a.y + (dir.y * localOffset));\r\n            }\r\n            previousOffset = nextOffset;\r\n        }\r\n        return Vector2.Zero();\r\n    }\r\n    /**\r\n     * Creates a new path starting from an x and y position\r\n     * @param x starting x value\r\n     * @param y starting y value\r\n     * @returns a new Path2 starting at the coordinates (x, y).\r\n     */\r\n    static StartingAt(x, y) {\r\n        return new Path2(x, y);\r\n    }\r\n}\r\n/**\r\n * Represents a 3D path made up of multiple 3D points\r\n */\r\nclass Path3D {\r\n    /**\r\n    * new Path3D(path, normal, raw)\r\n    * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\r\n    * please read the description in the tutorial : https://doc.babylonjs.com/how_to/how_to_use_path3d\r\n    * @param path an array of Vector3, the curve axis of the Path3D\r\n    * @param firstNormal (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\r\n    * @param raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\r\n    */\r\n    constructor(\r\n    /**\r\n     * an array of Vector3, the curve axis of the Path3D\r\n     */\r\n    path, firstNormal = null, raw) {\r\n        this.path = path;\r\n        this._curve = new Array();\r\n        this._distances = new Array();\r\n        this._tangents = new Array();\r\n        this._normals = new Array();\r\n        this._binormals = new Array();\r\n        for (var p = 0; p < path.length; p++) {\r\n            this._curve[p] = path[p].clone(); // hard copy\r\n        }\r\n        this._raw = raw || false;\r\n        this._compute(firstNormal);\r\n    }\r\n    /**\r\n     * Returns the Path3D array of successive Vector3 designing its curve.\r\n     * @returns the Path3D array of successive Vector3 designing its curve.\r\n     */\r\n    getCurve() {\r\n        return this._curve;\r\n    }\r\n    /**\r\n     * Returns an array populated with tangent vectors on each Path3D curve point.\r\n     * @returns an array populated with tangent vectors on each Path3D curve point.\r\n     */\r\n    getTangents() {\r\n        return this._tangents;\r\n    }\r\n    /**\r\n     * Returns an array populated with normal vectors on each Path3D curve point.\r\n     * @returns an array populated with normal vectors on each Path3D curve point.\r\n     */\r\n    getNormals() {\r\n        return this._normals;\r\n    }\r\n    /**\r\n     * Returns an array populated with binormal vectors on each Path3D curve point.\r\n     * @returns an array populated with binormal vectors on each Path3D curve point.\r\n     */\r\n    getBinormals() {\r\n        return this._binormals;\r\n    }\r\n    /**\r\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\r\n     */\r\n    getDistances() {\r\n        return this._distances;\r\n    }\r\n    /**\r\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\r\n     * @param path path which all values are copied into the curves points\r\n     * @param firstNormal which should be projected onto the curve\r\n     * @returns the same object updated.\r\n     */\r\n    update(path, firstNormal = null) {\r\n        for (var p = 0; p < path.length; p++) {\r\n            this._curve[p].x = path[p].x;\r\n            this._curve[p].y = path[p].y;\r\n            this._curve[p].z = path[p].z;\r\n        }\r\n        this._compute(firstNormal);\r\n        return this;\r\n    }\r\n    // private function compute() : computes tangents, normals and binormals\r\n    _compute(firstNormal) {\r\n        var l = this._curve.length;\r\n        // first and last tangents\r\n        this._tangents[0] = this._getFirstNonNullVector(0);\r\n        if (!this._raw) {\r\n            this._tangents[0].normalize();\r\n        }\r\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\r\n        if (!this._raw) {\r\n            this._tangents[l - 1].normalize();\r\n        }\r\n        // normals and binormals at first point : arbitrary vector with _normalVector()\r\n        var tg0 = this._tangents[0];\r\n        var pp0 = this._normalVector(tg0, firstNormal);\r\n        this._normals[0] = pp0;\r\n        if (!this._raw) {\r\n            this._normals[0].normalize();\r\n        }\r\n        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\r\n        if (!this._raw) {\r\n            this._binormals[0].normalize();\r\n        }\r\n        this._distances[0] = 0.0;\r\n        // normals and binormals : next points\r\n        var prev; // previous vector (segment)\r\n        var cur; // current vector (segment)\r\n        var curTang; // current tangent\r\n        // previous normal\r\n        var prevBinor; // previous binormal\r\n        for (var i = 1; i < l; i++) {\r\n            // tangents\r\n            prev = this._getLastNonNullVector(i);\r\n            if (i < l - 1) {\r\n                cur = this._getFirstNonNullVector(i);\r\n                this._tangents[i] = prev.add(cur);\r\n                this._tangents[i].normalize();\r\n            }\r\n            this._distances[i] = this._distances[i - 1] + prev.length();\r\n            // normals and binormals\r\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\r\n            curTang = this._tangents[i];\r\n            prevBinor = this._binormals[i - 1];\r\n            this._normals[i] = Vector3.Cross(prevBinor, curTang);\r\n            if (!this._raw) {\r\n                this._normals[i].normalize();\r\n            }\r\n            this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\r\n            if (!this._raw) {\r\n                this._binormals[i].normalize();\r\n            }\r\n        }\r\n    }\r\n    // private function getFirstNonNullVector(index)\r\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\r\n    _getFirstNonNullVector(index) {\r\n        var i = 1;\r\n        var nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\r\n            i++;\r\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\r\n        }\r\n        return nNVector;\r\n    }\r\n    // private function getLastNonNullVector(index)\r\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\r\n    _getLastNonNullVector(index) {\r\n        var i = 1;\r\n        var nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        while (nLVector.length() === 0 && index > i + 1) {\r\n            i++;\r\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\r\n        }\r\n        return nLVector;\r\n    }\r\n    // private function normalVector(v0, vt, va) :\r\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\r\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\r\n    _normalVector(vt, va) {\r\n        var normal0;\r\n        var tgl = vt.length();\r\n        if (tgl === 0.0) {\r\n            tgl = 1.0;\r\n        }\r\n        if (va === undefined || va === null) {\r\n            var point;\r\n            if (!_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, Epsilon)) { // search for a point in the plane\r\n                point = new Vector3(0.0, -1.0, 0.0);\r\n            }\r\n            else if (!_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(1.0, 0.0, 0.0);\r\n            }\r\n            else if (!_math_scalar__WEBPACK_IMPORTED_MODULE_1__[\"Scalar\"].WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, Epsilon)) {\r\n                point = new Vector3(0.0, 0.0, 1.0);\r\n            }\r\n            else {\r\n                point = Vector3.Zero();\r\n            }\r\n            normal0 = Vector3.Cross(vt, point);\r\n        }\r\n        else {\r\n            normal0 = Vector3.Cross(vt, va);\r\n            Vector3.CrossToRef(normal0, vt, normal0);\r\n        }\r\n        normal0.normalize();\r\n        return normal0;\r\n    }\r\n}\r\n/**\r\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n * A Curve3 is designed from a series of successive Vector3.\r\n * @see https://doc.babylonjs.com/how_to/how_to_use_curve3\r\n */\r\nclass Curve3 {\r\n    /**\r\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\r\n     * A Curve3 is designed from a series of successive Vector3.\r\n     * Tuto : https://doc.babylonjs.com/how_to/how_to_use_curve3#curve3-object\r\n     * @param points points which make up the curve\r\n     */\r\n    constructor(points) {\r\n        this._length = 0.0;\r\n        this._points = points;\r\n        this._length = this._computeLength(points);\r\n    }\r\n    /**\r\n     * Returns a Curve3 object along a Quadratic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#quadratic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Quadratic Bezier\r\n     * @param v1 (Vector3) the control point\r\n     * @param v2 (Vector3) the end point of the Quadratic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    static CreateQuadraticBezier(v0, v1, v2, nbPoints) {\r\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\r\n        var bez = new Array();\r\n        var equation = (t, val0, val1, val2) => {\r\n            var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\r\n            return res;\r\n        };\r\n        for (var i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n    /**\r\n     * Returns a Curve3 object along a Cubic Bezier curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#cubic-bezier-curve\r\n     * @param v0 (Vector3) the origin point of the Cubic Bezier\r\n     * @param v1 (Vector3) the first control point\r\n     * @param v2 (Vector3) the second control point\r\n     * @param v3 (Vector3) the end point of the Cubic Bezier\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {\r\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\r\n        var bez = new Array();\r\n        var equation = (t, val0, val1, val2, val3) => {\r\n            var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\r\n            return res;\r\n        };\r\n        for (var i = 0; i <= nbPoints; i++) {\r\n            bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\r\n        }\r\n        return new Curve3(bez);\r\n    }\r\n    /**\r\n     * Returns a Curve3 object along a Hermite Spline curve : https://doc.babylonjs.com/how_to/how_to_use_curve3#hermite-spline\r\n     * @param p1 (Vector3) the origin point of the Hermite Spline\r\n     * @param t1 (Vector3) the tangent vector at the origin point\r\n     * @param p2 (Vector3) the end point of the Hermite Spline\r\n     * @param t2 (Vector3) the tangent vector at the end point\r\n     * @param nbPoints (integer) the wanted number of points in the curve\r\n     * @returns the created Curve3\r\n     */\r\n    static CreateHermiteSpline(p1, t1, p2, t2, nbPoints) {\r\n        var hermite = new Array();\r\n        var step = 1.0 / nbPoints;\r\n        for (var i = 0; i <= nbPoints; i++) {\r\n            hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\r\n        }\r\n        return new Curve3(hermite);\r\n    }\r\n    /**\r\n     * Returns a Curve3 object along a CatmullRom Spline curve :\r\n     * @param points (array of Vector3) the points the spline must pass through. At least, four points required\r\n     * @param nbPoints (integer) the wanted number of points between each curve control points\r\n     * @param closed (boolean) optional with default false, when true forms a closed loop from the points\r\n     * @returns the created Curve3\r\n     */\r\n    static CreateCatmullRomSpline(points, nbPoints, closed) {\r\n        var catmullRom = new Array();\r\n        var step = 1.0 / nbPoints;\r\n        var amount = 0.0;\r\n        if (closed) {\r\n            var pointsCount = points.length;\r\n            for (var i = 0; i < pointsCount; i++) {\r\n                amount = 0;\r\n                for (var c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            catmullRom.push(catmullRom[0]);\r\n        }\r\n        else {\r\n            var totalPoints = new Array();\r\n            totalPoints.push(points[0].clone());\r\n            Array.prototype.push.apply(totalPoints, points);\r\n            totalPoints.push(points[points.length - 1].clone());\r\n            for (var i = 0; i < totalPoints.length - 3; i++) {\r\n                amount = 0;\r\n                for (var c = 0; c < nbPoints; c++) {\r\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n                    amount += step;\r\n                }\r\n            }\r\n            i--;\r\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\r\n        }\r\n        return new Curve3(catmullRom);\r\n    }\r\n    /**\r\n     * @returns the Curve3 stored array of successive Vector3\r\n     */\r\n    getPoints() {\r\n        return this._points;\r\n    }\r\n    /**\r\n     * @returns the computed length (float) of the curve.\r\n     */\r\n    length() {\r\n        return this._length;\r\n    }\r\n    /**\r\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\r\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\r\n     * curveA and curveB keep unchanged.\r\n     * @param curve the curve to continue from this curve\r\n     * @returns the newly constructed curve\r\n     */\r\n    continue(curve) {\r\n        var lastPoint = this._points[this._points.length - 1];\r\n        var continuedPoints = this._points.slice();\r\n        var curvePoints = curve.getPoints();\r\n        for (var i = 1; i < curvePoints.length; i++) {\r\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\r\n        }\r\n        var continuedCurve = new Curve3(continuedPoints);\r\n        return continuedCurve;\r\n    }\r\n    _computeLength(path) {\r\n        var l = 0;\r\n        for (var i = 1; i < path.length; i++) {\r\n            l += (path[i].subtract(path[i - 1])).length();\r\n        }\r\n        return l;\r\n    }\r\n}\r\n// Vertex formats\r\n/**\r\n * Contains position and normal vectors for a vertex\r\n */\r\nclass PositionNormalVertex {\r\n    /**\r\n     * Creates a PositionNormalVertex\r\n     * @param position the position of the vertex (defaut: 0,0,0)\r\n     * @param normal the normal of the vertex (defaut: 0,1,0)\r\n     */\r\n    constructor(\r\n    /** the position of the vertex (defaut: 0,0,0) */\r\n    position = Vector3.Zero(), \r\n    /** the normal of the vertex (defaut: 0,1,0) */\r\n    normal = Vector3.Up()) {\r\n        this.position = position;\r\n        this.normal = normal;\r\n    }\r\n    /**\r\n     * Clones the PositionNormalVertex\r\n     * @returns the cloned PositionNormalVertex\r\n     */\r\n    clone() {\r\n        return new PositionNormalVertex(this.position.clone(), this.normal.clone());\r\n    }\r\n}\r\n/**\r\n * Contains position, normal and uv vectors for a vertex\r\n */\r\nclass PositionNormalTextureVertex {\r\n    /**\r\n     * Creates a PositionNormalTextureVertex\r\n     * @param position the position of the vertex (defaut: 0,0,0)\r\n     * @param normal the normal of the vertex (defaut: 0,1,0)\r\n     * @param uv the uv of the vertex (default: 0,0)\r\n     */\r\n    constructor(\r\n    /** the position of the vertex (defaut: 0,0,0) */\r\n    position = Vector3.Zero(), \r\n    /** the normal of the vertex (defaut: 0,1,0) */\r\n    normal = Vector3.Up(), \r\n    /** the uv of the vertex (default: 0,0) */\r\n    uv = Vector2.Zero()) {\r\n        this.position = position;\r\n        this.normal = normal;\r\n        this.uv = uv;\r\n    }\r\n    /**\r\n     * Clones the PositionNormalTextureVertex\r\n     * @returns the cloned PositionNormalTextureVertex\r\n     */\r\n    clone() {\r\n        return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());\r\n    }\r\n}\r\n// Temporary pre-allocated objects for engine internal use\r\n// usage in any internal function :\r\n// var tmp = Tmp.Vector3[0];   <= gets access to the first pre-created Vector3\r\n// There's a Tmp array per object type : int, float, Vector2, Vector3, Vector4, Quaternion, Matrix\r\n/**\r\n * @hidden\r\n */\r\nclass Tmp {\r\n}\r\nTmp.Color3 = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(3, Color3.Black);\r\nTmp.Color4 = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(3, () => new Color4(0, 0, 0, 0));\r\nTmp.Vector2 = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(3, Vector2.Zero); // 3 temp Vector2 at once should be enough\r\nTmp.Vector3 = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(13, Vector3.Zero); // 13 temp Vector3 at once should be enough\r\nTmp.Vector4 = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(3, Vector4.Zero); // 3 temp Vector4 at once should be enough\r\nTmp.Quaternion = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(2, Quaternion.Zero); // 2 temp Quaternion at once should be enough\r\nTmp.Matrix = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(8, Matrix.Identity); // 8 temp Matrices at once should be enough\r\n/**\r\n * @hidden\r\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\r\n */\r\nclass MathTmp {\r\n}\r\nMathTmp.Vector3 = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(6, Vector3.Zero);\r\nMathTmp.Matrix = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(2, Matrix.Identity);\r\nMathTmp.Quaternion = _Misc_arrayTools__WEBPACK_IMPORTED_MODULE_0__[\"ArrayTools\"].BuildArray(3, Quaternion.Zero);\r\n\n\n//# sourceURL=webpack:///./src/babylon_math/Maths/math.ts?");

/***/ }),

/***/ "./src/babylon_math/Misc/arrayTools.ts":
/*!*********************************************!*\
  !*** ./src/babylon_math/Misc/arrayTools.ts ***!
  \*********************************************/
/*! exports provided: ArrayTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayTools\", function() { return ArrayTools; });\n/**\r\n * Class containing a set of static utilities functions for arrays.\r\n */\r\nclass ArrayTools {\r\n    /**\r\n     * Returns an array of the given size filled with element built from the given constructor and the paramters\r\n     * @param size the number of element to construct and put in the array\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\r\n     * @returns a new array filled with new objects\r\n     */\r\n    static BuildArray(size, itemBuilder) {\r\n        const a = [];\r\n        for (let i = 0; i < size; ++i) {\r\n            a.push(itemBuilder());\r\n        }\r\n        return a;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/babylon_math/Misc/arrayTools.ts?");

/***/ }),

/***/ "./src/math/geometry.ts":
/*!******************************!*\
  !*** ./src/math/geometry.ts ***!
  \******************************/
/*! exports provided: GeometryTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeometryTools\", function() { return GeometryTools; });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math/math.ts\");\n\r\nclass GeometryTools {\r\n    static polygon(edgeCount, asCenterMode) {\r\n        const vertexs = [];\r\n        const faces = [];\r\n        const radius = 1;\r\n        let vertexCount = edgeCount;\r\n        if (edgeCount >= 3) {\r\n            const perRadian = 3.14 * 2 / edgeCount;\r\n            if (asCenterMode) {\r\n                vertexCount++;\r\n                vertexs.push([0, 0]);\r\n            }\r\n            for (let i = 0; i < edgeCount; i++) {\r\n                const pos = [Math.cos(perRadian * i) * radius, Math.sin(perRadian * i) * radius];\r\n                vertexs.push(pos);\r\n            }\r\n            if (asCenterMode) {\r\n                for (let i = 3; i <= vertexCount; i++) {\r\n                    faces.push([0, i - 2, i - 1]);\r\n                }\r\n                faces.push([0, vertexCount - 1, 1]);\r\n            }\r\n            else {\r\n                for (let i = 3; i <= vertexCount; i++) {\r\n                    faces.push([0, i - 2, i - 1]);\r\n                }\r\n            }\r\n        }\r\n        return { vertexs, faces };\r\n    }\r\n    static sphere(detailH, detailV) {\r\n        const half = this.sphereHalf(detailH, detailV, (x) => {\r\n            const cos = Math.cos(Math.PI * x * 2);\r\n            return cos; // Math.abs(4 * x - 2) - 1; //(1 * (cos / Math.abs(cos)) - cos); // * (cos / Math.abs(cos));\r\n        }, (x) => {\r\n            // const sin = Math.abs(Math.cos(x) * Math.sin(x * 2)) * 0.9 + 0.2; // Math.sin(Math.PI * x * 8);\r\n            // return sin; // (1 * (sin / Math.abs(sin)) - sin); // * (sin / Math.abs(sin));\r\n            return Math.sin(Math.PI * x * 2);\r\n        }, (x) => { return Math.cos(Math.PI * x / 2); }, (x) => {\r\n            return Math.sin(Math.PI * x / 2);\r\n            // return (Math.pow((x * 2 - 1), 3) + 1) / 2;\r\n        }, true);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return Math.cos(Math.PI * x / 2); }, (x) => { return Math.sin(Math.PI * x / 2); }, \r\n        // (x: number) => {\r\n        //     return (Math.pow((x * 2 - 1), 3) + 1) / 2;\r\n        // },\r\n        true);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 棱锥体\r\n     * @param detailH 底面多边形边数目\r\n     */\r\n    static pyramid(detailH) {\r\n        const detailV = 1;\r\n        const half = this.sphereHalf(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return Math.cos(Math.PI * x / 2); }, (x) => { return Math.sin(Math.PI * x / 2); }, true);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return 0; }, false);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 柱体\r\n     * @param detailH 底面多边形边数目\r\n     */\r\n    static column(detailH) {\r\n        const detailV = 1;\r\n        const half = this.sphereHalf(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return x; }, false);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return 0; }, false);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 反棱柱\r\n     * @param detailH 底面多边形边数目\r\n     */\r\n    static antiPrism(detailH) {\r\n        const detailV = 1;\r\n        const half = this.sphereHalf(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return x; }, false);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return 0; }, false);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const deltaRadian = Math.PI / detailH;\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push([_math__WEBPACK_IMPORTED_MODULE_0__[\"MathTools\"].cos_a_add_b(point[1], point[0], deltaRadian), _math__WEBPACK_IMPORTED_MODULE_0__[\"MathTools\"].sin_a_add_b(point[1], point[0], deltaRadian), point[2]]);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 丝带\r\n     * @param detailCount 细节点数目\r\n     */\r\n    static ribbon(detailCount) {\r\n        const one_dimensional_points = [];\r\n        const one_dimensional_weights = [];\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const xFunction = (x) => {\r\n            return x * Math.cos(Math.PI * x * 2) * 0.8;\r\n        };\r\n        const wFunction = (x) => {\r\n            return x < 0.3 ? (Math.sin(Math.PI * (x / 0.3) / 2)) : x > 0.8 ? (Math.cos(Math.PI * ((x - 0.8) / 0.2) / 2)) : 1.0;\r\n        };\r\n        for (let i = 0; i < detailCount; i++) {\r\n            const x = i / detailCount;\r\n            const y = xFunction(x);\r\n            const w = wFunction(x) * 0.2;\r\n            one_dimensional_points.push(y);\r\n            one_dimensional_weights.push(w);\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i] = [(x - 0.5) * 2, y - w, 0];\r\n                result.vertexs3D[i + detailCount] = [(x - 0.5) * 2, y + w, 0];\r\n            }\r\n            result.faces = this.sphereRibbon(0, detailCount);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 丝带\r\n     * @param detailCount 细节点数目\r\n     */\r\n    static ribbon_from_line(points) {\r\n        const detailCount = points.length;\r\n        if (detailCount < 2) {\r\n            return;\r\n        }\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        for (let i = 1; i < detailCount; i++) {\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i] = [points[i][0], points[i][1] - 0.02, 0];\r\n                result.vertexs3D[i + detailCount] = [points[i][0], points[i][1] + 0.02, 0];\r\n            }\r\n        }\r\n        result.faces = this.sphereRibbon(0, detailCount);\r\n        return result;\r\n    }\r\n    /**\r\n     * 丝带\r\n     * @param detailCount 细节点数目\r\n     */\r\n    static ribbon2(detailCount, delta = 0) {\r\n        const one_dimensional_points = [];\r\n        const one_dimensional_weights = [];\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const xFunction = (x) => {\r\n            x = x - Math.floor(x);\r\n            return Math.cos(Math.PI * x * 2) * 0.8;\r\n        };\r\n        const wFunction = (x) => {\r\n            x = x - Math.floor(x);\r\n            return x < 0.3 ? (Math.sin(Math.PI * (x / 0.3) / 2)) : x > 0.8 ? (Math.cos(Math.PI * ((x - 0.8) / 0.2) / 2)) : 1.0;\r\n        };\r\n        const linePoints = [];\r\n        for (let i = 0; i < detailCount; i++) {\r\n            const x = i / detailCount;\r\n            const y = xFunction(x + delta);\r\n            const w = wFunction(x + delta) * 0.2;\r\n            // one_dimensional_points.push(y);\r\n            // one_dimensional_weights.push(w);\r\n            linePoints.push([(x - 0.5) * 2, y]);\r\n            // if (result.vertexs3D) {\r\n            //     result.vertexs3D[i] = [(x - 0.5) * 2, y - w, 0];\r\n            //     result.vertexs3D[i + detailCount] = [(x - 0.5) * 2, y + w, 0];\r\n            // }\r\n            // result.faces = this.sphereRibbon(0, detailCount);\r\n        }\r\n        return this.ribbon_from_line2(linePoints, 10, wFunction);\r\n    }\r\n    static ribbon_from_line2(points, deltaAngle, deltaAngleFunction, weightFunction, widthScaleHeight = 1) {\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const detailCount = points.length;\r\n        if (detailCount < 2) {\r\n            return;\r\n        }\r\n        let cos = 0, sin = 0, deltaCos = 0, deltaSin = 0, deltaXY = 0, deltaX = 0, deltaY = 0, prePoint = [points[0][0], points[0][1]], nxtPoint = [points[0][0], points[0][1]];\r\n        let currDeltaAngle;\r\n        let deltaDistance = 0;\r\n        let lastTempPoint = [points[0][0], points[0][1]];\r\n        for (let i = 1; i < detailCount; i++) {\r\n            nxtPoint = points[i];\r\n            deltaX = nxtPoint[0] - prePoint[0];\r\n            deltaY = nxtPoint[1] - prePoint[1];\r\n            deltaXY = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n            cos = deltaXY === 0 ? 0 : deltaX / deltaXY;\r\n            sin = deltaXY === 0 ? 0 : deltaY / deltaXY;\r\n            currDeltaAngle = deltaAngleFunction ? deltaAngle * deltaAngleFunction((i - 1) / detailCount) : deltaAngle;\r\n            deltaCos = Math.cos(Math.PI * currDeltaAngle / 180);\r\n            deltaSin = Math.sin(Math.PI * currDeltaAngle / 180);\r\n            deltaDistance = weightFunction ? weightFunction(i / detailCount) : 0.01;\r\n            // if (deltaXY > deltaDistance) {\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i - 1] = [\r\n                    (cos * deltaCos - sin * deltaSin) * deltaDistance / widthScaleHeight + prePoint[0],\r\n                    (sin * deltaCos + cos * deltaSin) * deltaDistance + prePoint[1],\r\n                    0\r\n                ];\r\n                result.vertexs3D[i - 1 + detailCount] = [\r\n                    (cos * deltaCos + sin * deltaSin) * deltaDistance / widthScaleHeight + prePoint[0],\r\n                    (sin * deltaCos - cos * deltaSin) * deltaDistance + prePoint[1],\r\n                    0\r\n                ];\r\n            }\r\n            lastTempPoint = prePoint;\r\n            // } else {\r\n            //     if (result.vertexs3D) {\r\n            //         result.vertexs3D[i - 1] = [\r\n            //             (cos * deltaCos - sin * deltaSin) * deltaDistance + lastTempPoint[0],\r\n            //             (sin * deltaCos + cos * deltaSin) * deltaDistance + lastTempPoint[1],\r\n            //             0\r\n            //         ];\r\n            //         result.vertexs3D[i - 1 + detailCount] = [\r\n            //             (cos * deltaCos + sin * deltaSin) * deltaDistance + lastTempPoint[0],\r\n            //             (sin * deltaCos - cos * deltaSin) * deltaDistance + lastTempPoint[1],\r\n            //             0\r\n            //         ];\r\n            //     }\r\n            // }\r\n            prePoint = points[i];\r\n        }\r\n        deltaCos = Math.cos(Math.PI * 45 / 180);\r\n        deltaSin = Math.sin(Math.PI * 45 / 180);\r\n        if (result.vertexs3D) {\r\n            result.vertexs3D[detailCount - 1] = [\r\n                (cos * deltaCos - sin * deltaSin) * deltaXY / widthScaleHeight + prePoint[0],\r\n                (sin * deltaSin + cos * deltaCos) * deltaXY + prePoint[1],\r\n                0\r\n            ];\r\n            result.vertexs3D[detailCount - 1 + detailCount] = [\r\n                (cos * deltaCos + sin * deltaSin) * deltaXY / widthScaleHeight + prePoint[0],\r\n                (sin * deltaSin - cos * deltaCos) * deltaXY + prePoint[1],\r\n                0\r\n            ];\r\n        }\r\n        result.faces = this.sphereRibbon(0, detailCount);\r\n        return result;\r\n    }\r\n    static sphereHalfRevert(detailH, detailV, xFunction, yFunction, detailHFucntion, detailVFucntion, topIsProtruding = true) {\r\n        const { circleList, facesList } = this.sphereHalf(detailH, detailV, xFunction, yFunction, detailHFucntion, detailVFucntion, topIsProtruding);\r\n        circleList.forEach((circle) => {\r\n            circle.reverse();\r\n            circle.forEach((point) => {\r\n                point[2] *= -1;\r\n            });\r\n            // const total = circle.length;\r\n            // const count = circle.length / 2;\r\n            // for (let i = 0; i < count; i++) {\r\n            //     const temp = circle[i];\r\n            //     circle[i]           = circle[total - i];\r\n            //     circle[total - i]   = temp;\r\n            // }\r\n        });\r\n        return { circleList, facesList };\r\n    }\r\n    static sphereHalf(detailH, detailV, xFunction, yFunction, detailHFucntion, detailVFucntion, topIsProtruding = true) {\r\n        const baseCirclePoints = this.circlePoints(detailH, xFunction, yFunction);\r\n        const circleList = [];\r\n        const facesList = [];\r\n        let circlePointCount = 0;\r\n        const vcount = topIsProtruding ? detailV : detailV + 1;\r\n        for (let i = 0; i < vcount; i++) {\r\n            const vDistance = detailVFucntion(i / detailV);\r\n            const radius = detailHFucntion(i / detailV); // Math.sqrt(1 - (i * i) / (detailV * detailV));\r\n            // const vDistance = Math.sin(Math.PI * i / detailV / 2);\r\n            // const radius    = Math.cos(Math.PI * i / detailV / 2);\r\n            const tempList = this.circlePointsScale(this.copyCirclePoints(baseCirclePoints), radius);\r\n            circlePointCount = tempList.length;\r\n            if (i > 0) {\r\n                facesList.push(this.sphereRing(circlePointCount * (i - 1), circlePointCount));\r\n            }\r\n            circleList.push(this.circleFillZ(tempList, vDistance));\r\n        }\r\n        facesList.push(this.sphereTop(circlePointCount * (circleList.length - 1), circlePointCount));\r\n        circleList.push([[0, 0, detailVFucntion(1)]]);\r\n        return {\r\n            circleList,\r\n            facesList\r\n        };\r\n    }\r\n    static sphereRing(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + i + 1 + pointCount\r\n            ], [\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1 + pointCount,\r\n                pointStartIndex + i + pointCount\r\n            ]);\r\n        }\r\n        const i = pointCount - 1;\r\n        faces.push([\r\n            pointStartIndex + i,\r\n            pointStartIndex + 0,\r\n            pointStartIndex + 0 + pointCount\r\n        ], [\r\n            pointStartIndex + i,\r\n            pointStartIndex + 0 + pointCount,\r\n            pointStartIndex + i + pointCount\r\n        ]);\r\n        return faces;\r\n    }\r\n    static sphereRibbon(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + i + 1 + pointCount\r\n            ], [\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1 + pointCount,\r\n                pointStartIndex + i + pointCount\r\n            ]);\r\n        }\r\n        return faces;\r\n    }\r\n    static sphereTop(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + pointCount\r\n            ]);\r\n        }\r\n        faces.push([\r\n            pointStartIndex + pointCount - 1,\r\n            pointStartIndex + 0,\r\n            pointStartIndex + pointCount\r\n        ]);\r\n        return faces;\r\n    }\r\n    static circleFillZ(circle, z) {\r\n        const result = [];\r\n        circle.forEach((point) => {\r\n            result.push([point[0], point[1], z]);\r\n        });\r\n        return result;\r\n    }\r\n    static circlePoints(detail, xFunction, yFunction) {\r\n        const points = [];\r\n        for (let i = 0; i < detail; i++) {\r\n            points.push([xFunction(i / detail), yFunction(i / detail)]);\r\n        }\r\n        return points;\r\n    }\r\n    static circlePointsDym(detail, radius, xFunction, yFunction) {\r\n        const points = this.circlePoints(detail, xFunction, yFunction);\r\n        return this.circlePointsScale(points, radius);\r\n    }\r\n    static circlePointsScale(points, radius) {\r\n        points.forEach((point) => {\r\n            point[0] *= radius;\r\n            point[1] *= radius;\r\n        });\r\n        return points;\r\n    }\r\n    static copyCirclePoints(points) {\r\n        const result = [];\r\n        points.forEach((point) => {\r\n            result.push([point[0], point[1]]);\r\n        });\r\n        return result;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/geometry.ts?");

/***/ }),

/***/ "./src/math/math.ts":
/*!**************************!*\
  !*** ./src/math/math.ts ***!
  \**************************/
/*! exports provided: MathTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MathTools\", function() { return MathTools; });\n/**\r\n * 数学函数库\r\n */\r\nclass MathTools {\r\n    static sin(x) {\r\n        return Math.sin(x);\r\n    }\r\n    static cos(x) {\r\n        return Math.cos(x);\r\n    }\r\n    static isPrimeNumber(n) {\r\n        if (n < 2) {\r\n            return false;\r\n        }\r\n        for (let i = 2; i <= n - 1; i++) {\r\n            if (n % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @description 下一个2的冥的数\r\n     */\r\n    static nextPowerOfTwo(value) {\r\n        --value;\r\n        value |= value >> 1;\r\n        value |= value >> 2;\r\n        value |= value >> 4;\r\n        value |= value >> 8;\r\n        value |= value >> 16;\r\n        return ++value;\r\n    }\r\n    /**\r\n     * sin(a+b) = sin(a) * cos(b) + cos(a) * sin(b)\r\n     * @param sin_a\r\n     * @param cos_a\r\n     * @param b\r\n     */\r\n    static sin_a_add_b(sin_a, cos_a, b) {\r\n        return sin_a * Math.cos(b) + cos_a * Math.sin(b);\r\n    }\r\n    /**\r\n     * cos(a+b) = cos(a) * cos(b) - sin(a) * sin(b)\r\n     * @param sin_a\r\n     * @param cos_a\r\n     * @param b\r\n     */\r\n    static cos_a_add_b(sin_a, cos_a, b) {\r\n        return cos_a * Math.cos(b) - sin_a * Math.sin(b);\r\n    }\r\n}\r\nMathTools.polarCoordToCartesian = (num) => {\r\n    return {\r\n        x: Math.cos(num) * num,\r\n        y: Math.sin(num) * num\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack:///./src/math/math.ts?");

/***/ }),

/***/ "./src/native/lib/shader_simple.ts":
/*!*****************************************!*\
  !*** ./src/native/lib/shader_simple.ts ***!
  \*****************************************/
/*! exports provided: vs_simple, fs_simple */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vs_simple\", function() { return vs_simple; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fs_simple\", function() { return fs_simple; });\nconst vs_simple = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\nattribute   vec3    a_position;\r\nattribute   vec4    a_color;\r\nattribute   vec2    a_uv;\r\n\r\nvarying     vec3    v_surfacePosition;\r\nvarying     vec4    v_color;\r\nvarying     vec2    v_UV;\r\n\r\nuniform     vec3    u_translate;\r\nuniform     vec3    u_scale;\r\nuniform     vec3    u_rotate;\r\nuniform     mat4    u_ViewMatrix;\r\n\r\nvoid main( void ){\r\n    vec2 pos        = a_position.xy;\r\n    pos += vec2(0.5);\r\n    pos *= u_scale.xy;\r\n    pos -= vec2(0.5);\r\n\r\n    pos += u_translate.xy;\r\n\r\n    vec4 pos4 = vec4( pos, 0., 1. );\r\n\r\n    // Adjust the z to divide by\r\n    float zToDivideBy = 1.0 + pos4.z * 2.0;\r\n\r\n    gl_Position         = u_ViewMatrix * vec4(pos4.xy / zToDivideBy, pos4.zw);\r\n\r\n    gl_PointSize        = 2.0;\r\n    v_surfacePosition   = a_position;\r\n    v_color             = a_color;\r\n    v_UV                = a_uv;\r\n}\r\n`;\r\nconst fs_simple = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform  sampler2D u_sampler;\r\n\r\nvarying  vec3   v_surfacePosition;\r\nvarying  vec4   v_color;\r\nvarying  vec2   v_UV;\r\n\r\nvoid main(void){\r\n    gl_FragColor = v_color;\r\n}\r\n`;\r\n\n\n//# sourceURL=webpack:///./src/native/lib/shader_simple.ts?");

/***/ }),

/***/ "./src/native/lib/webgl.ts":
/*!*********************************!*\
  !*** ./src/native/lib/webgl.ts ***!
  \*********************************/
/*! exports provided: Camera, ShaderCfg, DataBufferCfg, Mesh, Scene, TextureInstance, WebGLInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderCfg\", function() { return ShaderCfg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataBufferCfg\", function() { return DataBufferCfg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureInstance\", function() { return TextureInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLInstance\", function() { return WebGLInstance; });\n/* harmony import */ var _babylon_math_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../babylon_math/Maths/math */ \"./src/babylon_math/Maths/math.ts\");\n\r\nclass Camera {\r\n    constructor() {\r\n        this.position = new _babylon_math_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0);\r\n        this.target = new _babylon_math_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, -1);\r\n        this.up = new _babylon_math_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0);\r\n        this._matrix = new _babylon_math_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"]();\r\n    }\r\n    getMatrix() {\r\n        _babylon_math_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].LookAtLHToRef(this.position, this.target, this.up, this._matrix);\r\n        return this._matrix;\r\n    }\r\n}\r\nCamera.Default = new Camera();\r\nclass ShaderCfg {\r\n    constructor(sname, vs, fs) {\r\n        this.texActive = false;\r\n        this.sname = sname;\r\n        this.fs = fs;\r\n        this.vs = vs;\r\n    }\r\n    getPrograme(gl) {\r\n        const shader_fragment = this.getFSShader(gl);\r\n        const shader_vertex = this.getVSShader(gl);\r\n        if (this.shader_program === undefined && gl.getShaderParameter(shader_fragment, gl.COMPILE_STATUS)) {\r\n            const shader_program = gl.createProgram();\r\n            this.shader_program = shader_program;\r\n            gl.attachShader(this.shader_program, shader_vertex);\r\n            gl.attachShader(this.shader_program, shader_fragment);\r\n            gl.linkProgram(this.shader_program);\r\n        }\r\n        gl.useProgram(this.shader_program);\r\n        this.u_view_matrix_loc = gl.getUniformLocation(this.shader_program, `u_ViewMatrix`);\r\n        this.u_mouse_loc = gl.getUniformLocation(this.shader_program, `u_mouse`);\r\n        this.u_time_loc = gl.getUniformLocation(this.shader_program, `u_time`);\r\n        this.u_resolution_loc = gl.getUniformLocation(this.shader_program, `u_resolution`);\r\n        this.u_translate_loc = gl.getUniformLocation(this.shader_program, `u_translate`);\r\n        this.u_scale_loc = gl.getUniformLocation(this.shader_program, `u_scale`);\r\n        this.u_rotate_loc = gl.getUniformLocation(this.shader_program, `u_rotate`);\r\n        this.u_float_loc = gl.getUniformLocation(this.shader_program, `u_float`);\r\n        this.a_position_loc = gl.getAttribLocation(this.shader_program, 'a_position');\r\n        this.a_color_loc = gl.getAttribLocation(this.shader_program, 'a_color');\r\n        this.a_uv = gl.getAttribLocation(this.shader_program, 'a_uv');\r\n        this.u_texture = gl.getUniformLocation(this.shader_program, 'u_sampler');\r\n        this.u_texture1 = gl.getUniformLocation(this.shader_program, 'u_sampler1');\r\n        if (this.a_position_loc >= 0) {\r\n            gl.enableVertexAttribArray(this.a_position_loc);\r\n        }\r\n        if (this.a_color_loc >= 0) {\r\n            gl.enableVertexAttribArray(this.a_color_loc);\r\n        }\r\n        if (this.a_uv >= 0) {\r\n            gl.enableVertexAttribArray(this.a_uv);\r\n        }\r\n        if (this.texActive) {\r\n            this.u_texture && gl.uniform1i(this.u_texture, 0);\r\n            this.u_texture1 && gl.uniform1i(this.u_texture1, 1);\r\n        }\r\n    }\r\n    getVSShader(gl) {\r\n        if (gl === null) {\r\n            return this.vshader;\r\n        }\r\n        if (this.vshader) {\r\n            return this.vshader;\r\n        }\r\n        this.vshader = gl.createShader(gl.VERTEX_SHADER);\r\n        if (this.vshader === null) {\r\n            return this.vshader;\r\n        }\r\n        if (this.vs === undefined) {\r\n            return this.vshader;\r\n        }\r\n        gl.shaderSource(this.vshader, this.vs);\r\n        gl.compileShader(this.vshader);\r\n        if (!gl.getShaderParameter(this.vshader, gl.COMPILE_STATUS)) {\r\n            console.error(`ERROR IN 'VERTEX_SHADER' SHADER: ${gl.getShaderInfoLog(this.vshader)}`);\r\n            return this.vshader;\r\n        }\r\n        return this.vshader;\r\n    }\r\n    getFSShader(gl) {\r\n        if (gl === null) {\r\n            return this.fshader;\r\n        }\r\n        if (this.fshader) {\r\n            return this.fshader;\r\n        }\r\n        this.fshader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        if (this.fshader === null) {\r\n            return this.fshader;\r\n        }\r\n        if (this.fs === undefined) {\r\n            return this.fshader;\r\n        }\r\n        gl.shaderSource(this.fshader, this.fs);\r\n        gl.compileShader(this.fshader);\r\n        if (!gl.getShaderParameter(this.fshader, gl.COMPILE_STATUS)) {\r\n            console.error(`ERROR IN 'FRAGMENT_SHADER' SHADER: ${gl.getShaderInfoLog(this.fshader)}`);\r\n            return this.fshader;\r\n        }\r\n        return this.fshader;\r\n    }\r\n}\r\nclass DataBufferCfg {\r\n    constructor(vname) {\r\n        /**\r\n         * 一组 FLOAT 数据的大小\r\n         */\r\n        this.FLOAT_SIZE = 0;\r\n        /**\r\n         * 一组 INT 数据的大小\r\n         * * 没有这个处理必要 - INT 数据为 绘制的ELEMENT\r\n         * * 所有线数据 - 所有面数据 - 所有点数据 没有混合保存\r\n         */\r\n        this.INT_SIZE = 0;\r\n        /**\r\n         * 一个点的 坐标数据 数据量\r\n         */\r\n        this.VERTEX_SIZE = 3;\r\n        /**\r\n         * 一个点的 颜色数据 数据量\r\n         */\r\n        this.COLOR_SIZE = 4;\r\n        /**\r\n         * 一个点的 UV数据 数据量\r\n         */\r\n        this.UV_SIZE = 2;\r\n        /**\r\n         * 一个面的 点数目数据 数据量\r\n         */\r\n        this.FACE_SIZE = 3;\r\n        /**\r\n         * 一个点的 点数目数据 数据量\r\n         */\r\n        this.LINE_SIZE = 2;\r\n        /**\r\n         * 一条线的 点数目数据 数据量\r\n         */\r\n        this.POINT_SIZE = 1;\r\n        this.float_data = [];\r\n        this.int_data = [];\r\n        this.vertex_data = [];\r\n        // public vertex_buffer:           WebGLBuffer | undefined;\r\n        this.vertex_offset = 0;\r\n        this.color_data = [];\r\n        // public color_buffer:            WebGLBuffer | undefined;\r\n        this.color_offset = 0;\r\n        this.face_data = [];\r\n        // public face_buffer:             WebGLBuffer | undefined;\r\n        this.face_offset = 0;\r\n        this.point_data = [];\r\n        // public face_buffer:             WebGLBuffer | undefined;\r\n        this.point_offset = 0;\r\n        this.line_data = [];\r\n        // public line_buffer:             WebGLBuffer | undefined;\r\n        this.line_offset = 0;\r\n        this.uv_data = [];\r\n        // public uv_buffer:               WebGLBuffer | undefined;\r\n        this.uv_offset = 0;\r\n        this.vname = vname;\r\n    }\r\n    addVertex(x, y, z = 0) {\r\n        this.vertex_data.push([x, y, z]);\r\n    }\r\n    addFace(a, b, c) {\r\n        this.face_data.push([a, b, c]);\r\n    }\r\n    addPoint(data) {\r\n        this.point_data.push(data);\r\n    }\r\n    addColor(r, g, b, a) {\r\n        this.color_data.push([r, g, b, a]);\r\n    }\r\n    addUV(u, v) {\r\n        this.uv_data.push([u, v]);\r\n    }\r\n    addVertex2(data) {\r\n        this.vertex_data.push(data);\r\n    }\r\n    addFace2(data) {\r\n        this.face_data.push(data);\r\n    }\r\n    addPoint2(data) {\r\n        this.point_data.push(data);\r\n    }\r\n    addColor2(data) {\r\n        this.color_data.push(data);\r\n    }\r\n    addUV2(data) {\r\n        this.uv_data.push(data);\r\n    }\r\n    clearVertex() {\r\n        this.vertex_data.length = 0;\r\n    }\r\n    clearFace() {\r\n        this.face_data.length = 0;\r\n    }\r\n    clearPoint() {\r\n        this.point_data.length = 0;\r\n    }\r\n    clearColor() {\r\n        this.color_data.length = 0;\r\n    }\r\n    clearUV() {\r\n        this.uv_data.length = 0;\r\n    }\r\n    update(gl) {\r\n        this.activeFloatBuffer(gl);\r\n        this.activeIntBuffer(gl);\r\n    }\r\n    activeFloatBuffer(gl) {\r\n        if (!this.float_buffer) {\r\n            this.float_buffer = gl.createBuffer();\r\n        }\r\n        this.float_data.length = 0;\r\n        const count = this.vertex_data.length;\r\n        let vertex, color, uv;\r\n        for (let i = 0; i < count; i++) {\r\n            vertex = this.vertex_data[i];\r\n            color = this.color_data[i];\r\n            uv = this.uv_data[i];\r\n            vertex && this.float_data.push(...vertex);\r\n            color && this.float_data.push(...color);\r\n            uv && this.float_data.push(...uv);\r\n        }\r\n        let offset = 0;\r\n        if (this.vertex_data.length > 0) {\r\n            this.vertex_offset = offset;\r\n            offset += this.VERTEX_SIZE;\r\n        }\r\n        if (this.color_data.length > 0) {\r\n            this.color_offset = offset;\r\n            offset += this.COLOR_SIZE;\r\n        }\r\n        if (this.uv_data.length > 0) {\r\n            this.uv_offset = offset;\r\n            offset += this.UV_SIZE;\r\n        }\r\n        this.FLOAT_SIZE = offset;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.float_buffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.float_data), gl.STATIC_DRAW);\r\n    }\r\n    activeIntBuffer(gl) {\r\n        if (!this.int_buffer) {\r\n            this.int_buffer = gl.createBuffer();\r\n        }\r\n        this.int_data.length = 0;\r\n        let face, line;\r\n        let faces = [], lines = [];\r\n        this.line_data.length = 0;\r\n        const faceCount = this.face_data.length;\r\n        for (let i = 0; i < faceCount; i++) {\r\n            face = this.face_data[i];\r\n            face && faces.push(...face);\r\n            if (face) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    if (j === 0) {\r\n                        this.line_data.push([face[2], face[0]]);\r\n                    }\r\n                    else {\r\n                        this.line_data.push([face[j - 1], face[j]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const lineCount = this.line_data.length;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            line = this.line_data[i];\r\n            line && lines.push(...line);\r\n        }\r\n        let offset = 0;\r\n        if (faces.length > 0) {\r\n            // this.int_data.push(...faces);\r\n            faces.forEach((face) => {\r\n                this.int_data.push(face);\r\n            });\r\n            this.face_offset = offset;\r\n            offset += faces.length;\r\n        }\r\n        if (lines.length > 0) {\r\n            // this.int_data.push(...lines);\r\n            lines.forEach((line) => {\r\n                this.int_data.push(line);\r\n            });\r\n            this.line_offset = offset;\r\n            offset += lines.length;\r\n        }\r\n        if (this.vertex_data.length > 0) {\r\n            this.vertex_data.forEach((point, index) => {\r\n                this.int_data.push(index);\r\n            });\r\n            this.point_offset = offset;\r\n            offset += this.vertex_data.length;\r\n        }\r\n        this.INT_SIZE = offset;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.int_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.int_data), gl.STATIC_DRAW);\r\n    }\r\n}\r\nclass Mesh {\r\n    constructor(id, geo, material) {\r\n        this.wireFrame = false;\r\n        this.pointFrame = false;\r\n        this.triangleFrame = true;\r\n        this.alphaMode = 0;\r\n        this.translate = [0, 0, 0];\r\n        this.scale = [1, 1, 1];\r\n        this.rotate = [0, 0, 0];\r\n        this.ufloat = 0.0;\r\n        this.id = id;\r\n        this.dataBufferCfg = geo;\r\n        this.shaderCfg = material;\r\n        this.texture = null;\r\n        this.maskTexture = null;\r\n    }\r\n    render(scene) {\r\n        const gl = scene.engine.gl;\r\n        const shader = this.shaderCfg;\r\n        if (this.texture) {\r\n            this.shaderCfg.texActive = this.texture.active();\r\n            if (this.maskTexture) {\r\n                this.shaderCfg.texActive = this.maskTexture.active();\r\n            }\r\n            if (!this.shaderCfg.texActive) {\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            gl.bindTexture(gl.TEXTURE_2D, null);\r\n        }\r\n        shader.getPrograme(gl);\r\n        const camera = scene.camera || Camera.Default;\r\n        shader.u_view_matrix_loc && gl.uniformMatrix4fv(shader.u_view_matrix_loc, false, camera.getMatrix().m);\r\n        shader.u_mouse_loc && gl.uniform2fv(shader.u_mouse_loc, scene.engine.u_mouse);\r\n        shader.u_time_loc && gl.uniform1f(shader.u_time_loc, scene.engine.timestamp * 0.001);\r\n        shader.u_float_loc && gl.uniform1f(shader.u_float_loc, this.ufloat);\r\n        shader.u_resolution_loc && gl.uniform2f(shader.u_resolution_loc, scene.engine.width, scene.engine.height);\r\n        shader.u_translate_loc && gl.uniform3f(shader.u_translate_loc, this.translate[0], this.translate[1], this.translate[2]);\r\n        shader.u_scale_loc && gl.uniform3f(shader.u_scale_loc, this.scale[0], this.scale[1], this.scale[2]);\r\n        shader.u_rotate_loc && gl.uniform3f(shader.u_rotate_loc, this.rotate[0], this.rotate[1], this.rotate[2]);\r\n        if (shader.a_position_loc >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_position_loc, this.dataBufferCfg.VERTEX_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.vertex_offset * 4);\r\n        }\r\n        if (shader.a_color_loc >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_color_loc, this.dataBufferCfg.COLOR_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.color_offset * 4);\r\n        }\r\n        if (shader.a_uv >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_uv, this.dataBufferCfg.UV_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.uv_offset * 4);\r\n        }\r\n        if (this.dataBufferCfg.int_buffer) {\r\n            if (this.wireFrame) {\r\n                if (this.dataBufferCfg.line_data.length > 0) {\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dataBufferCfg.int_buffer);\r\n                    gl.drawElements(gl.LINES, this.dataBufferCfg.line_data.length * this.dataBufferCfg.LINE_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.line_offset * 2);\r\n                }\r\n            }\r\n            if (this.triangleFrame) {\r\n                if (this.dataBufferCfg.face_data.length > 0) {\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dataBufferCfg.int_buffer);\r\n                    gl.drawElements(gl.TRIANGLES, this.dataBufferCfg.face_data.length * this.dataBufferCfg.FACE_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.face_offset * 2);\r\n                }\r\n            }\r\n            if (this.pointFrame) {\r\n                if (this.dataBufferCfg.vertex_data.length > 0) {\r\n                    gl.drawElements(gl.POINTS, this.dataBufferCfg.vertex_data.length * this.dataBufferCfg.POINT_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.point_offset * 2);\r\n                }\r\n            }\r\n        }\r\n        gl.flush();\r\n    }\r\n}\r\nclass Scene {\r\n    constructor(sname, engine) {\r\n        this.viewport = [0, 0, 0, 0];\r\n        this.meshMap = new Map();\r\n        this.sname = sname;\r\n        this.engine = engine;\r\n    }\r\n    setCamera(cam) {\r\n        this.camera = cam;\r\n    }\r\n    addMesh(mesh) {\r\n        this.meshMap.set(mesh.id, mesh);\r\n    }\r\n    render(isClear) {\r\n        const gl = this.engine.gl;\r\n        gl.viewport(this.viewport[0], this.viewport[1], this.viewport[2], this.viewport[3]);\r\n        if (isClear) {\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n        gl.disable(gl.CULL_FACE); // 不开启背面剔除\r\n        gl.disable(gl.DEPTH_TEST); // 不开启深度测试\r\n        gl.disable(gl.SCISSOR_TEST); // 避免渲染范围被前一个渲染过程限制\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        this.meshMap.forEach((mesh) => {\r\n            mesh.render(this);\r\n        });\r\n    }\r\n}\r\nclass TextureInstance {\r\n    constructor(name, engine, index) {\r\n        this.fname = name;\r\n        this._engine = engine;\r\n        this._tex = null;\r\n        this._index = index || 0;\r\n        engine.addTexture(this);\r\n        TextureInstance.loadCall(name, engine, TextureInstance.loaded);\r\n    }\r\n    active() {\r\n        let result = false;\r\n        const GL = this._engine.gl;\r\n        if (this._tex) {\r\n            if (this._index === 0) {\r\n                GL.activeTexture(GL.TEXTURE0);\r\n            }\r\n            else if (this._index === 1) {\r\n                GL.activeTexture(GL.TEXTURE1);\r\n            }\r\n            GL.bindTexture(GL.TEXTURE_2D, this._tex);\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n    remove() {\r\n        this._engine.delTexture(this);\r\n    }\r\n}\r\nTextureInstance.loadCall = (path, engine, cb) => {\r\n    try {\r\n        // const img = new Image();\r\n        // img.onload = () => {\r\n        //     cb(img, path, engine);\r\n        // };\r\n        // img.src = path;\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n    }\r\n};\r\nTextureInstance.loaded = (img, fname, engine) => {\r\n    const texIns = engine.getTexture(fname);\r\n    if (texIns) {\r\n        const GL = engine.gl;\r\n        const tex = GL.createTexture();\r\n        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);\r\n        GL.bindTexture(GL.TEXTURE_2D, tex);\r\n        GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, img);\r\n        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);\r\n        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n        GL.generateMipmap(GL.TEXTURE_2D);\r\n        GL.bindTexture(GL.TEXTURE_2D, null);\r\n        texIns._tex = tex;\r\n    }\r\n};\r\nclass WebGLInstance {\r\n    constructor(opt) {\r\n        this.u_mouse = [0, 0];\r\n        this.timestamp = 0;\r\n        this.sceneMap = new Map();\r\n        this.textureMap = new Map();\r\n        this._isDestroy = false;\r\n        this.loop = (timestamp) => {\r\n            this.timestamp = timestamp;\r\n            this.renderLoop(timestamp);\r\n            requestAnimationFrame(this.loop);\r\n        };\r\n        this.canvas = opt.canvas;\r\n        this.width = this.canvas.width;\r\n        this.height = this.canvas.height;\r\n        this.gl = WebGLInstance.ctxInitFunc(this.canvas);\r\n    }\r\n    get isDestroy() {\r\n        return this._isDestroy;\r\n    }\r\n    static ctxInitFunc(canvas) {\r\n        let gl = null;\r\n        try {\r\n            for (var ii = 0; ii < WebGLInstance.contentModes.length; ++ii) {\r\n                try {\r\n                    gl = canvas.getContext(WebGLInstance.contentModes[ii], { alpha: true, antialias: true });\r\n                }\r\n                catch (e) {\r\n                    //\r\n                }\r\n                if (gl) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.warn(`There is not webgl compatible :( `);\r\n        }\r\n        return gl;\r\n    }\r\n    createTexture(fname, index) {\r\n        let tex = this.textureMap.get(fname);\r\n        if (tex === undefined) {\r\n            tex = new TextureInstance(fname, this, index);\r\n        }\r\n        return tex;\r\n    }\r\n    addTexture(tex) {\r\n        this.textureMap.set(tex.fname, tex);\r\n    }\r\n    getTexture(fname) {\r\n        return this.textureMap.get(fname);\r\n    }\r\n    delTexture(tex) {\r\n        this.textureMap.delete(tex.fname);\r\n        this.gl.deleteTexture(tex);\r\n    }\r\n    addScene(cfg) {\r\n        this.sceneMap.set(cfg.sname, cfg);\r\n    }\r\n    clearColor() {\r\n        const gl = this.gl;\r\n        gl.viewport(0, 0, this.width, this.height);\r\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    renderLoop(timestamp) { }\r\n    destroy() {\r\n        this._isDestroy = true;\r\n        this.textureMap.forEach((tex) => {\r\n            this.delTexture(tex);\r\n        });\r\n    }\r\n}\r\nWebGLInstance.uniforms_1f = ['u_time'];\r\nWebGLInstance.uniforms_2fv = ['u_mouse'];\r\nWebGLInstance.uniforms_2f = ['u_resolution'];\r\nWebGLInstance.contentModes = [\"webgl\", \"experimental-webgl\", \"webgl2\", \"webkit-3d\", \"moz-webgl\"];\r\n\n\n//# sourceURL=webpack:///./src/native/lib/webgl.ts?");

/***/ }),

/***/ "./src/native/simple/main.ts":
/*!***********************************!*\
  !*** ./src/native/simple/main.ts ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _render_launcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render_launcher */ \"./src/native/simple/render_launcher.ts\");\n/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/geometry */ \"./src/math/geometry.ts\");\n\r\n\r\nconst createButton = (tag, clikCall) => {\r\n    const div = document.createElement('div');\r\n    div.innerHTML = `\r\n        <span style=\"color: black;\">${tag}</span><input id=\"${tag}\" type=\"number\" value=\"edgeCount:\"/>\r\n    `;\r\n    div.style.width = '200px';\r\n    div.style.height = 'auto';\r\n    div.style.backgroundColor = 'green';\r\n    div.addEventListener('pointerdown', (e) => {\r\n        const arg = document.getElementById(tag);\r\n        clikCall && clikCall(arg.value);\r\n    });\r\n    createPanel().appendChild(div);\r\n};\r\nconst createPanel = () => {\r\n    if (!panel) {\r\n        panel = document.createElement('div');\r\n        panel.style.width = '200px';\r\n        panel.style.height = '400px';\r\n        panel.style.overflowY = 'auto';\r\n        panel.style.position = 'absolute';\r\n        document.body.appendChild(panel);\r\n    }\r\n    return panel;\r\n};\r\nlet panel;\r\nconst canvas = document.getElementById('your_canvas');\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\ncanvas.style.transform = 'scale(0.5)';\r\n_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].active(canvas, null);\r\nlet downFlag = true;\r\nlet lastX = 0;\r\nlet lastY = 0;\r\nlet rotateX = 0;\r\ncanvas.addEventListener('pointerdown', (e) => {\r\n    downFlag = true;\r\n});\r\ncanvas.addEventListener('pointermove', (e) => {\r\n    if (downFlag) {\r\n    }\r\n});\r\ncanvas.addEventListener('pointerup', (e) => {\r\n    if (downFlag) {\r\n    }\r\n});\r\nsetInterval(() => {\r\n    if (_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.rotate[0] += 0.02;\r\n    }\r\n}, 16);\r\ncreateButton('polygon', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.scale[0] = 0.5;\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].polygon(edgeCount, true);\r\n        if (sphere) {\r\n            if (sphere.vertexs) {\r\n                sphere.vertexs.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[1]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('pyramid', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].pyramid(edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('antiPrism', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].antiPrism(edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('column', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].column(edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('sphere', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].sphere(edgeCount, edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('ribbon', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        // const sphere = GeometryTools.sphere(100, 100);\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].ribbon2(100, Date.now() % 1000 / 1000);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n                    dataBuffer01.addColor(0.8, 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./src/native/simple/main.ts?");

/***/ }),

/***/ "./src/native/simple/render_launcher.ts":
/*!**********************************************!*\
  !*** ./src/native/simple/render_launcher.ts ***!
  \**********************************************/
/*! exports provided: RenderLauncher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderLauncher\", function() { return RenderLauncher; });\n/* harmony import */ var _lib_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/webgl */ \"./src/native/lib/webgl.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ \"./src/math/math.ts\");\n/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/geometry */ \"./src/math/geometry.ts\");\n/* harmony import */ var _lib_shader_simple__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/shader_simple */ \"./src/native/lib/shader_simple.ts\");\n\r\n\r\n\r\n\r\nclass RenderLauncher {\r\n    static active(canvas, args) {\r\n        RenderLauncher.simple(canvas, args);\r\n        return RenderLauncher.webgldemo;\r\n    }\r\n    static puase() {\r\n    }\r\n    static destroy() {\r\n        if (RenderLauncher.webgldemo && !RenderLauncher.webgldemo.isDestroy) {\r\n            RenderLauncher.webgldemo.destroy();\r\n            RenderLauncher.webgldemo = null;\r\n            if (RenderLauncher.opt.meshProgress) {\r\n                RenderLauncher.opt.meshProgress = undefined;\r\n            }\r\n        }\r\n    }\r\n    static simple(canvas, args) {\r\n        const opt = {};\r\n        opt.canvas = canvas;\r\n        RenderLauncher.webgldemo = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"WebGLInstance\"](opt);\r\n        _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"TextureInstance\"].loadCall = RenderLauncher.createTextureLoad;\r\n        const webgldemo = RenderLauncher.webgldemo;\r\n        if (!RenderLauncher.webgldemo.gl) {\r\n            return;\r\n        }\r\n        const shader01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"ShaderCfg\"]('01', _lib_shader_simple__WEBPACK_IMPORTED_MODULE_3__[\"vs_simple\"], _lib_shader_simple__WEBPACK_IMPORTED_MODULE_3__[\"fs_simple\"]);\r\n        const scene01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]('01', webgldemo);\r\n        const dataBuffer01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"DataBufferCfg\"]('01');\r\n        // const polygon8 = GeometryTools.polygon(8, true);\r\n        // if (polygon8.vertexs) {\r\n        //     polygon8.vertexs.forEach((vertex) => {\r\n        //         dataBuffer01.addVertex(vertex[0], vertex[1], 0);\r\n        //         dataBuffer01.addColor(1, 0, 0, 1);\r\n        //     });\r\n        // }\r\n        // polygon8.faces.forEach((face) => {\r\n        //     dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        // });\r\n        // dataBuffer01.update(<WebGLRenderingContext>webgldemo.gl);\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_2__[\"GeometryTools\"].antiPrism(5);\r\n        if (sphere.vertexs3D) {\r\n            sphere.vertexs3D.forEach((vertex) => {\r\n                dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n                dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n            });\r\n        }\r\n        sphere.faces.forEach((face) => {\r\n            dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        });\r\n        dataBuffer01.update(webgldemo.gl);\r\n        const mesh01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]('mesh01', dataBuffer01, shader01);\r\n        mesh01.translate[0] = 0.0;\r\n        mesh01.translate[1] = 0.0;\r\n        mesh01.scale[0] = 1.0;\r\n        mesh01.scale[1] = 1.0;\r\n        // mesh01.rotate[0] = 1.57;\r\n        mesh01.wireFrame = true;\r\n        mesh01.pointFrame = true;\r\n        // mesh01.triangleFrame = true;\r\n        // mesh01.texture = RenderLauncher.webgldemo.createTexture('/resources/alpha.png');\r\n        scene01.addMesh(mesh01);\r\n        RenderLauncher.mesh = mesh01;\r\n        webgldemo.renderLoop = (timestamp) => {\r\n            webgldemo.clearColor();\r\n            scene01.viewport[0] = 0;\r\n            scene01.viewport[1] = 0;\r\n            scene01.viewport[2] = webgldemo.width;\r\n            scene01.viewport[3] = webgldemo.height;\r\n            scene01.render(true);\r\n        };\r\n        webgldemo.loop(0);\r\n        // setInterval(() => {\r\n        //     dataBuffer01.clearVertex();\r\n        //     dataBuffer01.clearColor();\r\n        //     dataBuffer01.clearFace();\r\n        //     const sphere = GeometryTools.pyramid(5);\r\n        //     if (sphere.vertexs3D) {\r\n        //         sphere.vertexs3D.forEach((vertex) => {\r\n        //             dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n        //             dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n        //         });\r\n        //     }\r\n        //     sphere.faces.forEach((face) => {\r\n        //         dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        //     });\r\n        //     dataBuffer01.update(<WebGLRenderingContext>webgldemo.gl);\r\n        // }, 2000);\r\n        // let delta = 0;\r\n        // setInterval(() => {\r\n        //     dataBuffer01.clearVertex();\r\n        //     dataBuffer01.clearColor();\r\n        //     dataBuffer01.clearFace();\r\n        //     // const sphere = GeometryTools.sphere(100, 100);\r\n        //     const sphere = GeometryTools.ribbon2(100, delta += 0.01);\r\n        //     if (sphere) {\r\n        //         if (sphere.vertexs3D) {\r\n        //             sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n        //                 dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n        //                 dataBuffer01.addColor(0.8, 0, 0, 1);\r\n        //             });\r\n        //         }\r\n        //         sphere.faces.forEach((face) => {\r\n        //             dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        //         });\r\n        //     }\r\n        //     dataBuffer01.update(<WebGLRenderingContext>webgldemo.gl);\r\n        // }, 20);\r\n        return mesh01;\r\n    }\r\n    static updateProgress(num) {\r\n        if (RenderLauncher.opt.meshProgress) {\r\n            RenderLauncher.opt.meshProgress.ufloat = num;\r\n        }\r\n    }\r\n}\r\nRenderLauncher.opt = {};\r\nRenderLauncher.loadImageSucc = (img, fname) => {\r\n    _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"TextureInstance\"].loaded(img, fname, RenderLauncher.webgldemo);\r\n};\r\nRenderLauncher.createTextureLoad = (fname, engine, cb) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n        const width = _math_math__WEBPACK_IMPORTED_MODULE_1__[\"MathTools\"].nextPowerOfTwo(img.width);\r\n        const height = _math_math__WEBPACK_IMPORTED_MODULE_1__[\"MathTools\"].nextPowerOfTwo(img.height);\r\n        if (img.width !== width || img.height !== height) {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            // document.body.appendChild(canvas);\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(img, 0, 0, width, height);\r\n            ctx.save();\r\n            RenderLauncher.loadImageSucc(canvas, fname);\r\n        }\r\n        else {\r\n            RenderLauncher.loadImageSucc(img, fname);\r\n        }\r\n        // setTimeout(() => { loadImageSucc(img, data.fname); }, 2000);\r\n    };\r\n    img.src = fname;\r\n};\r\n\n\n//# sourceURL=webpack:///./src/native/simple/render_launcher.ts?");

/***/ })

/******/ });