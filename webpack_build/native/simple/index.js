/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/native/simple/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/math/geometry.ts":
/*!******************************!*\
  !*** ./src/math/geometry.ts ***!
  \******************************/
/*! exports provided: GeometryTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeometryTools\", function() { return GeometryTools; });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./src/math/math.ts\");\n\r\nclass GeometryTools {\r\n    static polygon(edgeCount, asCenterMode) {\r\n        const vertexs = [];\r\n        const faces = [];\r\n        const radius = 1;\r\n        let vertexCount = edgeCount;\r\n        if (edgeCount >= 3) {\r\n            const perRadian = 3.14 * 2 / edgeCount;\r\n            if (asCenterMode) {\r\n                vertexCount++;\r\n                vertexs.push([0, 0]);\r\n            }\r\n            for (let i = 0; i < edgeCount; i++) {\r\n                const pos = [Math.cos(perRadian * i) * radius, Math.sin(perRadian * i) * radius];\r\n                vertexs.push(pos);\r\n            }\r\n            if (asCenterMode) {\r\n                for (let i = 3; i <= vertexCount; i++) {\r\n                    faces.push([0, i - 2, i - 1]);\r\n                }\r\n                faces.push([0, vertexCount - 1, 1]);\r\n            }\r\n            else {\r\n                for (let i = 3; i <= vertexCount; i++) {\r\n                    faces.push([0, i - 2, i - 1]);\r\n                }\r\n            }\r\n        }\r\n        return { vertexs, faces };\r\n    }\r\n    static sphere(detailH, detailV) {\r\n        const half = this.sphereHalf(detailH, detailV, (x) => {\r\n            const cos = Math.cos(Math.PI * x * 2);\r\n            return cos; // Math.abs(4 * x - 2) - 1; //(1 * (cos / Math.abs(cos)) - cos); // * (cos / Math.abs(cos));\r\n        }, (x) => {\r\n            // const sin = Math.abs(Math.cos(x) * Math.sin(x * 2)) * 0.9 + 0.2; // Math.sin(Math.PI * x * 8);\r\n            // return sin; // (1 * (sin / Math.abs(sin)) - sin); // * (sin / Math.abs(sin));\r\n            return Math.sin(Math.PI * x * 2);\r\n        }, (x) => { return Math.cos(Math.PI * x / 2); }, (x) => {\r\n            return Math.sin(Math.PI * x / 2);\r\n            // return (Math.pow((x * 2 - 1), 3) + 1) / 2;\r\n        }, true);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return Math.cos(Math.PI * x / 2); }, (x) => { return Math.sin(Math.PI * x / 2); }, \r\n        // (x: number) => {\r\n        //     return (Math.pow((x * 2 - 1), 3) + 1) / 2;\r\n        // },\r\n        true);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 棱锥体\r\n     * @param detailH 底面多边形边数目\r\n     */\r\n    static pyramid(detailH) {\r\n        const detailV = 1;\r\n        const half = this.sphereHalf(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return Math.cos(Math.PI * x / 2); }, (x) => { return Math.sin(Math.PI * x / 2); }, true);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return 0; }, false);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 柱体\r\n     * @param detailH 底面多边形边数目\r\n     */\r\n    static column(detailH) {\r\n        const detailV = 1;\r\n        const half = this.sphereHalf(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return x; }, false);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return 0; }, false);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 反棱柱\r\n     * @param detailH 底面多边形边数目\r\n     */\r\n    static antiPrism(detailH) {\r\n        const detailV = 1;\r\n        const half = this.sphereHalf(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return x; }, false);\r\n        const halfRevert = this.sphereHalfRevert(detailH, detailV, (x) => { return Math.cos(Math.PI * x * 2); }, (x) => { return Math.sin(Math.PI * x * 2); }, (x) => { return 1; }, (x) => { return 0; }, false);\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const deltaRadian = Math.PI / detailH;\r\n        if (result.vertexs3D) {\r\n            half.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push(point);\r\n                    }\r\n                });\r\n            });\r\n            half.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    result.faces.push(face);\r\n                });\r\n            });\r\n            const halfPointCount = result.vertexs3D.length;\r\n            halfRevert.circleList.forEach((cicle) => {\r\n                cicle.forEach((point) => {\r\n                    if (result.vertexs3D) {\r\n                        result.vertexs3D.push([_math__WEBPACK_IMPORTED_MODULE_0__[\"MathTools\"].cos_a_add_b(point[1], point[0], deltaRadian), _math__WEBPACK_IMPORTED_MODULE_0__[\"MathTools\"].sin_a_add_b(point[1], point[0], deltaRadian), point[2]]);\r\n                    }\r\n                });\r\n            });\r\n            halfRevert.facesList.forEach((faces) => {\r\n                faces.forEach((face) => {\r\n                    if (result.vertexs3D) {\r\n                        result.faces.push([face[0] + halfPointCount, face[1] + halfPointCount, face[2] + halfPointCount]);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 丝带\r\n     * @param detailCount 细节点数目\r\n     */\r\n    static ribbon(detailCount) {\r\n        const one_dimensional_points = [];\r\n        const one_dimensional_weights = [];\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const xFunction = (x) => {\r\n            return x * Math.cos(Math.PI * x * 2) * 0.8;\r\n        };\r\n        const wFunction = (x) => {\r\n            return x < 0.3 ? (Math.sin(Math.PI * (x / 0.3) / 2)) : x > 0.8 ? (Math.cos(Math.PI * ((x - 0.8) / 0.2) / 2)) : 1.0;\r\n        };\r\n        for (let i = 0; i < detailCount; i++) {\r\n            const x = i / detailCount;\r\n            const y = xFunction(x);\r\n            const w = wFunction(x) * 0.2;\r\n            one_dimensional_points.push(y);\r\n            one_dimensional_weights.push(w);\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i] = [(x - 0.5) * 2, y - w, 0];\r\n                result.vertexs3D[i + detailCount] = [(x - 0.5) * 2, y + w, 0];\r\n            }\r\n            result.faces = this.sphereRibbon(0, detailCount);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 丝带\r\n     * @param detailCount 细节点数目\r\n     */\r\n    static ribbon_from_line(points) {\r\n        const detailCount = points.length;\r\n        if (detailCount < 2) {\r\n            return;\r\n        }\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        for (let i = 1; i < detailCount; i++) {\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i] = [points[i][0], points[i][1] - 0.02, 0];\r\n                result.vertexs3D[i + detailCount] = [points[i][0], points[i][1] + 0.02, 0];\r\n            }\r\n        }\r\n        result.faces = this.sphereRibbon(0, detailCount);\r\n        return result;\r\n    }\r\n    /**\r\n     * 丝带\r\n     * @param detailCount 细节点数目\r\n     */\r\n    static ribbon2(detailCount, delta = 0) {\r\n        const one_dimensional_points = [];\r\n        const one_dimensional_weights = [];\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const xFunction = (x) => {\r\n            x = x - Math.floor(x);\r\n            return Math.cos(Math.PI * x * 2) * 0.8;\r\n        };\r\n        const wFunction = (x) => {\r\n            x = x - Math.floor(x);\r\n            return x < 0.3 ? (Math.sin(Math.PI * (x / 0.3) / 2)) : x > 0.8 ? (Math.cos(Math.PI * ((x - 0.8) / 0.2) / 2)) : 1.0;\r\n        };\r\n        const linePoints = [];\r\n        for (let i = 0; i < detailCount; i++) {\r\n            const x = i / detailCount;\r\n            const y = xFunction(x + delta);\r\n            const w = wFunction(x + delta) * 0.2;\r\n            // one_dimensional_points.push(y);\r\n            // one_dimensional_weights.push(w);\r\n            linePoints.push([(x - 0.5) * 2, y]);\r\n            // if (result.vertexs3D) {\r\n            //     result.vertexs3D[i] = [(x - 0.5) * 2, y - w, 0];\r\n            //     result.vertexs3D[i + detailCount] = [(x - 0.5) * 2, y + w, 0];\r\n            // }\r\n            // result.faces = this.sphereRibbon(0, detailCount);\r\n        }\r\n        return this.ribbon_from_line2(linePoints, 10, wFunction);\r\n    }\r\n    static ribbon_from_line2(points, deltaAngle, deltaAngleFunction, weightFunction, widthScaleHeight = 1) {\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const detailCount = points.length;\r\n        if (detailCount < 2) {\r\n            return;\r\n        }\r\n        let cos = 0, sin = 0, deltaCos = 0, deltaSin = 0, deltaXY = 0, deltaX = 0, deltaY = 0, prePoint = [points[0][0], points[0][1]], nxtPoint = [points[0][0], points[0][1]];\r\n        let currDeltaAngle;\r\n        let deltaDistance = 0;\r\n        let lastTempPoint = [points[0][0], points[0][1]];\r\n        for (let i = 1; i < detailCount; i++) {\r\n            nxtPoint = points[i];\r\n            deltaX = nxtPoint[0] - prePoint[0];\r\n            deltaY = nxtPoint[1] - prePoint[1];\r\n            deltaXY = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n            cos = deltaXY === 0 ? 0 : deltaX / deltaXY;\r\n            sin = deltaXY === 0 ? 0 : deltaY / deltaXY;\r\n            currDeltaAngle = deltaAngleFunction ? deltaAngle * deltaAngleFunction((i - 1) / detailCount) : deltaAngle;\r\n            deltaCos = Math.cos(Math.PI * currDeltaAngle / 180);\r\n            deltaSin = Math.sin(Math.PI * currDeltaAngle / 180);\r\n            deltaDistance = weightFunction ? weightFunction(i / detailCount) : 0.01;\r\n            // if (deltaXY > deltaDistance) {\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i - 1] = [\r\n                    (cos * deltaCos - sin * deltaSin) * deltaDistance / widthScaleHeight + prePoint[0],\r\n                    (sin * deltaCos + cos * deltaSin) * deltaDistance + prePoint[1],\r\n                    0\r\n                ];\r\n                result.vertexs3D[i - 1 + detailCount] = [\r\n                    (cos * deltaCos + sin * deltaSin) * deltaDistance / widthScaleHeight + prePoint[0],\r\n                    (sin * deltaCos - cos * deltaSin) * deltaDistance + prePoint[1],\r\n                    0\r\n                ];\r\n            }\r\n            lastTempPoint = prePoint;\r\n            // } else {\r\n            //     if (result.vertexs3D) {\r\n            //         result.vertexs3D[i - 1] = [\r\n            //             (cos * deltaCos - sin * deltaSin) * deltaDistance + lastTempPoint[0],\r\n            //             (sin * deltaCos + cos * deltaSin) * deltaDistance + lastTempPoint[1],\r\n            //             0\r\n            //         ];\r\n            //         result.vertexs3D[i - 1 + detailCount] = [\r\n            //             (cos * deltaCos + sin * deltaSin) * deltaDistance + lastTempPoint[0],\r\n            //             (sin * deltaCos - cos * deltaSin) * deltaDistance + lastTempPoint[1],\r\n            //             0\r\n            //         ];\r\n            //     }\r\n            // }\r\n            prePoint = points[i];\r\n        }\r\n        deltaCos = Math.cos(Math.PI * 45 / 180);\r\n        deltaSin = Math.sin(Math.PI * 45 / 180);\r\n        if (result.vertexs3D) {\r\n            result.vertexs3D[detailCount - 1] = [\r\n                (cos * deltaCos - sin * deltaSin) * deltaXY / widthScaleHeight + prePoint[0],\r\n                (sin * deltaSin + cos * deltaCos) * deltaXY + prePoint[1],\r\n                0\r\n            ];\r\n            result.vertexs3D[detailCount - 1 + detailCount] = [\r\n                (cos * deltaCos + sin * deltaSin) * deltaXY / widthScaleHeight + prePoint[0],\r\n                (sin * deltaSin - cos * deltaCos) * deltaXY + prePoint[1],\r\n                0\r\n            ];\r\n        }\r\n        result.faces = this.sphereRibbon(0, detailCount);\r\n        return result;\r\n    }\r\n    static sphereHalfRevert(detailH, detailV, xFunction, yFunction, detailHFucntion, detailVFucntion, topIsProtruding = true) {\r\n        const { circleList, facesList } = this.sphereHalf(detailH, detailV, xFunction, yFunction, detailHFucntion, detailVFucntion, topIsProtruding);\r\n        circleList.forEach((circle) => {\r\n            circle.reverse();\r\n            circle.forEach((point) => {\r\n                point[2] *= -1;\r\n            });\r\n            // const total = circle.length;\r\n            // const count = circle.length / 2;\r\n            // for (let i = 0; i < count; i++) {\r\n            //     const temp = circle[i];\r\n            //     circle[i]           = circle[total - i];\r\n            //     circle[total - i]   = temp;\r\n            // }\r\n        });\r\n        return { circleList, facesList };\r\n    }\r\n    static sphereHalf(detailH, detailV, xFunction, yFunction, detailHFucntion, detailVFucntion, topIsProtruding = true) {\r\n        const baseCirclePoints = this.circlePoints(detailH, xFunction, yFunction);\r\n        const circleList = [];\r\n        const facesList = [];\r\n        let circlePointCount = 0;\r\n        const vcount = topIsProtruding ? detailV : detailV + 1;\r\n        for (let i = 0; i < vcount; i++) {\r\n            const vDistance = detailVFucntion(i / detailV);\r\n            const radius = detailHFucntion(i / detailV); // Math.sqrt(1 - (i * i) / (detailV * detailV));\r\n            // const vDistance = Math.sin(Math.PI * i / detailV / 2);\r\n            // const radius    = Math.cos(Math.PI * i / detailV / 2);\r\n            const tempList = this.circlePointsScale(this.copyCirclePoints(baseCirclePoints), radius);\r\n            circlePointCount = tempList.length;\r\n            if (i > 0) {\r\n                facesList.push(this.sphereRing(circlePointCount * (i - 1), circlePointCount));\r\n            }\r\n            circleList.push(this.circleFillZ(tempList, vDistance));\r\n        }\r\n        facesList.push(this.sphereTop(circlePointCount * (circleList.length - 1), circlePointCount));\r\n        circleList.push([[0, 0, detailVFucntion(1)]]);\r\n        return {\r\n            circleList,\r\n            facesList\r\n        };\r\n    }\r\n    static sphereRing(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + i + 1 + pointCount\r\n            ], [\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1 + pointCount,\r\n                pointStartIndex + i + pointCount\r\n            ]);\r\n        }\r\n        const i = pointCount - 1;\r\n        faces.push([\r\n            pointStartIndex + i,\r\n            pointStartIndex + 0,\r\n            pointStartIndex + 0 + pointCount\r\n        ], [\r\n            pointStartIndex + i,\r\n            pointStartIndex + 0 + pointCount,\r\n            pointStartIndex + i + pointCount\r\n        ]);\r\n        return faces;\r\n    }\r\n    static sphereRibbon(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + i + 1 + pointCount\r\n            ], [\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1 + pointCount,\r\n                pointStartIndex + i + pointCount\r\n            ]);\r\n        }\r\n        return faces;\r\n    }\r\n    static sphereTop(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + pointCount\r\n            ]);\r\n        }\r\n        faces.push([\r\n            pointStartIndex + pointCount - 1,\r\n            pointStartIndex + 0,\r\n            pointStartIndex + pointCount\r\n        ]);\r\n        return faces;\r\n    }\r\n    static circleFillZ(circle, z) {\r\n        const result = [];\r\n        circle.forEach((point) => {\r\n            result.push([point[0], point[1], z]);\r\n        });\r\n        return result;\r\n    }\r\n    static circlePoints(detail, xFunction, yFunction) {\r\n        const points = [];\r\n        for (let i = 0; i < detail; i++) {\r\n            points.push([xFunction(i / detail), yFunction(i / detail)]);\r\n        }\r\n        return points;\r\n    }\r\n    static circlePointsDym(detail, radius, xFunction, yFunction) {\r\n        const points = this.circlePoints(detail, xFunction, yFunction);\r\n        return this.circlePointsScale(points, radius);\r\n    }\r\n    static circlePointsScale(points, radius) {\r\n        points.forEach((point) => {\r\n            point[0] *= radius;\r\n            point[1] *= radius;\r\n        });\r\n        return points;\r\n    }\r\n    static copyCirclePoints(points) {\r\n        const result = [];\r\n        points.forEach((point) => {\r\n            result.push([point[0], point[1]]);\r\n        });\r\n        return result;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/geometry.ts?");

/***/ }),

/***/ "./src/math/math.ts":
/*!**************************!*\
  !*** ./src/math/math.ts ***!
  \**************************/
/*! exports provided: MathTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MathTools\", function() { return MathTools; });\n/**\r\n * 数学函数库\r\n */\r\nclass MathTools {\r\n    static sin(x) {\r\n        return Math.sin(x);\r\n    }\r\n    static cos(x) {\r\n        return Math.cos(x);\r\n    }\r\n    static isPrimeNumber(n) {\r\n        if (n < 2) {\r\n            return false;\r\n        }\r\n        for (let i = 2; i <= n - 1; i++) {\r\n            if (n % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @description 下一个2的冥的数\r\n     */\r\n    static nextPowerOfTwo(value) {\r\n        --value;\r\n        value |= value >> 1;\r\n        value |= value >> 2;\r\n        value |= value >> 4;\r\n        value |= value >> 8;\r\n        value |= value >> 16;\r\n        return ++value;\r\n    }\r\n    /**\r\n     * sin(a+b) = sin(a) * cos(b) + cos(a) * sin(b)\r\n     * @param sin_a\r\n     * @param cos_a\r\n     * @param b\r\n     */\r\n    static sin_a_add_b(sin_a, cos_a, b) {\r\n        return sin_a * Math.cos(b) + cos_a * Math.sin(b);\r\n    }\r\n    /**\r\n     * cos(a+b) = cos(a) * cos(b) - sin(a) * sin(b)\r\n     * @param sin_a\r\n     * @param cos_a\r\n     * @param b\r\n     */\r\n    static cos_a_add_b(sin_a, cos_a, b) {\r\n        return cos_a * Math.cos(b) - sin_a * Math.sin(b);\r\n    }\r\n}\r\nMathTools.polarCoordToCartesian = (num) => {\r\n    return {\r\n        x: Math.cos(num) * num,\r\n        y: Math.sin(num) * num\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack:///./src/math/math.ts?");

/***/ }),

/***/ "./src/native/lib/shader_simple.ts":
/*!*****************************************!*\
  !*** ./src/native/lib/shader_simple.ts ***!
  \*****************************************/
/*! exports provided: vs_simple, fs_simple */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vs_simple\", function() { return vs_simple; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fs_simple\", function() { return fs_simple; });\nconst vs_simple = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\nattribute   vec3    a_position;\r\nattribute   vec4    a_color;\r\nattribute   vec2    a_uv;\r\n\r\nvarying     vec3    v_surfacePosition;\r\nvarying     vec4    v_color;\r\nvarying     vec2    v_UV;\r\n\r\nuniform     vec3    u_translate;\r\nuniform     vec3    u_scale;\r\nuniform     vec3    u_rotate;\r\n\r\nvoid main( void ){\r\n    vec2 pos        = a_position.xy;\r\n    pos += vec2(0.5);\r\n    pos *= u_scale.xy;\r\n    pos -= vec2(0.5);\r\n\r\n    pos += u_translate.xy;\r\n\r\n    gl_Position         = vec4( pos, 0., 1. );\r\n    gl_PointSize        = 2.0;\r\n    v_surfacePosition   = a_position;\r\n    v_color             = a_color;\r\n    v_UV                = a_uv;\r\n}\r\n`;\r\nconst fs_simple = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform  sampler2D u_sampler;\r\n\r\nvarying  vec3   v_surfacePosition;\r\nvarying  vec4   v_color;\r\nvarying  vec2   v_UV;\r\n\r\nvoid main(void){\r\n    gl_FragColor = v_color;\r\n}\r\n`;\r\n\n\n//# sourceURL=webpack:///./src/native/lib/shader_simple.ts?");

/***/ }),

/***/ "./src/native/lib/webgl.ts":
/*!*********************************!*\
  !*** ./src/native/lib/webgl.ts ***!
  \*********************************/
/*! exports provided: ShaderCfg, DataBufferCfg, Mesh, Scene, TextureInstance, WebGLInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderCfg\", function() { return ShaderCfg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataBufferCfg\", function() { return DataBufferCfg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureInstance\", function() { return TextureInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLInstance\", function() { return WebGLInstance; });\n/**\r\n * WEBGL 基本处理\r\n */\r\nclass ShaderCfg {\r\n    constructor(sname, vs, fs) {\r\n        this.texActive = false;\r\n        this.sname = sname;\r\n        this.fs = fs;\r\n        this.vs = vs;\r\n    }\r\n    getPrograme(gl) {\r\n        const shader_fragment = this.getFSShader(gl);\r\n        const shader_vertex = this.getVSShader(gl);\r\n        if (this.shader_program === undefined && gl.getShaderParameter(shader_fragment, gl.COMPILE_STATUS)) {\r\n            const shader_program = gl.createProgram();\r\n            this.shader_program = shader_program;\r\n            gl.attachShader(this.shader_program, shader_vertex);\r\n            gl.attachShader(this.shader_program, shader_fragment);\r\n            gl.linkProgram(this.shader_program);\r\n        }\r\n        this.u_mouse_loc = gl.getUniformLocation(this.shader_program, `u_mouse`);\r\n        this.u_time_loc = gl.getUniformLocation(this.shader_program, `u_time`);\r\n        this.u_resolution_loc = gl.getUniformLocation(this.shader_program, `u_resolution`);\r\n        this.u_translate_loc = gl.getUniformLocation(this.shader_program, `u_translate`);\r\n        this.u_scale_loc = gl.getUniformLocation(this.shader_program, `u_scale`);\r\n        this.u_rotate_loc = gl.getUniformLocation(this.shader_program, `u_rotate`);\r\n        this.u_float_loc = gl.getUniformLocation(this.shader_program, `u_float`);\r\n        this.a_position_loc = gl.getAttribLocation(this.shader_program, 'a_position');\r\n        this.a_color_loc = gl.getAttribLocation(this.shader_program, 'a_color');\r\n        this.a_uv = gl.getAttribLocation(this.shader_program, 'a_uv');\r\n        this.u_texture = gl.getUniformLocation(this.shader_program, 'u_sampler');\r\n        this.u_texture1 = gl.getUniformLocation(this.shader_program, 'u_sampler1');\r\n        if (this.a_position_loc >= 0) {\r\n            gl.enableVertexAttribArray(this.a_position_loc);\r\n        }\r\n        if (this.a_color_loc >= 0) {\r\n            gl.enableVertexAttribArray(this.a_color_loc);\r\n        }\r\n        if (this.a_uv >= 0) {\r\n            gl.enableVertexAttribArray(this.a_uv);\r\n        }\r\n        gl.useProgram(this.shader_program);\r\n        if (this.texActive) {\r\n            this.u_texture && gl.uniform1i(this.u_texture, 0);\r\n            this.u_texture1 && gl.uniform1i(this.u_texture1, 1);\r\n        }\r\n    }\r\n    getVSShader(gl) {\r\n        if (gl === null) {\r\n            return this.vshader;\r\n        }\r\n        if (this.vshader) {\r\n            return this.vshader;\r\n        }\r\n        this.vshader = gl.createShader(gl.VERTEX_SHADER);\r\n        if (this.vshader === null) {\r\n            return this.vshader;\r\n        }\r\n        if (this.vs === undefined) {\r\n            return this.vshader;\r\n        }\r\n        gl.shaderSource(this.vshader, this.vs);\r\n        gl.compileShader(this.vshader);\r\n        if (!gl.getShaderParameter(this.vshader, gl.COMPILE_STATUS)) {\r\n            console.error(`ERROR IN 'VERTEX_SHADER' SHADER: ${gl.getShaderInfoLog(this.vshader)}`);\r\n            return this.vshader;\r\n        }\r\n        return this.vshader;\r\n    }\r\n    getFSShader(gl) {\r\n        if (gl === null) {\r\n            return this.fshader;\r\n        }\r\n        if (this.fshader) {\r\n            return this.fshader;\r\n        }\r\n        this.fshader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        if (this.fshader === null) {\r\n            return this.fshader;\r\n        }\r\n        if (this.fs === undefined) {\r\n            return this.fshader;\r\n        }\r\n        gl.shaderSource(this.fshader, this.fs);\r\n        gl.compileShader(this.fshader);\r\n        if (!gl.getShaderParameter(this.fshader, gl.COMPILE_STATUS)) {\r\n            console.error(`ERROR IN 'FRAGMENT_SHADER' SHADER: ${gl.getShaderInfoLog(this.fshader)}`);\r\n            return this.fshader;\r\n        }\r\n        return this.fshader;\r\n    }\r\n}\r\nclass DataBufferCfg {\r\n    constructor(vname) {\r\n        /**\r\n         * 一组 FLOAT 数据的大小\r\n         */\r\n        this.FLOAT_SIZE = 0;\r\n        /**\r\n         * 一组 INT 数据的大小\r\n         * * 没有这个处理必要 - INT 数据为 绘制的ELEMENT\r\n         * * 所有线数据 - 所有面数据 - 所有点数据 没有混合保存\r\n         */\r\n        this.INT_SIZE = 0;\r\n        /**\r\n         * 一个点的 坐标数据 数据量\r\n         */\r\n        this.VERTEX_SIZE = 3;\r\n        /**\r\n         * 一个点的 颜色数据 数据量\r\n         */\r\n        this.COLOR_SIZE = 4;\r\n        /**\r\n         * 一个点的 UV数据 数据量\r\n         */\r\n        this.UV_SIZE = 2;\r\n        /**\r\n         * 一个面的 点数目数据 数据量\r\n         */\r\n        this.FACE_SIZE = 3;\r\n        /**\r\n         * 一个点的 点数目数据 数据量\r\n         */\r\n        this.LINE_SIZE = 2;\r\n        /**\r\n         * 一条线的 点数目数据 数据量\r\n         */\r\n        this.POINT_SIZE = 1;\r\n        this.float_data = [];\r\n        this.int_data = [];\r\n        this.vertex_data = [];\r\n        // public vertex_buffer:           WebGLBuffer | undefined;\r\n        this.vertex_offset = 0;\r\n        this.color_data = [];\r\n        // public color_buffer:            WebGLBuffer | undefined;\r\n        this.color_offset = 0;\r\n        this.face_data = [];\r\n        // public face_buffer:             WebGLBuffer | undefined;\r\n        this.face_offset = 0;\r\n        this.point_data = [];\r\n        // public face_buffer:             WebGLBuffer | undefined;\r\n        this.point_offset = 0;\r\n        this.line_data = [];\r\n        // public line_buffer:             WebGLBuffer | undefined;\r\n        this.line_offset = 0;\r\n        this.uv_data = [];\r\n        // public uv_buffer:               WebGLBuffer | undefined;\r\n        this.uv_offset = 0;\r\n        this.vname = vname;\r\n    }\r\n    addVertex(x, y, z = 0) {\r\n        this.vertex_data.push([x, y, z]);\r\n    }\r\n    addFace(a, b, c) {\r\n        this.face_data.push([a, b, c]);\r\n    }\r\n    addPoint(data) {\r\n        this.point_data.push(data);\r\n    }\r\n    addColor(r, g, b, a) {\r\n        this.color_data.push([r, g, b, a]);\r\n    }\r\n    addUV(u, v) {\r\n        this.uv_data.push([u, v]);\r\n    }\r\n    addVertex2(data) {\r\n        this.vertex_data.push(data);\r\n    }\r\n    addFace2(data) {\r\n        this.face_data.push(data);\r\n    }\r\n    addPoint2(data) {\r\n        this.point_data.push(data);\r\n    }\r\n    addColor2(data) {\r\n        this.color_data.push(data);\r\n    }\r\n    addUV2(data) {\r\n        this.uv_data.push(data);\r\n    }\r\n    clearVertex() {\r\n        this.vertex_data.length = 0;\r\n    }\r\n    clearFace() {\r\n        this.face_data.length = 0;\r\n    }\r\n    clearPoint() {\r\n        this.point_data.length = 0;\r\n    }\r\n    clearColor() {\r\n        this.color_data.length = 0;\r\n    }\r\n    clearUV() {\r\n        this.uv_data.length = 0;\r\n    }\r\n    update(gl) {\r\n        this.activeFloatBuffer(gl);\r\n        this.activeIntBuffer(gl);\r\n    }\r\n    activeFloatBuffer(gl) {\r\n        if (!this.float_buffer) {\r\n            this.float_buffer = gl.createBuffer();\r\n        }\r\n        this.float_data.length = 0;\r\n        const count = this.vertex_data.length;\r\n        let vertex, color, uv;\r\n        for (let i = 0; i < count; i++) {\r\n            vertex = this.vertex_data[i];\r\n            color = this.color_data[i];\r\n            uv = this.uv_data[i];\r\n            vertex && this.float_data.push(...vertex);\r\n            color && this.float_data.push(...color);\r\n            uv && this.float_data.push(...uv);\r\n        }\r\n        let offset = 0;\r\n        if (this.vertex_data.length > 0) {\r\n            this.vertex_offset = offset;\r\n            offset += this.VERTEX_SIZE;\r\n        }\r\n        if (this.color_data.length > 0) {\r\n            this.color_offset = offset;\r\n            offset += this.COLOR_SIZE;\r\n        }\r\n        if (this.uv_data.length > 0) {\r\n            this.uv_offset = offset;\r\n            offset += this.UV_SIZE;\r\n        }\r\n        this.FLOAT_SIZE = offset;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.float_buffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.float_data), gl.STATIC_DRAW);\r\n    }\r\n    activeIntBuffer(gl) {\r\n        if (!this.int_buffer) {\r\n            this.int_buffer = gl.createBuffer();\r\n        }\r\n        this.int_data.length = 0;\r\n        let face, line;\r\n        let faces = [], lines = [];\r\n        this.line_data.length = 0;\r\n        const faceCount = this.face_data.length;\r\n        for (let i = 0; i < faceCount; i++) {\r\n            face = this.face_data[i];\r\n            face && faces.push(...face);\r\n            if (face) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    if (j === 0) {\r\n                        this.line_data.push([face[2], face[0]]);\r\n                    }\r\n                    else {\r\n                        this.line_data.push([face[j - 1], face[j]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const lineCount = this.line_data.length;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            line = this.line_data[i];\r\n            line && lines.push(...line);\r\n        }\r\n        let offset = 0;\r\n        if (faces.length > 0) {\r\n            // this.int_data.push(...faces);\r\n            faces.forEach((face) => {\r\n                this.int_data.push(face);\r\n            });\r\n            this.face_offset = offset;\r\n            offset += faces.length;\r\n        }\r\n        if (lines.length > 0) {\r\n            // this.int_data.push(...lines);\r\n            lines.forEach((line) => {\r\n                this.int_data.push(line);\r\n            });\r\n            this.line_offset = offset;\r\n            offset += lines.length;\r\n        }\r\n        if (this.vertex_data.length > 0) {\r\n            this.vertex_data.forEach((point, index) => {\r\n                this.int_data.push(index);\r\n            });\r\n            this.point_offset = offset;\r\n            offset += this.vertex_data.length;\r\n        }\r\n        this.INT_SIZE = offset;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.int_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.int_data), gl.STATIC_DRAW);\r\n    }\r\n}\r\nclass Mesh {\r\n    constructor(id, geo, material) {\r\n        this.wireFrame = false;\r\n        this.pointFrame = false;\r\n        this.triangleFrame = false;\r\n        this.alphaMode = 0;\r\n        this.translate = [0, 0, 0];\r\n        this.scale = [1, 1, 1];\r\n        this.rotate = [0, 0, 0];\r\n        this.ufloat = 0.0;\r\n        this.id = id;\r\n        this.dataBufferCfg = geo;\r\n        this.shaderCfg = material;\r\n        this.texture = null;\r\n        this.maskTexture = null;\r\n    }\r\n    render(scene) {\r\n        const gl = scene.engine.gl;\r\n        const shader = this.shaderCfg;\r\n        if (this.texture) {\r\n            this.shaderCfg.texActive = this.texture.active();\r\n            if (this.maskTexture) {\r\n                this.shaderCfg.texActive = this.maskTexture.active();\r\n            }\r\n            if (!this.shaderCfg.texActive) {\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            gl.bindTexture(gl.TEXTURE0, null);\r\n        }\r\n        shader.getPrograme(gl);\r\n        shader.u_mouse_loc && gl.uniform2fv(shader.u_mouse_loc, scene.engine.u_mouse);\r\n        shader.u_time_loc && gl.uniform1f(shader.u_time_loc, scene.engine.timestamp * 0.001);\r\n        shader.u_float_loc && gl.uniform1f(shader.u_float_loc, this.ufloat);\r\n        shader.u_resolution_loc && gl.uniform2f(shader.u_resolution_loc, scene.engine.width, scene.engine.height);\r\n        shader.u_translate_loc && gl.uniform3f(shader.u_translate_loc, this.translate[0], this.translate[1], this.translate[2]);\r\n        shader.u_scale_loc && gl.uniform3f(shader.u_scale_loc, this.scale[0], this.scale[1], this.scale[2]);\r\n        shader.u_rotate_loc && gl.uniform3f(shader.u_rotate_loc, this.rotate[0], this.rotate[1], this.rotate[2]);\r\n        if (shader.a_position_loc >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_position_loc, this.dataBufferCfg.VERTEX_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.vertex_offset * 4);\r\n        }\r\n        if (shader.a_color_loc >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_color_loc, this.dataBufferCfg.COLOR_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.color_offset * 4);\r\n        }\r\n        if (shader.a_uv >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_uv, this.dataBufferCfg.UV_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.uv_offset * 4);\r\n        }\r\n        if (this.dataBufferCfg.int_buffer) {\r\n            if (this.wireFrame) {\r\n                if (this.dataBufferCfg.line_data.length > 0) {\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dataBufferCfg.int_buffer);\r\n                    gl.drawElements(gl.LINES, this.dataBufferCfg.line_data.length * this.dataBufferCfg.LINE_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.line_offset * 2);\r\n                }\r\n            }\r\n            if (this.triangleFrame) {\r\n                if (this.dataBufferCfg.face_data.length > 0) {\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dataBufferCfg.int_buffer);\r\n                    gl.drawElements(gl.TRIANGLES, this.dataBufferCfg.face_data.length * this.dataBufferCfg.FACE_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.face_offset * 2);\r\n                }\r\n            }\r\n            if (this.pointFrame) {\r\n                if (this.dataBufferCfg.vertex_data.length > 0) {\r\n                    gl.drawElements(gl.POINTS, this.dataBufferCfg.vertex_data.length * this.dataBufferCfg.POINT_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.point_offset * 2);\r\n                }\r\n            }\r\n        }\r\n        gl.flush();\r\n    }\r\n}\r\nclass Scene {\r\n    constructor(sname, engine) {\r\n        this.viewport = [0, 0, 0, 0];\r\n        this.meshMap = new Map();\r\n        this.sname = sname;\r\n        this.engine = engine;\r\n    }\r\n    addMesh(mesh) {\r\n        this.meshMap.set(mesh.id, mesh);\r\n    }\r\n    render(isClear) {\r\n        const gl = this.engine.gl;\r\n        gl.viewport(this.viewport[0], this.viewport[1], this.viewport[2], this.viewport[3]);\r\n        if (isClear) {\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n        gl.disable(gl.CULL_FACE); // 不开启背面剔除\r\n        gl.disable(gl.DEPTH_TEST); // 不开启深度测试\r\n        gl.disable(gl.SCISSOR_TEST); // 避免渲染范围被前一个渲染过程限制\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        this.meshMap.forEach((mesh) => {\r\n            mesh.render(this);\r\n        });\r\n    }\r\n}\r\nclass TextureInstance {\r\n    constructor(name, engine, index) {\r\n        this.fname = name;\r\n        this._engine = engine;\r\n        this._tex = null;\r\n        this._index = index || 0;\r\n        engine.addTexture(this);\r\n        TextureInstance.loadCall(name, engine, TextureInstance.loaded);\r\n    }\r\n    active() {\r\n        let result = false;\r\n        const GL = this._engine.gl;\r\n        if (this._tex) {\r\n            if (this._index === 0) {\r\n                GL.activeTexture(GL.TEXTURE0);\r\n            }\r\n            else if (this._index === 1) {\r\n                GL.activeTexture(GL.TEXTURE1);\r\n            }\r\n            GL.bindTexture(GL.TEXTURE_2D, this._tex);\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n    remove() {\r\n        this._engine.delTexture(this);\r\n    }\r\n}\r\nTextureInstance.loadCall = (path, engine, cb) => {\r\n    try {\r\n        // const img = new Image();\r\n        // img.onload = () => {\r\n        //     cb(img, path, engine);\r\n        // };\r\n        // img.src = path;\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n    }\r\n};\r\nTextureInstance.loaded = (img, fname, engine) => {\r\n    const texIns = engine.getTexture(fname);\r\n    if (texIns) {\r\n        const GL = engine.gl;\r\n        const tex = GL.createTexture();\r\n        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);\r\n        GL.bindTexture(GL.TEXTURE_2D, tex);\r\n        GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, img);\r\n        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);\r\n        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n        GL.generateMipmap(GL.TEXTURE_2D);\r\n        GL.bindTexture(GL.TEXTURE_2D, null);\r\n        texIns._tex = tex;\r\n    }\r\n};\r\nclass WebGLInstance {\r\n    constructor(opt) {\r\n        this.u_mouse = [0, 0];\r\n        this.timestamp = 0;\r\n        this.sceneMap = new Map();\r\n        this.textureMap = new Map();\r\n        this._isDestroy = false;\r\n        this.loop = (timestamp) => {\r\n            this.timestamp = timestamp;\r\n            this.renderLoop(timestamp);\r\n            requestAnimationFrame(this.loop);\r\n        };\r\n        this.canvas = opt.canvas;\r\n        this.width = this.canvas.width;\r\n        this.height = this.canvas.height;\r\n        this.gl = WebGLInstance.ctxInitFunc(this.canvas);\r\n    }\r\n    get isDestroy() {\r\n        return this._isDestroy;\r\n    }\r\n    static ctxInitFunc(canvas) {\r\n        let gl = null;\r\n        try {\r\n            for (var ii = 0; ii < WebGLInstance.contentModes.length; ++ii) {\r\n                try {\r\n                    gl = canvas.getContext(WebGLInstance.contentModes[ii], { alpha: true, antialias: false });\r\n                }\r\n                catch (e) {\r\n                    //\r\n                }\r\n                if (gl) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.warn(`There is not webgl compatible :( `);\r\n        }\r\n        return gl;\r\n    }\r\n    createTexture(fname, index) {\r\n        let tex = this.textureMap.get(fname);\r\n        if (tex === undefined) {\r\n            tex = new TextureInstance(fname, this, index);\r\n        }\r\n        return tex;\r\n    }\r\n    addTexture(tex) {\r\n        this.textureMap.set(tex.fname, tex);\r\n    }\r\n    getTexture(fname) {\r\n        return this.textureMap.get(fname);\r\n    }\r\n    delTexture(tex) {\r\n        this.textureMap.delete(tex.fname);\r\n        this.gl.deleteTexture(tex);\r\n    }\r\n    addScene(cfg) {\r\n        this.sceneMap.set(cfg.sname, cfg);\r\n    }\r\n    clearColor() {\r\n        const gl = this.gl;\r\n        gl.viewport(0, 0, this.width, this.height);\r\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    renderLoop(timestamp) { }\r\n    destroy() {\r\n        this._isDestroy = true;\r\n        this.textureMap.forEach((tex) => {\r\n            this.delTexture(tex);\r\n        });\r\n    }\r\n}\r\nWebGLInstance.uniforms_1f = ['u_time'];\r\nWebGLInstance.uniforms_2fv = ['u_mouse'];\r\nWebGLInstance.uniforms_2f = ['u_resolution'];\r\nWebGLInstance.contentModes = [\"webgl\", \"experimental-webgl\", \"webgl2\", \"webkit-3d\", \"moz-webgl\"];\r\n\n\n//# sourceURL=webpack:///./src/native/lib/webgl.ts?");

/***/ }),

/***/ "./src/native/simple/main.ts":
/*!***********************************!*\
  !*** ./src/native/simple/main.ts ***!
  \***********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _render_launcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render_launcher */ \"./src/native/simple/render_launcher.ts\");\n/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/geometry */ \"./src/math/geometry.ts\");\n\r\n\r\nconst createButton = (tag, clikCall) => {\r\n    const div = document.createElement('div');\r\n    div.innerHTML = `\r\n        <span style=\"color: black;\">${tag}</span><input id=\"${tag}\" type=\"number\" value=\"edgeCount:\"/>\r\n    `;\r\n    div.style.width = '200px';\r\n    div.style.height = 'auto';\r\n    div.style.backgroundColor = 'green';\r\n    div.addEventListener('pointerdown', (e) => {\r\n        const arg = document.getElementById(tag);\r\n        clikCall && clikCall(arg.value);\r\n    });\r\n    createPanel().appendChild(div);\r\n};\r\nconst createPanel = () => {\r\n    if (!panel) {\r\n        panel = document.createElement('div');\r\n        panel.style.width = '200px';\r\n        panel.style.height = '400px';\r\n        panel.style.overflowY = 'auto';\r\n        panel.style.position = 'absolute';\r\n        document.body.appendChild(panel);\r\n    }\r\n    return panel;\r\n};\r\nlet panel;\r\nconst canvas = document.getElementById('your_canvas');\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\ncanvas.style.transform = 'scale(0.5)';\r\n_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].active(canvas, null);\r\ncreateButton('polygon', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        // dataBuffer01.VERTEX_SIZE = 2;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].polygon(edgeCount, true);\r\n        if (sphere) {\r\n            if (sphere.vertexs) {\r\n                sphere.vertexs.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[1], 0);\r\n                    dataBuffer01.addColor(Math.abs(vertex[1]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('pyramid', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].pyramid(edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('antiPrism', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].antiPrism(edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('column', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].column(edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('sphere', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (arg && _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        const edgeCount = arg - 0;\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].sphere(edgeCount, edgeCount);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n                    dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\ncreateButton('ribbon', (arg) => {\r\n    // const reg = /edgeCount:(.+)-()/;\r\n    // const resResult = arg.match(reg);\r\n    if (_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh) {\r\n        const dataBuffer01 = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].mesh.dataBufferCfg;\r\n        dataBuffer01.clearVertex();\r\n        dataBuffer01.clearColor();\r\n        dataBuffer01.clearFace();\r\n        // const sphere = GeometryTools.sphere(100, 100);\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GeometryTools\"].ribbon2(100, Date.now() % 1000 / 1000);\r\n        if (sphere) {\r\n            if (sphere.vertexs3D) {\r\n                sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                    dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n                    dataBuffer01.addColor(0.8, 0, 0, 1);\r\n                });\r\n            }\r\n            sphere.faces.forEach((face) => {\r\n                dataBuffer01.addFace(face[0], face[1], face[2]);\r\n            });\r\n        }\r\n        dataBuffer01.update(_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl);\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./src/native/simple/main.ts?");

/***/ }),

/***/ "./src/native/simple/render_launcher.ts":
/*!**********************************************!*\
  !*** ./src/native/simple/render_launcher.ts ***!
  \**********************************************/
/*! exports provided: RenderLauncher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderLauncher\", function() { return RenderLauncher; });\n/* harmony import */ var _lib_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/webgl */ \"./src/native/lib/webgl.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/math */ \"./src/math/math.ts\");\n/* harmony import */ var _math_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/geometry */ \"./src/math/geometry.ts\");\n/* harmony import */ var _lib_shader_simple__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/shader_simple */ \"./src/native/lib/shader_simple.ts\");\n\r\n\r\n\r\n\r\nclass RenderLauncher {\r\n    static active(canvas, args) {\r\n        RenderLauncher.simple(canvas, args);\r\n        return RenderLauncher.webgldemo;\r\n    }\r\n    static puase() {\r\n    }\r\n    static destroy() {\r\n        if (RenderLauncher.webgldemo && !RenderLauncher.webgldemo.isDestroy) {\r\n            RenderLauncher.webgldemo.destroy();\r\n            RenderLauncher.webgldemo = null;\r\n            if (RenderLauncher.opt.meshProgress) {\r\n                RenderLauncher.opt.meshProgress = undefined;\r\n            }\r\n        }\r\n    }\r\n    static simple(canvas, args) {\r\n        const opt = {};\r\n        opt.canvas = canvas;\r\n        RenderLauncher.webgldemo = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"WebGLInstance\"](opt);\r\n        _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"TextureInstance\"].loadCall = RenderLauncher.createTextureLoad;\r\n        const webgldemo = RenderLauncher.webgldemo;\r\n        if (!RenderLauncher.webgldemo.gl) {\r\n            return;\r\n        }\r\n        const shader01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"ShaderCfg\"]('01', _lib_shader_simple__WEBPACK_IMPORTED_MODULE_3__[\"vs_simple\"], _lib_shader_simple__WEBPACK_IMPORTED_MODULE_3__[\"fs_simple\"]);\r\n        const scene01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]('01', webgldemo);\r\n        const dataBuffer01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"DataBufferCfg\"]('01');\r\n        // const polygon8 = GeometryTools.polygon(8, true);\r\n        // if (polygon8.vertexs) {\r\n        //     polygon8.vertexs.forEach((vertex) => {\r\n        //         dataBuffer01.addVertex(vertex[0], vertex[1], 0);\r\n        //         dataBuffer01.addColor(1, 0, 0, 1);\r\n        //     });\r\n        // }\r\n        // polygon8.faces.forEach((face) => {\r\n        //     dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        // });\r\n        // dataBuffer01.update(<WebGLRenderingContext>webgldemo.gl);\r\n        const sphere = _math_geometry__WEBPACK_IMPORTED_MODULE_2__[\"GeometryTools\"].antiPrism(5);\r\n        if (sphere.vertexs3D) {\r\n            sphere.vertexs3D.forEach((vertex) => {\r\n                dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n                dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n            });\r\n        }\r\n        sphere.faces.forEach((face) => {\r\n            dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        });\r\n        dataBuffer01.update(webgldemo.gl);\r\n        const mesh01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]('mesh01', dataBuffer01, shader01);\r\n        mesh01.translate[0] = 0.0;\r\n        mesh01.translate[1] = 0.0;\r\n        mesh01.scale[0] = 1.0;\r\n        mesh01.scale[1] = 1.0;\r\n        mesh01.rotate[0] = 1.57;\r\n        mesh01.wireFrame = true;\r\n        mesh01.pointFrame = true;\r\n        // mesh01.triangleFrame = true;\r\n        // mesh01.texture = RenderLauncher.webgldemo.createTexture('/resources/alpha.png');\r\n        scene01.addMesh(mesh01);\r\n        RenderLauncher.mesh = mesh01;\r\n        webgldemo.renderLoop = (timestamp) => {\r\n            webgldemo.clearColor();\r\n            scene01.viewport[0] = 0;\r\n            scene01.viewport[1] = 0;\r\n            scene01.viewport[2] = webgldemo.width;\r\n            scene01.viewport[3] = webgldemo.height;\r\n            scene01.render(true);\r\n        };\r\n        webgldemo.loop(0);\r\n        // setInterval(() => {\r\n        //     dataBuffer01.clearVertex();\r\n        //     dataBuffer01.clearColor();\r\n        //     dataBuffer01.clearFace();\r\n        //     const sphere = GeometryTools.pyramid(5);\r\n        //     if (sphere.vertexs3D) {\r\n        //         sphere.vertexs3D.forEach((vertex) => {\r\n        //             dataBuffer01.addVertex(vertex[0], vertex[2], vertex[1]);\r\n        //             dataBuffer01.addColor(Math.abs(vertex[2]), 0, 0, 1);\r\n        //         });\r\n        //     }\r\n        //     sphere.faces.forEach((face) => {\r\n        //         dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        //     });\r\n        //     dataBuffer01.update(<WebGLRenderingContext>webgldemo.gl);\r\n        // }, 2000);\r\n        // let delta = 0;\r\n        // setInterval(() => {\r\n        //     dataBuffer01.clearVertex();\r\n        //     dataBuffer01.clearColor();\r\n        //     dataBuffer01.clearFace();\r\n        //     // const sphere = GeometryTools.sphere(100, 100);\r\n        //     const sphere = GeometryTools.ribbon2(100, delta += 0.01);\r\n        //     if (sphere) {\r\n        //         if (sphere.vertexs3D) {\r\n        //             sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n        //                 dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n        //                 dataBuffer01.addColor(0.8, 0, 0, 1);\r\n        //             });\r\n        //         }\r\n        //         sphere.faces.forEach((face) => {\r\n        //             dataBuffer01.addFace(face[0], face[1], face[2]);\r\n        //         });\r\n        //     }\r\n        //     dataBuffer01.update(<WebGLRenderingContext>webgldemo.gl);\r\n        // }, 20);\r\n        return mesh01;\r\n    }\r\n    static updateProgress(num) {\r\n        if (RenderLauncher.opt.meshProgress) {\r\n            RenderLauncher.opt.meshProgress.ufloat = num;\r\n        }\r\n    }\r\n}\r\nRenderLauncher.opt = {};\r\nRenderLauncher.loadImageSucc = (img, fname) => {\r\n    _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"TextureInstance\"].loaded(img, fname, RenderLauncher.webgldemo);\r\n};\r\nRenderLauncher.createTextureLoad = (fname, engine, cb) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n        const width = _math_math__WEBPACK_IMPORTED_MODULE_1__[\"MathTools\"].nextPowerOfTwo(img.width);\r\n        const height = _math_math__WEBPACK_IMPORTED_MODULE_1__[\"MathTools\"].nextPowerOfTwo(img.height);\r\n        if (img.width !== width || img.height !== height) {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            // document.body.appendChild(canvas);\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(img, 0, 0, width, height);\r\n            ctx.save();\r\n            RenderLauncher.loadImageSucc(canvas, fname);\r\n        }\r\n        else {\r\n            RenderLauncher.loadImageSucc(img, fname);\r\n        }\r\n        // setTimeout(() => { loadImageSucc(img, data.fname); }, 2000);\r\n    };\r\n    img.src = fname;\r\n};\r\n\n\n//# sourceURL=webpack:///./src/native/simple/render_launcher.ts?");

/***/ })

/******/ });