/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/transform/3d/test/test.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/coordinate_system/left_coordinate_sys_3d.ts":
/*!*********************************************************!*\
  !*** ./src/coordinate_system/left_coordinate_sys_3d.ts ***!
  \*********************************************************/
/*! exports provided: LeftHandCoordinateSys3D */
/*! exports used: LeftHandCoordinateSys3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return LeftHandCoordinateSys3D; });\n/* harmony import */ var _math_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/matrix */ \"./src/math/matrix.ts\");\n/* harmony import */ var _math_matrix4x4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/matrix4x4 */ \"./src/math/matrix4x4.ts\");\n/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vector3 */ \"./src/math/vector3.ts\");\n\r\n\r\n\r\nclass LeftHandCoordinateSys3D {\r\n    constructor() {\r\n        this.tempMatrix4x4 = new _math_matrix4x4__WEBPACK_IMPORTED_MODULE_1__[/* Matrix4x4 */ \"a\"]();\r\n    }\r\n    getRotationMatrixWithAixsAndAngle(axisDirection, angleRadians, result) {\r\n        let cosA = Math.cos(angleRadians);\r\n        let one_cosA = 1.0 - cosA;\r\n        let sinA = Math.sin(angleRadians);\r\n        let x = axisDirection.x;\r\n        let y = axisDirection.y;\r\n        let z = axisDirection.z;\r\n        let xx = x * x, xy = x * y, xz = x * z, yy = y * y, yz = y * z, zz = z * z;\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(1, 1, 4, 4)] = cosA * 1 + one_cosA * xx + sinA * (0);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(1, 2, 4, 4)] = cosA * 0 + one_cosA * xy + sinA * (-z);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(1, 3, 4, 4)] = cosA * 0 + one_cosA * xz + sinA * (y);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(2, 1, 4, 4)] = cosA * 0 + one_cosA * xy + sinA * (z);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(2, 2, 4, 4)] = cosA * 1 + one_cosA * yy + sinA * (0);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(2, 3, 4, 4)] = cosA * 0 + one_cosA * yz + sinA * (-x);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(3, 1, 4, 4)] = cosA * 0 + one_cosA * xz + sinA * (-y);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(3, 2, 4, 4)] = cosA * 0 + one_cosA * yz + sinA * (x);\r\n        result.m[_math_matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].RowMajorOrder(3, 3, 4, 4)] = cosA * 1 + one_cosA * zz + sinA * (0);\r\n        result._isDirty = true;\r\n    }\r\n    vector3RotateWithAxisAndAngle(axisDirection, angleRadians, source, result) {\r\n        let cosA = Math.cos(angleRadians);\r\n        let one_cosA = 1.0 - cosA;\r\n        let sinA = Math.sin(angleRadians);\r\n        let tempV = new _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"](axisDirection.x, axisDirection.y, axisDirection.z);\r\n        _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].CrossToRef(tempV, source, tempV);\r\n        _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].ScaleToRef(tempV, sinA, result);\r\n        let dot = _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].Dot(axisDirection, source);\r\n        _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].ScaleToRef(axisDirection, dot * one_cosA, tempV);\r\n        _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].AddToRef(result, tempV, result);\r\n        _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].ScaleToRef(source, cosA, tempV);\r\n        _math_vector3__WEBPACK_IMPORTED_MODULE_2__[/* Vector3 */ \"a\"].AddToRef(result, tempV, result);\r\n        tempV.dispose();\r\n    }\r\n    decompose(target, scaling, rotation, translation) {\r\n        let result = false;\r\n        if (target.isIdentity()) {\r\n            if (translation) {\r\n                translation.x = 0;\r\n                translation.y = 0;\r\n                translation.z = 0;\r\n            }\r\n            if (scaling) {\r\n                scaling.x = 1;\r\n                scaling.y = 1;\r\n                scaling.z = 1;\r\n            }\r\n            if (rotation) {\r\n                rotation.x = 0;\r\n                rotation.y = 0;\r\n                rotation.z = 0;\r\n                rotation.w = 1;\r\n            }\r\n            return true;\r\n        }\r\n        const m = target.m;\r\n        if (translation) {\r\n            translation.x = m[12];\r\n            translation.y = m[13];\r\n            translation.z = m[14];\r\n        }\r\n        let sx = 1, sy = 1, sz = 1;\r\n        let m11 = m[0], m12 = m[1], m13 = m[2], m21 = m[4], m22 = m[5], m23 = m[6], m31 = m[8], m32 = m[9], m33 = m[10];\r\n        sx = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\r\n        sy = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\r\n        sz = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\r\n        if (_math_matrix4x4__WEBPACK_IMPORTED_MODULE_1__[/* Matrix4x4 */ \"a\"].Determinant(target) <= 0) {\r\n            sy *= -1;\r\n        }\r\n        if (scaling) {\r\n            scaling.x = sx;\r\n            scaling.y = sy;\r\n            scaling.z = sz;\r\n        }\r\n        if (sx === 0 || sy === 0 || sz === 0) {\r\n            if (rotation) {\r\n                rotation.x = 0;\r\n                rotation.y = 0;\r\n                rotation.z = 0;\r\n                rotation.w = 1;\r\n            }\r\n            return false;\r\n        }\r\n        if (rotation) {\r\n            sx = 1 / sx, sy = 1 / sy;\r\n            sz = 1 / sz;\r\n            let tempM = this.tempMatrix4x4.m;\r\n            tempM[0] = m[0] * sx, tempM[1] = m[1] * sx, tempM[2] = m[2] * sx, tempM[3] = 0,\r\n                tempM[4] = m[4] * sy, tempM[5] = m[5] * sy, tempM[6] = m[6] * sy, tempM[7] = 0,\r\n                tempM[8] = m[8] * sz, tempM[9] = m[9] * sz, tempM[10] = m[10] * sz, tempM[11] = 0,\r\n                tempM[12] = 0, tempM[13] = 0, tempM[14] = 0, tempM[15] = 1;\r\n            this.tempMatrix4x4._isDirty = true;\r\n            this.rotationMatrixToQuaternion(this.tempMatrix4x4, rotation);\r\n        }\r\n        return result;\r\n    }\r\n    composeToRef(scaling, rotation, translation, result) {\r\n        let m = result.m;\r\n        let x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;\r\n        let x2 = x + x, y2 = y + y, z2 = z + z;\r\n        let xx = x * x2, xy = x * y2, xz = x * z2;\r\n        let yy = y * y2, yz = y * z2, zz = z * z2;\r\n        let wx = w * x2, wy = w * y2, wz = w * z2;\r\n        let sx = scaling.x, sy = scaling.y, sz = scaling.z;\r\n        m[0] = (1 - (yy + zz)) * sx;\r\n        m[1] = (xy + wz) * sx;\r\n        m[2] = (xz - wy) * sx;\r\n        m[3] = 0;\r\n        m[4] = (xy - wz) * sy;\r\n        m[5] = (1 - (xx + zz)) * sy;\r\n        m[6] = (yz + wx) * sy;\r\n        m[7] = 0;\r\n        m[8] = (xz + wy) * sz;\r\n        m[9] = (yz - wx) * sz;\r\n        m[10] = (1 - (xx + yy)) * sz;\r\n        m[11] = 0;\r\n        m[12] = translation.x;\r\n        m[13] = translation.y;\r\n        m[14] = translation.z;\r\n        m[15] = 1;\r\n        result._isDirty = true;\r\n    }\r\n    quaternionToRotationMatrixRef(quat, result) {\r\n        var xx = quat.x * quat.x;\r\n        var yy = quat.y * quat.y;\r\n        var zz = quat.z * quat.z;\r\n        var xy = quat.x * quat.y;\r\n        var zw = quat.z * quat.w;\r\n        var zx = quat.z * quat.x;\r\n        var yw = quat.y * quat.w;\r\n        var yz = quat.y * quat.z;\r\n        var xw = quat.x * quat.w;\r\n        result.m[0] = 1.0 - (2.0 * (yy + zz));\r\n        result.m[1] = 2.0 * (xy + zw);\r\n        result.m[2] = 2.0 * (zx - yw);\r\n        result.m[3] = 0.0;\r\n        result.m[4] = 2.0 * (xy - zw);\r\n        result.m[5] = 1.0 - (2.0 * (zz + xx));\r\n        result.m[6] = 2.0 * (yz + xw);\r\n        result.m[7] = 0.0;\r\n        result.m[8] = 2.0 * (zx + yw);\r\n        result.m[9] = 2.0 * (yz - xw);\r\n        result.m[10] = 1.0 - (2.0 * (yy + xx));\r\n        result.m[11] = 0.0;\r\n        result.m[12] = 0.0;\r\n        result.m[13] = 0.0;\r\n        result.m[14] = 0.0;\r\n        result.m[15] = 1.0;\r\n        result._isDirty = true;\r\n    }\r\n    rotationMatrixToQuaternion(source, result) {\r\n        const m = source.m;\r\n        let m11 = m[0], m12 = m[1], m13 = m[2], m21 = m[4], m22 = m[5], m23 = m[6], m31 = m[8], m32 = m[9], m33 = m[10];\r\n        let trace = m11 + m22 + m33;\r\n        let s = 0;\r\n        if (trace > 0) {\r\n            s = 0.5 / Math.sqrt(trace + 1.0);\r\n            result.w = 0.25 / s;\r\n            result.x = (m32 - m23) * s;\r\n            result.y = (m13 - m31) * s;\r\n            result.z = (m21 - m12) * s;\r\n        }\r\n        else if (m11 > m22 && m11 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\r\n            result.w = (m32 - m23) / s;\r\n            result.x = 0.25 * s;\r\n            result.y = (m12 + m21) / s;\r\n            result.z = (m13 + m31) / s;\r\n        }\r\n        else if (m22 > m33) {\r\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\r\n            result.w = (m13 - m31) / s;\r\n            result.x = (m12 + m21) / s;\r\n            result.y = 0.25 * s;\r\n            result.z = (m23 + m32) / s;\r\n        }\r\n        else {\r\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\r\n            result.w = (m21 - m12) / s;\r\n            result.x = (m13 + m31) / s;\r\n            result.y = (m23 + m32) / s;\r\n            result.z = 0.25 * s;\r\n        }\r\n    }\r\n    transformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {\r\n        let m = transformation.m;\r\n        let rx = x * m[0] + y * m[4] + z * m[8] + m[12];\r\n        let ry = x * m[1] + y * m[5] + z * m[9] + m[13];\r\n        let rz = x * m[2] + y * m[6] + z * m[10] + m[14];\r\n        let rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\r\n        result.x = rx * rw;\r\n        result.y = ry * rw;\r\n        result.z = rz * rw;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/coordinate_system/left_coordinate_sys_3d.ts?");

/***/ }),

/***/ "./src/display/html_display.ts":
/*!*************************************!*\
  !*** ./src/display/html_display.ts ***!
  \*************************************/
/*! exports provided: display */
/*! exports used: display */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return display; });\nfunction display(str) {\r\n    let node = document.createElement('span');\r\n    node.innerHTML = str;\r\n    document.body.style.whiteSpace = \"pre\";\r\n    document.body.style.fontFamily = \"serif\";\r\n    document.body.appendChild(node);\r\n}\r\n\n\n//# sourceURL=webpack:///./src/display/html_display.ts?");

/***/ }),

/***/ "./src/math/matrix.ts":
/*!****************************!*\
  !*** ./src/math/matrix.ts ***!
  \****************************/
/*! exports provided: N1, N2, N3, N4, Matrix */
/*! exports used: Matrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* unused harmony export N1 */\n/* unused harmony export N2 */\n/* unused harmony export N3 */\n/* unused harmony export N4 */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Matrix; });\n/* harmony import */ var _pool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pool */ \"./src/math/pool.ts\");\n/* harmony import */ var _scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar */ \"./src/math/scalar.ts\");\n\r\n\r\nconst N1 = 1;\r\nconst N2 = 2;\r\nconst N3 = 3;\r\nconst N4 = 4;\r\n/**\r\n * 行主序 存储\r\n * * 0  1  2  3\r\n * * 4  5  6  7\r\n * * 8  9 10 11\r\n * * ......\r\n */\r\nclass Matrix {\r\n    /**\r\n     * 创建一个矩阵\r\n     * @param row 行数目\r\n     * @param col 列数目\r\n     * @param value 元素值\r\n     */\r\n    constructor(row, col, value = 0) {\r\n        /** @hidden */\r\n        this._isDirty = true;\r\n        this._size = col * row;\r\n        this.row = row;\r\n        this.col = col;\r\n        this._m = Object(_pool__WEBPACK_IMPORTED_MODULE_0__[/* createFloat32Array */ \"a\"])(this._size);\r\n        for (let i = 0; i < this._size; i++) {\r\n            this._m[i] = value;\r\n        }\r\n    }\r\n    get m() { return this._m; }\r\n    isEqual(b) {\r\n        let size = this._m.length;\r\n        let result = true;\r\n        for (let i = 0; i < size; i++) {\r\n            if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[i], b._m[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    dispose() {\r\n        Object(_pool__WEBPACK_IMPORTED_MODULE_0__[/* recycleFloat32Array */ \"b\"])(this._m);\r\n        this._m = undefined;\r\n    }\r\n    /**\r\n     * 获取矩阵数据副本\r\n     * @returns Float32Array\r\n     */\r\n    toArray() {\r\n        return new Float32Array(this._m.buffer.slice(0));\r\n    }\r\n    /**\r\n     * 获取矩阵格式化显示字符串\r\n     * @param length 每个元素显示时的字符总长度\r\n     * @param decimalLenght 小数部分显示字符数目\r\n     * @returns 格式化字符串\r\n     */\r\n    toFormatString(length = 12, decimalLenght = 4, breakString = '\\r\\n') {\r\n        let result = '';\r\n        for (let j = 0; j < this.row; j++) {\r\n            for (let i = 0; i < this.col; i++) {\r\n                let sourceIndex = j * this.col + i;\r\n                result += _scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].FormatString(this._m[sourceIndex], length, decimalLenght) + ',';\r\n            }\r\n            result += breakString;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 行主序存储的索引计算\r\n     * @param rowIndex 行序号\r\n     * @param colIndex 列序号\r\n     * @param row 行数目\r\n     * @param col 列数目\r\n     * @returns 数组索引\r\n     */\r\n    static RowMajorOrder(rowIndex, colIndex, row, col) {\r\n        return (rowIndex - 1) * col + (colIndex - 1);\r\n    }\r\n    /**\r\n     * 列主序存储的索引计算\r\n     * @param rowIndex 行序号\r\n     * @param colIndex 列序号\r\n     * @param row 行数目\r\n     * @param col 列数目\r\n     * @returns 数组索引\r\n     */\r\n    static ColMajorOrder(rowIndex, colIndex, row, col) {\r\n        return (rowIndex - 1) + (colIndex - 1) * row;\r\n    }\r\n    /**\r\n     * 获取矩阵指定 列 的子矩阵\r\n     * @param source source matrix\r\n     * @param colIndex index of column\r\n     * @param result result matrix\r\n     */\r\n    static GetColumn(source, colIndex, result) {\r\n        let rowCount = source.row;\r\n        for (let i = 0; i < rowCount; i++) {\r\n            result._m[i] = source._m[i * source.col + colIndex];\r\n        }\r\n    }\r\n    /**\r\n     * 获取矩阵指定 行 的子矩阵\r\n     * @param source source matrix\r\n     * @param rowIndex index of row\r\n     * @param result result matrix\r\n     */\r\n    static GetRow(source, rowIndex, result) {\r\n        let colCount = source.col;\r\n        for (let i = 0; i < colCount; i++) {\r\n            result._m[i] = source._m[rowIndex * source.col + i];\r\n        }\r\n    }\r\n    /**\r\n     * 创建元素全为 0 的矩阵\r\n     * @param row 行数目\r\n     * @param col 列数目\r\n     * @return Zero Matrix\r\n     */\r\n    static Zero(row, col) {\r\n        let result = new Matrix(row, col, 0.);\r\n        return result;\r\n    }\r\n    /**\r\n     * 修改元素为 指定数值\r\n     * @param target target matrix\r\n     * @param value value number\r\n     */\r\n    static ModifyToRef(target, value) {\r\n        for (let i = 0; i < target._size; i++) {\r\n            target._m[i] = value;\r\n        }\r\n        target._isDirty = true;\r\n    }\r\n    /**\r\n     * 修改矩阵指定元素为 指定数值 - 行主序\r\n     * @param target target matrix\r\n     * @param rowIndex index of row\r\n     * @param colIndex index of col\r\n     * @param value value number\r\n     */\r\n    static ModifyCellToRef(target, rowIndex, colIndex, value) {\r\n        if (rowIndex <= target.row && colIndex <= target.col) {\r\n            target._m[Matrix.RowMajorOrder(rowIndex, colIndex, target.row, target.col)] = value;\r\n            target._isDirty = true;\r\n        }\r\n        else {\r\n            throw new Error(`Matrix ModifyToRef Error: rowIndex or colIndex is out of bound.`);\r\n        }\r\n    }\r\n    /**\r\n     * 创建元素全为 1 的矩阵\r\n     * @param row 行数目\r\n     * @param col 列数目\r\n     * @return One Matrix\r\n     */\r\n    static One(row, col) {\r\n        let result = new Matrix(row, col, 1.);\r\n        return result;\r\n    }\r\n    /**\r\n     * 矩阵复制\r\n     * @returns result matrix\r\n     */\r\n    clone() {\r\n        let result = new Matrix(this.row, this.col, 0.);\r\n        Matrix.CopyTo(this, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 矩阵复制\r\n     * @param source source matrix\r\n     * @param result result matrix\r\n     */\r\n    static CopyTo(source, result) {\r\n        for (let i = 0; i < result._size; i++) {\r\n            result._m[i] = source._m[i];\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 检查矩阵行列是否相同\r\n     * @param left left matrix\r\n     * @param right right matrix\r\n     * @returns bool\r\n     */\r\n    static SameColRow(left, right) {\r\n        return left.col === right.col && left.row === right.row;\r\n    }\r\n    /**\r\n     * 矩阵加法\r\n     * @param right right matrix\r\n     * @returns result matrix\r\n     */\r\n    add(right) {\r\n        let result = new Matrix(this.row, this.col, 0.);\r\n        Matrix.AddToRef(this, right, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 矩阵加法\r\n     * @param left left matrix\r\n     * @param right right matrix\r\n     * @param result result matrix\r\n     */\r\n    static AddToRef(left, right, result) {\r\n        let size = left._size;\r\n        for (let i = 0; i < size; i++) {\r\n            result._m[i] = left._m[i] + right._m[i];\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 矩阵减法\r\n     * @param right right matrix\r\n     * @returns result matrix\r\n     */\r\n    substract(right) {\r\n        let result = new Matrix(this.row, this.col);\r\n        Matrix.SubstractToRef(this, right, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 矩阵减法\r\n     * @param left left matrix\r\n     * @param right right matrix\r\n     * @param result result matrix\r\n     */\r\n    static SubstractToRef(left, right, result) {\r\n        let size = left._size;\r\n        for (let i = 0; i < size; i++) {\r\n            result._m[i] = left._m[i] - right._m[i];\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 标量乘法\r\n     * @param scalar scale value\r\n     * @returns new matrix\r\n     */\r\n    scale(scalar) {\r\n        let result = new Matrix(this.row, this.col);\r\n        Matrix.ScaleToRef(this, scalar, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 标量乘法\r\n     * @param left target matrix\r\n     * @param scalar scale value\r\n     * @param result result matrix\r\n     */\r\n    static ScaleToRef(left, scalar, result) {\r\n        let size = left._size;\r\n        for (let i = 0; i < size; i++) {\r\n            result._m[i] = left._m[i] * scalar;\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 转置\r\n     */\r\n    transpose() {\r\n        let result = new Matrix(this.col, this.row);\r\n        Matrix.TransposeToRef(this, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 转置: 只能对行列匹配的矩阵使用\r\n     * @param source source matrix\r\n     * @param result Transpose result\r\n     * @tip T(T(A))     = A\r\n     * @tip T(xA)       = xT(A)\r\n     * @tip T(A + B)    = T(A) + T(B)\r\n     * @tip T(AB)       = T(B)T(A)\r\n     */\r\n    static TransposeToRef(source, result) {\r\n        let temp = source.toArray();\r\n        for (let j = 0; j < source.row; j++) {\r\n            for (let i = 0; i < source.col; i++) {\r\n                let sourceIndex = j * source.col + i;\r\n                let resultIndex = i * result.col + j;\r\n                result._m[resultIndex] = temp[sourceIndex];\r\n            }\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 矩阵乘法 Left * Right = Result\r\n     * @param right right matrix\r\n     * @returns result\r\n     */\r\n    multiply(right) {\r\n        let resultRow = this.row;\r\n        let resultCol = right.col;\r\n        let result = new Matrix(resultRow, resultCol);\r\n        Matrix.MultiplyToRef(this, right, result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 矩阵乘法 Left * Right = Result\r\n     * @param left left matrix\r\n     * @param right right matrix\r\n     * @param result result matrix\r\n     * @tip AB !== BA; eg: A: Matrix<3, 2>, B: Matrix<2, 3>\r\n     * @tip result.row = left.row\r\n     * @tip result.col = right.col\r\n     * @tip compute number of calculate iteration == left.col == right.row\r\n     */\r\n    static MultiplyToRef(left, right, result) {\r\n        // if (left.row === left.col && left.isIdentity()) {\r\n        //     Matrix.CopyFrom(right, result);\r\n        // } else if (right.row === right.col && right.isIdentity()) {\r\n        //     Matrix.CopyFrom(left, result);\r\n        // } else {\r\n        let size = left.m.length;\r\n        let temp = new Float32Array(size);\r\n        let tempLength = left.col;\r\n        let resultRow = left.row;\r\n        let resultCol = right.col;\r\n        let tempLeftRow = new Matrix(tempLength, 1);\r\n        let tempRightCol = new Matrix(tempLength, 1);\r\n        let tempCount = tempLength;\r\n        for (let i = 0; i < resultRow; i++) {\r\n            for (let j = 0; j < resultCol; j++) {\r\n                let resultIndex = i * resultCol + j;\r\n                Matrix.GetRow(left, i, tempLeftRow);\r\n                Matrix.GetColumn(right, j, tempRightCol);\r\n                temp[resultIndex] = 0;\r\n                for (let k = 0; k < tempCount; k++) {\r\n                    temp[resultIndex] += tempLeftRow._m[k] * tempRightCol._m[k];\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < size; i++) {\r\n            result._m[i] = temp[i];\r\n        }\r\n        result._isDirty = true;\r\n        // }\r\n    }\r\n    // public static Dot(right: Matrix) {\r\n    // }\r\n    // public static Cross(right: Matrix, result: Matrix) {\r\n    // }\r\n    /**\r\n     * Sum Of Quared Residuals 残差平方和\r\n     * @param left left matrix\r\n     * @param right right matrix\r\n     */\r\n    static SumOfQuaredResiduals(left, right) {\r\n        let len = left._size;\r\n        let result = 0;\r\n        let tempDiff = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            tempDiff = left._m[i] - right._m[i];\r\n            result += tempDiff * tempDiff;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 各项平方和\r\n     * @param left matrix\r\n     * @returns Sum Of Quared\r\n     */\r\n    static SumOfQuared(left) {\r\n        let len = left._size;\r\n        let result = 0;\r\n        let tempDiff = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            tempDiff = left._m[i];\r\n            result += tempDiff * tempDiff;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 归一化各项 - 如果为 0 矩阵, 则返回第一项为 1 的结果\r\n     * @param left matrix\r\n     * @param result matrix\r\n     */\r\n    static NormalizeToRef(left, result) {\r\n        let len = left._size;\r\n        let length = Math.sqrt(Matrix.SumOfQuared(left));\r\n        if (length == 0) {\r\n            result._m[0] = 1;\r\n            for (let i = 1; i < len; i++) {\r\n                result._m[i] = 0;\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < len; i++) {\r\n                result._m[i] = left._m[i] / length;\r\n            }\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    static FractToRef(target, result) {\r\n        let len = target._size;\r\n        for (let i = 0; i < len; i++) {\r\n            result._m[i] = target._m[i] % 1;\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    static FloorToRef(target, result) {\r\n        let len = target._size;\r\n        for (let i = 0; i < len; i++) {\r\n            result._m[i] = Math.floor(target._m[i]);\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    static CeilToRef(target, result) {\r\n        let len = target._size;\r\n        for (let i = 0; i < len; i++) {\r\n            result._m[i] = Math.ceil(target._m[i]);\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    static RoundToRef(target, result) {\r\n        let len = target._size;\r\n        for (let i = 0; i < len; i++) {\r\n            result._m[i] = Math.round(target._m[i]);\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 在两个矩阵间 线性 插值\r\n     * @param from 起始矩阵\r\n     * @param to 结束矩阵\r\n     * @param amount 插值因子\r\n     * @param result 结果矩阵\r\n     */\r\n    static LerpToRef(from, to, amount, result) {\r\n        let len = from._size;\r\n        let tempDiff = 0;\r\n        for (let i = 0; i < len; i++) {\r\n            tempDiff = to._m[i] - from._m[i];\r\n            result._m[i] = from._m[i] + tempDiff * amount;\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * divide every item\r\n     * @param left Matrix\r\n     * @param right Matrix\r\n     * @param result Matrix\r\n     */\r\n    static DivideItemsToRef(left, right, result) {\r\n        let len = left._size;\r\n        for (let i = 0; i < len; i++) {\r\n            result._m[i] = left._m[i] / right._m[i];\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 在两个矩阵间 Hermite 插值\r\n     * @param value1 起始数值矩阵\r\n     * @param tangent1 起始 tangent 数值\r\n     * @param value2 结束数值矩阵\r\n     * @param tangent2 结束 tangent 数值\r\n     * @param amount 插值因子\r\n     * @param result 结果矩阵\r\n     */\r\n    static Hermite(value1, tangent1, value2, tangent2, amount, result) {\r\n        let squared = amount * amount;\r\n        let cubed = amount * squared;\r\n        let part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        let part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        let part3 = (cubed - (2.0 * squared)) + amount;\r\n        let part4 = cubed - squared;\r\n        let len = value1._size;\r\n        for (let i = 0; i < len; i++) {\r\n            result._m[i] = (((value1._m[i] * part1) + (value2._m[i] * part2)) + (tangent1._m[i] * part3)) + (tangent2._m[i] * part4);\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/matrix.ts?");

/***/ }),

/***/ "./src/math/matrix4x4.ts":
/*!*******************************!*\
  !*** ./src/math/matrix4x4.ts ***!
  \*******************************/
/*! exports provided: Matrix4x4 */
/*! exports used: Matrix4x4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Matrix4x4; });\n/* harmony import */ var _square_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./square_matrix */ \"./src/math/square_matrix.ts\");\n\r\nclass Matrix4x4 extends _square_matrix__WEBPACK_IMPORTED_MODULE_0__[/* SquareMatrix */ \"a\"] {\r\n    constructor() {\r\n        super(4, 4);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/matrix4x4.ts?");

/***/ }),

/***/ "./src/math/pool.ts":
/*!**************************!*\
  !*** ./src/math/pool.ts ***!
  \**************************/
/*! exports provided: createFloat32Array, recycleFloat32Array */
/*! exports used: createFloat32Array, recycleFloat32Array */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createFloat32Array; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return recycleFloat32Array; });\nconst float32arrayPool = [];\r\nconst float32arrayPool3 = [];\r\nconst float32arrayPool4 = [];\r\nconst float32arrayPool16 = [];\r\nfunction createFloat32Array(size) {\r\n    let result;\r\n    if (size == 3) {\r\n        result = float32arrayPool3.pop();\r\n    }\r\n    else if (size == 4) {\r\n        result = float32arrayPool4.pop();\r\n    }\r\n    else if (size == 16) {\r\n        result = float32arrayPool16.pop();\r\n    }\r\n    else {\r\n        let len = float32arrayPool.length;\r\n        if (len > 0) {\r\n            let index = -1;\r\n            for (let i = len - 1; i >= 0; i--) {\r\n                if (float32arrayPool[i].length == size) {\r\n                    index = i;\r\n                    result = float32arrayPool[i];\r\n                    break;\r\n                }\r\n            }\r\n            if (len > 1) {\r\n                float32arrayPool[index] = float32arrayPool[len - 1];\r\n            }\r\n            float32arrayPool.length = len - 1;\r\n        }\r\n    }\r\n    if (!result) {\r\n        result = new Float32Array(size);\r\n    }\r\n    return result;\r\n}\r\nfunction recycleFloat32Array(data) {\r\n    let len = data.length;\r\n    if (len == 3) {\r\n        float32arrayPool3.push(data);\r\n    }\r\n    else if (len == 4) {\r\n        float32arrayPool4.push(data);\r\n    }\r\n    else if (len == 16) {\r\n        float32arrayPool16.push(data);\r\n    }\r\n    else {\r\n        float32arrayPool.push(data);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/pool.ts?");

/***/ }),

/***/ "./src/math/quaternion.ts":
/*!********************************!*\
  !*** ./src/math/quaternion.ts ***!
  \********************************/
/*! exports provided: Quaternion */
/*! exports used: Quaternion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Quaternion; });\n/* harmony import */ var _row__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./row */ \"./src/math/row.ts\");\n/* harmony import */ var _scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar */ \"./src/math/scalar.ts\");\n\r\n\r\nclass Quaternion extends _row__WEBPACK_IMPORTED_MODULE_0__[/* Row */ \"a\"] {\r\n    /** @hidden */\r\n    get x() {\r\n        return this._m[0];\r\n    }\r\n    set x(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[0], value)) {\r\n            this._m[0] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    /** @hidden */\r\n    get y() {\r\n        return this._m[1];\r\n    }\r\n    set y(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[1], value)) {\r\n            this._m[1] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    /** @hidden */\r\n    get z() {\r\n        return this._m[2];\r\n    }\r\n    set z(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[2], value)) {\r\n            this._m[2] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    /** @hidden */\r\n    get w() {\r\n        return this._m[3];\r\n    }\r\n    set w(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[3], value)) {\r\n            this._m[3] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    constructor(x = 0, y = 0, z = 0, w = 1) {\r\n        super(4);\r\n        this._m[0] = x;\r\n        this._m[1] = y;\r\n        this._m[2] = z;\r\n        this._m[3] = w;\r\n    }\r\n    isIdentity() {\r\n        return this._m[0] === 0 && this._m[1] === 0 && this._m[2] === 0 && this._m[3] === 1;\r\n    }\r\n    static IsIdentity(quaternion) {\r\n        return quaternion && quaternion._m[0] === 0 && quaternion._m[1] === 0 && quaternion._m[2] === 0 && quaternion._m[3] === 1;\r\n    }\r\n    static Identity() {\r\n        return new Quaternion(0, 0, 0, 1);\r\n    }\r\n    static IdentityToRef(result) {\r\n        result._m[0] = 0;\r\n        result._m[1] = 0;\r\n        result._m[2] = 0;\r\n        result._m[3] = 1;\r\n        result._isDirty = true;\r\n    }\r\n    static InverseToRef(source, result) {\r\n        result._m[0] = -source._m[0];\r\n        result._m[1] = -source._m[1];\r\n        result._m[2] = -source._m[2];\r\n        result._m[3] = +source._m[3];\r\n        result._isDirty = true;\r\n    }\r\n    /**\r\n     * 欧拉角(弧度)转换到四元数\r\n     * @param x Pitch 弧度\r\n     * @param y Yaw 弧度\r\n     * @param z Roll 弧度\r\n     * @param result Quaternion\r\n     */\r\n    static EulerAnglesToRef(x, y, z, result) {\r\n        Quaternion.RotationYawPitchRollToRef(y, x, z, result);\r\n    }\r\n    /**\r\n     * 欧拉角(弧度)转换到四元数 (in the z-y-x orientation (Tait-Bryan angles))\r\n     * @param yaw rotation around Y axis\r\n     * @param pitch rotation around X axis\r\n     * @param roll rotation around Z aixs\r\n     * @param result quaternion\r\n     */\r\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\r\n        let halfRoll = roll * 0.5;\r\n        let halfPitch = pitch * 0.5;\r\n        let halfYaw = yaw * 0.5;\r\n        let sinRoll = Math.sin(halfRoll);\r\n        let cosRoll = Math.cos(halfRoll);\r\n        let sinPitch = Math.sin(halfPitch);\r\n        let cosPitch = Math.cos(halfPitch);\r\n        let sinYaw = Math.sin(halfYaw);\r\n        let cosYaw = Math.cos(halfYaw);\r\n        result._m[0] = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n        result._m[1] = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n        result._m[2] = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n        result._m[3] = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n        result._isDirty = true;\r\n    }\r\n    static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {\r\n        let halfGammaPlusAlpha = (gamma + alpha) * 0.5;\r\n        let halfGammaMinusAlpha = (gamma - alpha) * 0.5;\r\n        let halfBeta = beta * 0.5;\r\n        result._m[0] = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result._m[1] = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\r\n        result._m[2] = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n        result._m[3] = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\r\n        result._isDirty = true;\r\n    }\r\n    static TransformToEularAnglesRef(source, result) {\r\n        let qz = source.z, qx = source.x, qy = source.y, qw = source.w;\r\n        let sqw = qw * qw, sqx = qx * qx, sqy = qy * qy, sqz = qz * qz;\r\n        let zAxisY = qy * qz - qx * qw;\r\n        let limit = 0.4999999;\r\n        if (zAxisY < -limit) {\r\n            result.m[0] = 2 * Math.atan2(qy, qw);\r\n            result.m[1] = Math.PI / 2;\r\n            result.m[2] = 0;\r\n        }\r\n        else if (zAxisY > limit) {\r\n            result.m[0] = 2 * Math.atan2(qy, qw);\r\n            result.m[1] = -Math.PI / 2;\r\n            result.m[2] = 0;\r\n        }\r\n        else {\r\n            result.m[0] = Math.atan2(2.0 * (qx * qy + qz + qw), (-sqz - sqx + sqy + sqw));\r\n            result.m[1] = Math.asin(-2.0 * (qz * qy - qz * qw));\r\n            result.m[2] = Math.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw));\r\n        }\r\n        result._isDirty = true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/quaternion.ts?");

/***/ }),

/***/ "./src/math/row.ts":
/*!*************************!*\
  !*** ./src/math/row.ts ***!
  \*************************/
/*! exports provided: Row */
/*! exports used: Row */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Row; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./src/math/matrix.ts\");\n\r\nclass Row extends _matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"] {\r\n    constructor(col) {\r\n        super(1, col);\r\n    }\r\n    static Dot(left, right) {\r\n        let result = 0;\r\n        for (let i = 0; i < left.col; i++) {\r\n            result += left._m[i] * right._m[i];\r\n        }\r\n        return result;\r\n    }\r\n    static DistanceSquared(start, end) {\r\n        return Row.SumOfQuaredResiduals(end, start);\r\n    }\r\n    static Distance(start, end) {\r\n        return Math.sqrt(Row.SumOfQuaredResiduals(end, start));\r\n    }\r\n    static Length(target) {\r\n        return Math.sqrt(Row.SumOfQuared(target));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/row.ts?");

/***/ }),

/***/ "./src/math/scalar.ts":
/*!****************************!*\
  !*** ./src/math/scalar.ts ***!
  \****************************/
/*! exports provided: FloatScalar */
/*! exports used: FloatScalar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return FloatScalar; });\nclass FloatScalar {\r\n    static isNaN(value) {\r\n        return isNaN(value);\r\n    }\r\n    /**\r\n     * Boolean: 检查两个数值是否相等\r\n     * @param a left value\r\n     * @param b right value\r\n     * @returns a == b\r\n     */\r\n    static Equal(a, b) {\r\n        return a == b;\r\n    }\r\n    /**\r\n     * Boolean: 检查两个数值是否在指定误差范围内相等\r\n     * @param a left value\r\n     * @param b right value\r\n     * @param epsilon (default = 1.401298E-45)\r\n     * @returns if the absolute diffrence between a and b is lower than epsilon\r\n     */\r\n    static EqualWithEpsilon(a, b, epsilon = 1.401298E-45) {\r\n        let diff = a - b;\r\n        return -epsilon < diff && diff < epsilon;\r\n    }\r\n    /**\r\n     * Returens -1 if value is negative, returns +1 if value is positive, or reuturn 0\r\n     * @param value the value\r\n     */\r\n    static Sign(value) {\r\n        value = +value;\r\n        if (value === 0 || this.isNaN(value)) {\r\n            return 0;\r\n        }\r\n        return value > 0 ? 1 : -1;\r\n    }\r\n    /**\r\n     * Returns the value it self if it's between minimum and maximum\r\n     * Returns minimum if the value is lower than minimum\r\n     * Returns maximum if the value is greater than maximum\r\n     * @param value the value to clamp\r\n     * @param minimum the minimum (default 0)\r\n     * @param maximum the maximum (default 1)\r\n     * @returns the clamped value\r\n     */\r\n    static Clamp(value, minimum = 0, maximum = 1) {\r\n        return Math.min(maximum, Math.max(minimum, value));\r\n    }\r\n    /**\r\n     * Normalized the value between 0.0 and 1.0 using min and max value\r\n     * @param value the value\r\n     * @param min min to normalize between\r\n     * @param max max to normalize between\r\n     * @returns the normalize value\r\n     */\r\n    static Normalize(value, min, max) {\r\n        if (max != min) {\r\n            return this.Clamp((value - min) / (max - min));\r\n        }\r\n        else {\r\n            return 0.;\r\n        }\r\n    }\r\n    /**\r\n     * Denormalize the value between 0.0 and 1.0 using min and max value\r\n     * @param normalised the normalised value\r\n     * @param min min to normalize between\r\n     * @param max max to normalize between\r\n     * @returns the normalize value\r\n     */\r\n    static Denormalize(normalised, min, max) {\r\n        return normalised * (max - min) + min;\r\n    }\r\n    /**\r\n     * Detransform the value to new coordinate using min and max value\r\n     * @param transformed the transformed value\r\n     * @param min min to transform between\r\n     * @param max max to transform between\r\n     * @returns the transform value\r\n     */\r\n    static Detransform(transformed, min, max) {\r\n        return min * (1.0 - transformed) + max * transformed;\r\n    }\r\n    /**\r\n     * Transform the value to new coordinate using min and max value\r\n     * @param value the value\r\n     * @param min min to transform between\r\n     * @param max max to transform between\r\n     * @returns the transform value\r\n     */\r\n    static Transform(value, min, max) {\r\n        if (max != min) {\r\n            return (value - min) / (max - min);\r\n        }\r\n        else {\r\n            return 0.;\r\n        }\r\n    }\r\n    /**\r\n     * Diffrent with modulo operator\r\n     * Repeat(-5, 3) = 1\r\n     * -Infinity to Infinity\r\n     * -5 mod 3 = -2\r\n     * 0 to -Infinity or Infinity\r\n     * @param value the value\r\n     * @param length step length\r\n     */\r\n    static Repeat(value, length) {\r\n        return value - Math.floor(value / length) * length;\r\n    }\r\n    /**\r\n     * PingPongs the value t\r\n     * @param value the value\r\n     * @param length the step length\r\n     */\r\n    static PingPong(value, length) {\r\n        let t = FloatScalar.Repeat(value, length * 2.0);\r\n        return length - Math.abs(t - length);\r\n    }\r\n    /**\r\n     * Calculate the shortest diffrence between two angles in degrees.\r\n     * @param current current degrees\r\n     * @param target target degrees\r\n     * @returns delta degrees\r\n     */\r\n    static DeltaAngle(current, target) {\r\n        let num = FloatScalar.Repeat(target - current, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return num;\r\n    }\r\n    static Step(x1, x2) {\r\n        return x1 <= x2 ? 1. : 0.;\r\n    }\r\n    static SmoothStep(from, to, tx) {\r\n        let t = FloatScalar.Clamp(tx, 0., 1.);\r\n        let tt = t * t;\r\n        t = -2.0 * tt * t + 3.0 * tt;\r\n        return FloatScalar.Detransform(t, from, to);\r\n    }\r\n    static Lerp(from, to, tx) {\r\n        return FloatScalar.Detransform(tx, from, to);\r\n    }\r\n    /**\r\n     * Hermite interplate\r\n     * @param value1 spline value\r\n     * @param tangent1 spline tangent\r\n     * @param value2 spline value\r\n     * @param tangent2 spline tangent\r\n     * @param amount amount\r\n     */\r\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\r\n        let squared = amount * amount;\r\n        let cubed = squared * amount;\r\n        let part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\r\n        let part2 = (-2.0 * cubed) + (3.0 * squared);\r\n        let part3 = (cubed - (2.0 * squared)) + amount;\r\n        let part4 = cubed - squared;\r\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\r\n    }\r\n    static RandomRange(min, max) {\r\n        if (min == max) {\r\n            return min;\r\n        }\r\n        else {\r\n            return FloatScalar.Lerp(min, max, Math.random());\r\n        }\r\n    }\r\n    static FormatString(value, length, decimalLenght, char = \" \") {\r\n        let result = value.toFixed(decimalLenght);\r\n        let tempLength = result.length;\r\n        for (let i = length - tempLength; i >= 0; i--) {\r\n            result = char + result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nFloatScalar.Pi = Math.PI;\r\nFloatScalar.TwoPi = Math.PI * 2;\r\n\n\n//# sourceURL=webpack:///./src/math/scalar.ts?");

/***/ }),

/***/ "./src/math/square_matrix.ts":
/*!***********************************!*\
  !*** ./src/math/square_matrix.ts ***!
  \***********************************/
/*! exports provided: SquareMatrix */
/*! exports used: SquareMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SquareMatrix; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./src/math/matrix.ts\");\n\r\nclass SquareMatrix extends _matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"] {\r\n    constructor(n, value) {\r\n        super(n, n, value);\r\n        /** @hidden */\r\n        this._isDirty = true;\r\n        this._isIdentityDirty = false;\r\n        this._isIdentity = false;\r\n    }\r\n    /**\r\n     * 矩阵是否为单位矩阵\r\n     * @returns bool\r\n     */\r\n    isIdentity() {\r\n        if (this._isDirty || this._isIdentityDirty) {\r\n            this._isIdentity = true;\r\n            for (let i = 0; i < this.col; i++) {\r\n                let indexDiagonal = i * this.col + i;\r\n                for (let j = 0; j < this.row; j++) {\r\n                    let index = i * this.col + j;\r\n                    if (index == indexDiagonal) {\r\n                        this._isIdentity = this._m[index] == 1.;\r\n                    }\r\n                    else {\r\n                        this._isIdentity = this._m[index] == 0.;\r\n                    }\r\n                    if (!this._isIdentity) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (!this._isIdentity) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this._isIdentity;\r\n    }\r\n    /**\r\n     * 创建单位方阵\r\n     * @param n 行列数目\r\n     * @return Identity Matrix\r\n     */\r\n    static Identity(n) {\r\n        let result = new SquareMatrix(n, 0.);\r\n        SquareMatrix.IdentityToRef(result);\r\n        return result;\r\n    }\r\n    /**\r\n     * 将矩阵设置为单位矩阵\r\n     * @param result result\r\n     */\r\n    static IdentityToRef(result) {\r\n        _matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].ModifyToRef(result, 0.);\r\n        for (let i = 0; i < result.col; i++) {\r\n            if (i >= result.row) {\r\n                break;\r\n            }\r\n            result._m[i * result.col + i] = 1;\r\n        }\r\n        result._isIdentity = true;\r\n        result._isIdentityDirty = false;\r\n        result._isDirty = true;\r\n        return result;\r\n    }\r\n    /**\r\n     * 求方阵的逆\r\n     * @param source source\r\n     * @param result multiplicative inverse\r\n     */\r\n    static InvertToRef(source, result) {\r\n        //\r\n        if (source.isIdentity()) {\r\n            SquareMatrix.IdentityToRef(result);\r\n            result._isDirty = true;\r\n            return;\r\n        }\r\n        let row = source.row;\r\n        if (row === 4) {\r\n            return SquareMatrix.InvertToRefN4(source, result);\r\n        }\r\n        else {\r\n            throw new Error(`InvertToRef Not Implment!`);\r\n        }\r\n    }\r\n    static InvertToRefN4(source, result) {\r\n        let m = source.m;\r\n        let m11 = m[0], m12 = m[1], m13 = m[2], m14 = m[3], m21 = m[4], m22 = m[5], m23 = m[6], m24 = m[7], m31 = m[8], m32 = m[9], m33 = m[10], m34 = m[11], m41 = m[12], m42 = m[13], m43 = m[14], m44 = m[15];\r\n        let det_31_42 = m31 * m42 - m41 * m32;\r\n        let det_32_43 = m32 * m43 - m42 * m33;\r\n        let det_33_44 = m33 * m44 - m43 * m34;\r\n        let det_31_44 = m31 * m44 - m41 * m34;\r\n        let det_31_43 = m31 * m43 - m41 * m33;\r\n        let det_32_44 = m32 * m44 - m42 * m34;\r\n        let cofact_11 = +(m22 * (+det_33_44) + m23 * (-det_32_44) + m24 * (+det_32_43));\r\n        let cofact_12 = -(m21 * (+det_33_44) + m23 * (-det_31_44) + m24 * (+det_31_43));\r\n        let cofact_13 = +(m21 * (+det_32_44) + m22 * (-det_31_44) + m24 * (+det_31_42));\r\n        let cofact_14 = -(m21 * (+det_32_43) + m22 * (-det_31_43) + m23 * (+det_31_42));\r\n        let det = m11 * cofact_11 + m12 * cofact_12 + m13 * cofact_13 + m14 * cofact_14;\r\n        if (det === 0) {\r\n            _matrix__WEBPACK_IMPORTED_MODULE_0__[/* Matrix */ \"a\"].CopyTo(source, result);\r\n        }\r\n        else {\r\n            let detInv = 1.0 / det;\r\n            let m = source.m;\r\n            let m11 = m[0], m12 = m[1], m13 = m[2], m14 = m[3], m21 = m[4], m22 = m[5], m23 = m[6], m24 = m[7], m31 = m[8], m32 = m[9], m33 = m[10], m34 = m[11], m41 = m[12], m42 = m[13], m43 = m[14], m44 = m[15];\r\n            let det_23_44 = m23 * m44 - m43 * m24;\r\n            let det_22_44 = m22 * m44 - m42 * m24;\r\n            let det_22_43 = m22 * m43 - m42 * m23;\r\n            let det_21_44 = m21 * m44 - m41 * m24;\r\n            let det_21_43 = m21 * m43 - m41 * m23;\r\n            let det_21_42 = m21 * m42 - m41 * m22;\r\n            let det_23_34 = m23 * m34 - m33 * m24;\r\n            let det_22_34 = m22 * m34 - m32 * m24;\r\n            let det_22_33 = m22 * m33 - m32 * m23;\r\n            let det_21_34 = m21 * m34 - m31 * m24;\r\n            let det_21_33 = m21 * m33 - m31 * m23;\r\n            let det_21_32 = m21 * m32 - m31 * m22;\r\n            let cofact_21 = -(m12 * det_33_44 - m13 * det_32_44 + m14 * det_32_43);\r\n            let cofact_22 = +(m11 * det_33_44 - m13 * det_31_44 + m14 * det_31_43);\r\n            let cofact_23 = -(m11 * det_32_44 - m12 * det_31_44 + m14 * det_31_42);\r\n            let cofact_24 = +(m11 * det_32_43 - m12 * det_31_43 + m13 * det_31_42);\r\n            let cofact_31 = +(m12 * det_23_44 - m13 * det_22_44 + m14 * det_22_43);\r\n            let cofact_32 = -(m11 * det_23_44 - m13 * det_21_44 + m14 * det_21_43);\r\n            let cofact_33 = +(m11 * det_22_44 - m12 * det_21_44 + m14 * det_21_42);\r\n            let cofact_34 = -(m11 * det_22_43 - m12 * det_21_43 + m13 * det_21_42);\r\n            let cofact_41 = -(m12 * det_23_34 - m13 * det_22_34 + m14 * det_22_33);\r\n            let cofact_42 = +(m11 * det_23_34 - m13 * det_21_34 + m14 * det_21_33);\r\n            let cofact_43 = -(m11 * det_22_34 - m12 * det_21_34 + m14 * det_21_32);\r\n            let cofact_44 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\r\n            result.m[0] = cofact_11 * detInv, result.m[4] = cofact_12 * detInv, result.m[8] = cofact_13 * detInv, result.m[12] = cofact_14 * detInv,\r\n                result.m[1] = cofact_21 * detInv, result.m[5] = cofact_22 * detInv, result.m[9] = cofact_23 * detInv, result.m[13] = cofact_24 * detInv,\r\n                result.m[2] = cofact_31 * detInv, result.m[6] = cofact_32 * detInv, result.m[10] = cofact_33 * detInv, result.m[14] = cofact_34 * detInv,\r\n                result.m[3] = cofact_41 * detInv, result.m[7] = cofact_42 * detInv, result.m[11] = cofact_43 * detInv, result.m[15] = cofact_44 * detInv;\r\n            result._isDirty = true;\r\n        }\r\n    }\r\n    /**\r\n     * 求行列式 - 当N>5，消元法优于递归\r\n     * @param target SquareMatrix\r\n     * @returns number\r\n     */\r\n    static Determinant(target) {\r\n        let row = target.row;\r\n        let result = 0;\r\n        if (row == 4) {\r\n            return SquareMatrix.DeterminantN4(target);\r\n        }\r\n        throw new Error(`Determinant Not Implment!`);\r\n    }\r\n    static DeterminantN4(target) {\r\n        let result = 0;\r\n        if (target.isIdentity()) {\r\n            result = 1;\r\n        }\r\n        else {\r\n            let m = target.m;\r\n            let m11 = m[0], m12 = m[1], m13 = m[2], m14 = m[3], m21 = m[4], m22 = m[5], m23 = m[6], m24 = m[7], m31 = m[8], m32 = m[9], m33 = m[10], m34 = m[11], m41 = m[12], m42 = m[13], m43 = m[14], m44 = m[15];\r\n            let det_31_42 = m31 * m42 - m41 * m32;\r\n            let det_32_43 = m32 * m43 - m42 * m33;\r\n            let det_33_44 = m33 * m44 - m43 * m34;\r\n            let det_31_44 = m31 * m44 - m41 * m34;\r\n            let det_31_43 = m31 * m43 - m41 * m33;\r\n            let det_32_44 = m32 * m44 - m42 * m34;\r\n            let cofact_11 = m22 * (+det_33_44) + m23 * (-det_32_44) + m24 * (+det_32_43);\r\n            let cofact_12 = m21 * (+det_33_44) + m23 * (-det_31_44) + m24 * (+det_31_43);\r\n            let cofact_13 = m21 * (+det_32_44) + m22 * (-det_31_44) + m24 * (+det_31_42);\r\n            let cofact_14 = m21 * (+det_32_43) + m22 * (-det_31_43) + m23 * (+det_31_42);\r\n            result = m11 * (+cofact_11) + m12 * (-cofact_12) + m13 * (+cofact_13) + m14 * (-cofact_14);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * 判断方阵是否是奇异的 - 不存在乘法逆元(逆矩阵)\r\n     * @param source source matrix\r\n     */\r\n    static IsSingular(source) {\r\n        throw new Error(`IsSingular Not Implment!`);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/square_matrix.ts?");

/***/ }),

/***/ "./src/math/vector3.ts":
/*!*****************************!*\
  !*** ./src/math/vector3.ts ***!
  \*****************************/
/*! exports provided: Vector3 */
/*! exports used: Vector3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Vector3; });\n/* harmony import */ var _row__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./row */ \"./src/math/row.ts\");\n/* harmony import */ var _scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scalar */ \"./src/math/scalar.ts\");\n\r\n\r\nclass Vector3 extends _row__WEBPACK_IMPORTED_MODULE_0__[/* Row */ \"a\"] {\r\n    /** @hidden */\r\n    get x() {\r\n        return this._m[0];\r\n    }\r\n    set x(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[0], value)) {\r\n            this._m[0] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    /** @hidden */\r\n    get y() {\r\n        return this._m[1];\r\n    }\r\n    set y(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[1], value)) {\r\n            this._m[1] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    /** @hidden */\r\n    get z() {\r\n        return this._m[2];\r\n    }\r\n    set z(value) {\r\n        if (!_scalar__WEBPACK_IMPORTED_MODULE_1__[/* FloatScalar */ \"a\"].Equal(this._m[2], value)) {\r\n            this._m[2] = value;\r\n            this._isDirty = true;\r\n        }\r\n    }\r\n    constructor(x = 0, y = 0, z = 0) {\r\n        super(3);\r\n        this._m[0] = x;\r\n        this._m[1] = y;\r\n        this._m[2] = z;\r\n        return this;\r\n    }\r\n    copyFromFloats(x, y, z) {\r\n        this._m[0] = x;\r\n        this._m[1] = y;\r\n        this._m[2] = z;\r\n        this._isDirty = true;\r\n    }\r\n    static Cross(a, b) {\r\n        let result = new Vector3(0, 0, 0);\r\n        Vector3.CrossToRef(a, b, result);\r\n        return result;\r\n    }\r\n    static CrossToRef(a, b, result) {\r\n        let ax = a.x, ay = a.y, az = a.z;\r\n        let bx = b.x, by = b.y, bz = b.z;\r\n        result._m[0] = ay * bz - by * az;\r\n        result._m[1] = az * bx - bz * ax;\r\n        result._m[2] = ax * by - bx * ay;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/math/vector3.ts?");

/***/ }),

/***/ "./src/transform/3d/node.ts":
/*!**********************************!*\
  !*** ./src/transform/3d/node.ts ***!
  \**********************************/
/*! exports provided: Node */
/*! exports used: Node */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Node; });\n/* harmony import */ var _math_matrix4x4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/matrix4x4 */ \"./src/math/matrix4x4.ts\");\n/* harmony import */ var _math_quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/quaternion */ \"./src/math/quaternion.ts\");\n/* harmony import */ var _math_square_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/square_matrix */ \"./src/math/square_matrix.ts\");\n/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/vector3 */ \"./src/math/vector3.ts\");\n\r\n\r\n\r\n\r\nclass Node {\r\n    constructor(id, coordinateSys) {\r\n        this.coordinateSys = coordinateSys;\r\n        this._position = new _math_vector3__WEBPACK_IMPORTED_MODULE_3__[/* Vector3 */ \"a\"]();\r\n        this._scaling = new _math_vector3__WEBPACK_IMPORTED_MODULE_3__[/* Vector3 */ \"a\"](1, 1, 1);\r\n        this._rotationQuaternion = new _math_quaternion__WEBPACK_IMPORTED_MODULE_1__[/* Quaternion */ \"a\"]();\r\n        this._localMatrix = _math_square_matrix__WEBPACK_IMPORTED_MODULE_2__[/* SquareMatrix */ \"a\"].Identity(4);\r\n        this._worldMatrix = _math_square_matrix__WEBPACK_IMPORTED_MODULE_2__[/* SquareMatrix */ \"a\"].Identity(4);\r\n        this._parentNode = null;\r\n        this._isAbsoluteSynced = false;\r\n        this._absolutePosition = new _math_vector3__WEBPACK_IMPORTED_MODULE_3__[/* Vector3 */ \"a\"]();\r\n        this._absoluteScaling = new _math_vector3__WEBPACK_IMPORTED_MODULE_3__[/* Vector3 */ \"a\"]();\r\n        this._absoluteRotationQuaternion = new _math_quaternion__WEBPACK_IMPORTED_MODULE_1__[/* Quaternion */ \"a\"]();\r\n        this._children = null;\r\n        this.billboardModifier = null;\r\n        this.infinitedDistanceModifier = null;\r\n        /**\r\n         * 针对局部坐标系的修改器\r\n         * @tip 会在正常的局部坐标系计算之前使用\r\n         */\r\n        this.modifierLocalList = [];\r\n        /**\r\n         * 针对世界坐标系的修改器\r\n         * @tip 会在正常的世界坐标系计算之后使用\r\n         */\r\n        this.modifierWorldList = [];\r\n        this.id = id;\r\n    }\r\n    get position() {\r\n        return this._position;\r\n    }\r\n    get rotationQuaternion() {\r\n        return this._rotationQuaternion;\r\n    }\r\n    get parentNode() {\r\n        return this._parentNode;\r\n    }\r\n    get absolutePosition() {\r\n        return this._absolutePosition;\r\n    }\r\n    get absoluteScaling() {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteScaling;\r\n    }\r\n    get absoluteRotationQuaternion() {\r\n        this._syncAbsoluteScalingAndRotation();\r\n        return this._absoluteRotationQuaternion;\r\n    }\r\n    modifyRotationByEulerAngle(x, y, z) {\r\n        _math_quaternion__WEBPACK_IMPORTED_MODULE_1__[/* Quaternion */ \"a\"].RotationYawPitchRollToRef(y, x, z, this._rotationQuaternion);\r\n    }\r\n    setParent(value, keepAbsolute) {\r\n        this._parentNode = value;\r\n    }\r\n    /**\r\n     * 计算世界矩阵\r\n     * @param force 是否强制重新计算\r\n     * @returns 返回节点世界矩阵的引用，外部应当只读\r\n     */\r\n    computeWorldMatrix(force = false) {\r\n        if (force || this._position._isDirty || this._rotationQuaternion._isDirty) {\r\n            //\r\n        }\r\n        // Modify for local\r\n        let modifierCount = this.modifierLocalList.length;\r\n        for (let i = 0; i < modifierCount; i++) {\r\n            let modifier = this.modifierWorldList[i];\r\n            modifier.modify(this);\r\n        }\r\n        // Compose LocalMatrix\r\n        this.coordinateSys.composeToRef(this._scaling, this._rotationQuaternion, this.position, this._localMatrix);\r\n        // Compute WorldMatrix\r\n        if (this._parentNode) {\r\n            _math_matrix4x4__WEBPACK_IMPORTED_MODULE_0__[/* Matrix4x4 */ \"a\"].MultiplyToRef(this._localMatrix, this._parentNode._worldMatrix, this._worldMatrix);\r\n        }\r\n        else {\r\n            _math_matrix4x4__WEBPACK_IMPORTED_MODULE_0__[/* Matrix4x4 */ \"a\"].CopyTo(this._localMatrix, this._worldMatrix);\r\n        }\r\n        // Modify for world\r\n        modifierCount = this.modifierWorldList.length;\r\n        for (let i = 0; i < modifierCount; i++) {\r\n            let modifier = this.modifierWorldList[i];\r\n            modifier.modify(this);\r\n        }\r\n        // 解出全局坐标系下 的三元信息\r\n        this._isAbsoluteSynced = false;\r\n        this.coordinateSys.decompose(this._worldMatrix, undefined, undefined, this._absolutePosition);\r\n        return this._worldMatrix;\r\n    }\r\n    getLocalMatrix(result) {\r\n        this.coordinateSys.composeToRef(this._scaling, this._rotationQuaternion, this.position, result);\r\n    }\r\n    _syncAbsoluteScalingAndRotation() {\r\n        if (!this._isAbsoluteSynced) {\r\n            this.coordinateSys.decompose(this._worldMatrix, this._absoluteScaling, this._absoluteRotationQuaternion, undefined);\r\n            this._isAbsoluteSynced = true;\r\n        }\r\n    }\r\n    dispose() {\r\n        this._scaling.dispose();\r\n        this._position.dispose();\r\n        this._rotationQuaternion.dispose();\r\n        this._localMatrix.dispose();\r\n        this._worldMatrix.dispose();\r\n        this.modifierLocalList.forEach((modifier) => {\r\n            if (!modifier.forCache) {\r\n                modifier.dispose();\r\n            }\r\n        });\r\n        this.modifierLocalList.length = 0;\r\n        this.modifierWorldList.forEach((modifier) => {\r\n            if (!modifier.forCache) {\r\n                modifier.dispose();\r\n            }\r\n        });\r\n        this.modifierWorldList.length = 0;\r\n        this._scaling = null;\r\n        this._position = null;\r\n        this._rotationQuaternion = null;\r\n        this._localMatrix = null;\r\n        this._worldMatrix = null;\r\n        this.modifierLocalList = null;\r\n        this.modifierWorldList = null;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/transform/3d/node.ts?");

/***/ }),

/***/ "./src/transform/3d/test/test.ts":
/*!***************************************!*\
  !*** ./src/transform/3d/test/test.ts ***!
  \***************************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _coordinate_system_left_coordinate_sys_3d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../coordinate_system/left_coordinate_sys_3d */ \"./src/coordinate_system/left_coordinate_sys_3d.ts\");\n/* harmony import */ var _display_html_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../display/html_display */ \"./src/display/html_display.ts\");\n/* harmony import */ var _math_matrix4x4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../math/matrix4x4 */ \"./src/math/matrix4x4.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node */ \"./src/transform/3d/node.ts\");\n/* harmony import */ var _transform_node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transform_node */ \"./src/transform/3d/transform_node.ts\");\n\r\n\r\n\r\n\r\n\r\nfunction breakRow() {\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])('--------------------------------------------------------------<br>');\r\n}\r\nlet tempMat4x4 = new _math_matrix4x4__WEBPACK_IMPORTED_MODULE_2__[/* Matrix4x4 */ \"a\"]();\r\nfunction displayNode(node) {\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Position:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node.position.toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Scaling:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node._scaling.toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Rotation:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node.rotationQuaternion.toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Local Matrix:<br>`);\r\n    node.getLocalMatrix(tempMat4x4);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(tempMat4x4.toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`World Matrix:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node.computeWorldMatrix().toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Absolute Position:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node.absolutePosition.toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Absolute Scaling:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node.absoluteScaling.toFormatString(10, 4, `<br>`));\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`Absolute Rotation:<br>`);\r\n    Object(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(node.absoluteRotationQuaternion.toFormatString(10, 4, `<br>`));\r\n    breakRow();\r\n}\r\nlet coordinate_sys = new _coordinate_system_left_coordinate_sys_3d__WEBPACK_IMPORTED_MODULE_0__[/* LeftHandCoordinateSys3D */ \"a\"]();\r\nlet node0 = new _transform_node__WEBPACK_IMPORTED_MODULE_4__[/* TransformNode */ \"a\"](`0`, coordinate_sys);\r\nnode0.modifyRotationByEulerAngle(90 * Math.PI / 180, 0, 0);\r\nnode0.position.copyFromFloats(100, 0, 0);\r\nnode0.scaling.copyFromFloats(2, 2, 2);\r\nnode0.computeWorldMatrix();\r\nObject(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`node0:<br>`);\r\ndisplayNode(node0);\r\nlet node2 = new _node__WEBPACK_IMPORTED_MODULE_3__[/* Node */ \"a\"](`2`, coordinate_sys);\r\nnode2.setParent(node0);\r\nnode2.position.copyFromFloats(100, 100, 100);\r\nnode2.computeWorldMatrix();\r\nObject(_display_html_display__WEBPACK_IMPORTED_MODULE_1__[/* display */ \"a\"])(`node2:<br>`);\r\ndisplayNode(node2);\r\n\n\n//# sourceURL=webpack:///./src/transform/3d/test/test.ts?");

/***/ }),

/***/ "./src/transform/3d/transform_node.ts":
/*!********************************************!*\
  !*** ./src/transform/3d/transform_node.ts ***!
  \********************************************/
/*! exports provided: TransformNode */
/*! exports used: TransformNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TransformNode; });\n/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/vector3 */ \"./src/math/vector3.ts\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node */ \"./src/transform/3d/node.ts\");\n\r\n\r\nclass TransformNode extends _node__WEBPACK_IMPORTED_MODULE_1__[/* Node */ \"a\"] {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._scaling = new _math_vector3__WEBPACK_IMPORTED_MODULE_0__[/* Vector3 */ \"a\"](1, 1, 1);\r\n    }\r\n    get scaling() {\r\n        return this._scaling;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/transform/3d/transform_node.ts?");

/***/ })

/******/ });