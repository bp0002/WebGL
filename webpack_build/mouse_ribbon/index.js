/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./mouse_ribbon/native/mouse_move_ribbon/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./mouse_ribbon/math/math.ts":
/*!***********************************!*\
  !*** ./mouse_ribbon/math/math.ts ***!
  \***********************************/
/*! exports provided: MathTools */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MathTools\", function() { return MathTools; });\n/**\r\n * 数学函数库\r\n */\r\nclass MathTools {\r\n    static sin(x) {\r\n        return Math.sin(x);\r\n    }\r\n    static cos(x) {\r\n        return Math.cos(x);\r\n    }\r\n    static isPrimeNumber(n) {\r\n        if (n < 2) {\r\n            return false;\r\n        }\r\n        for (let i = 2; i <= n - 1; i++) {\r\n            if (n % i == 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @description 下一个2的冥的数\r\n     */\r\n    static nextPowerOfTwo(value) {\r\n        --value;\r\n        value |= value >> 1;\r\n        value |= value >> 2;\r\n        value |= value >> 4;\r\n        value |= value >> 8;\r\n        value |= value >> 16;\r\n        return ++value;\r\n    }\r\n    /**\r\n     * sin(a+b) = sin(a) * cos(b) + cos(a) * sin(b)\r\n     * @param sin_a\r\n     * @param cos_a\r\n     * @param b\r\n     */\r\n    static sin_a_add_b(sin_a, cos_a, b) {\r\n        return sin_a * Math.cos(b) + cos_a * Math.sin(b);\r\n    }\r\n    /**\r\n     * cos(a+b) = cos(a) * cos(b) - sin(a) * sin(b)\r\n     * @param sin_a\r\n     * @param cos_a\r\n     * @param b\r\n     */\r\n    static cos_a_add_b(sin_a, cos_a, b) {\r\n        return cos_a * Math.cos(b) - sin_a * Math.sin(b);\r\n    }\r\n}\r\nMathTools.polarCoordToCartesian = (num) => {\r\n    return {\r\n        x: Math.cos(num) * num,\r\n        y: Math.sin(num) * num\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack:///./mouse_ribbon/math/math.ts?");

/***/ }),

/***/ "./mouse_ribbon/native/lib/shader_ribbon.ts":
/*!**************************************************!*\
  !*** ./mouse_ribbon/native/lib/shader_ribbon.ts ***!
  \**************************************************/
/*! exports provided: vs_ribbon, fs_ribbon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vs_ribbon\", function() { return vs_ribbon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fs_ribbon\", function() { return fs_ribbon; });\nconst vs_ribbon = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\nattribute   vec3    a_position;\r\nattribute   vec4    a_color;\r\nattribute   vec2    a_uv;\r\n\r\nvarying     vec3    v_surfacePosition;\r\nvarying     vec4    v_color;\r\nvarying     vec2    v_UV;\r\n\r\nuniform     vec3    u_translate;\r\nuniform     vec3    u_scale;\r\nuniform     vec3    u_rotate;\r\n\r\nvoid main( void ){\r\n    vec2 pos        = a_position.xy;\r\n    pos += vec2(0.5);\r\n    pos *= u_scale.xy;\r\n    pos -= vec2(0.5);\r\n\r\n    pos += u_translate.xy;\r\n\r\n    gl_Position         = vec4( pos, 0., 1. );\r\n    gl_PointSize        = 10.0;\r\n    v_surfacePosition   = a_position;\r\n    v_color             = a_color;\r\n    v_UV                = a_uv;\r\n}\r\n`;\r\nconst fs_ribbon = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform  sampler2D u_sampler;\r\n\r\nvarying  vec3   v_surfacePosition;\r\nvarying  vec4   v_color;\r\nvarying  vec2   v_UV;\r\n\r\nvoid main(void){\r\n    gl_FragColor = v_color;\r\n    // gl_FragColor = vec4(texture2D( u_sampler, v_UV ).rgb, v_color.a);\r\n}\r\n`;\r\n\n\n//# sourceURL=webpack:///./mouse_ribbon/native/lib/shader_ribbon.ts?");

/***/ }),

/***/ "./mouse_ribbon/native/lib/webgl.ts":
/*!******************************************!*\
  !*** ./mouse_ribbon/native/lib/webgl.ts ***!
  \******************************************/
/*! exports provided: ShaderCfg, DataBufferCfg, Mesh, Scene, TextureInstance, WebGLInstance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderCfg\", function() { return ShaderCfg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DataBufferCfg\", function() { return DataBufferCfg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mesh\", function() { return Mesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureInstance\", function() { return TextureInstance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebGLInstance\", function() { return WebGLInstance; });\n/**\r\n * WEBGL 基本处理\r\n */\r\nclass ShaderCfg {\r\n    constructor(sname, vs, fs) {\r\n        this.texActive = false;\r\n        this.sname = sname;\r\n        this.fs = fs;\r\n        this.vs = vs;\r\n    }\r\n    getPrograme(gl) {\r\n        const shader_fragment = this.getFSShader(gl);\r\n        const shader_vertex = this.getVSShader(gl);\r\n        if (this.shader_program === undefined && gl.getShaderParameter(shader_fragment, gl.COMPILE_STATUS)) {\r\n            const shader_program = gl.createProgram();\r\n            this.shader_program = shader_program;\r\n            gl.attachShader(this.shader_program, shader_vertex);\r\n            gl.attachShader(this.shader_program, shader_fragment);\r\n            gl.linkProgram(this.shader_program);\r\n        }\r\n        this.u_mouse_loc = gl.getUniformLocation(this.shader_program, `u_mouse`);\r\n        this.u_time_loc = gl.getUniformLocation(this.shader_program, `u_time`);\r\n        this.u_resolution_loc = gl.getUniformLocation(this.shader_program, `u_resolution`);\r\n        this.u_translate_loc = gl.getUniformLocation(this.shader_program, `u_translate`);\r\n        this.u_scale_loc = gl.getUniformLocation(this.shader_program, `u_scale`);\r\n        this.u_rotate_loc = gl.getUniformLocation(this.shader_program, `u_rotate`);\r\n        this.u_float_loc = gl.getUniformLocation(this.shader_program, `u_float`);\r\n        this.a_position_loc = gl.getAttribLocation(this.shader_program, 'a_position');\r\n        this.a_color_loc = gl.getAttribLocation(this.shader_program, 'a_color');\r\n        this.a_uv = gl.getAttribLocation(this.shader_program, 'a_uv');\r\n        this.u_texture = gl.getUniformLocation(this.shader_program, 'u_sampler');\r\n        this.u_texture1 = gl.getUniformLocation(this.shader_program, 'u_sampler1');\r\n        if (this.a_position_loc >= 0) {\r\n            gl.enableVertexAttribArray(this.a_position_loc);\r\n        }\r\n        if (this.a_color_loc >= 0) {\r\n            gl.enableVertexAttribArray(this.a_color_loc);\r\n        }\r\n        if (this.a_uv >= 0) {\r\n            gl.enableVertexAttribArray(this.a_uv);\r\n        }\r\n        gl.useProgram(this.shader_program);\r\n        if (this.texActive) {\r\n            this.u_texture && gl.uniform1i(this.u_texture, 0);\r\n            this.u_texture1 && gl.uniform1i(this.u_texture1, 1);\r\n        }\r\n    }\r\n    getVSShader(gl) {\r\n        if (gl === null) {\r\n            return this.vshader;\r\n        }\r\n        if (this.vshader) {\r\n            return this.vshader;\r\n        }\r\n        this.vshader = gl.createShader(gl.VERTEX_SHADER);\r\n        if (this.vshader === null) {\r\n            return this.vshader;\r\n        }\r\n        if (this.vs === undefined) {\r\n            return this.vshader;\r\n        }\r\n        gl.shaderSource(this.vshader, this.vs);\r\n        gl.compileShader(this.vshader);\r\n        if (!gl.getShaderParameter(this.vshader, gl.COMPILE_STATUS)) {\r\n            console.error(`ERROR IN 'VERTEX_SHADER' SHADER: ${gl.getShaderInfoLog(this.vshader)}`);\r\n            return this.vshader;\r\n        }\r\n        return this.vshader;\r\n    }\r\n    getFSShader(gl) {\r\n        if (gl === null) {\r\n            return this.fshader;\r\n        }\r\n        if (this.fshader) {\r\n            return this.fshader;\r\n        }\r\n        this.fshader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        if (this.fshader === null) {\r\n            return this.fshader;\r\n        }\r\n        if (this.fs === undefined) {\r\n            return this.fshader;\r\n        }\r\n        gl.shaderSource(this.fshader, this.fs);\r\n        gl.compileShader(this.fshader);\r\n        if (!gl.getShaderParameter(this.fshader, gl.COMPILE_STATUS)) {\r\n            console.error(`ERROR IN 'FRAGMENT_SHADER' SHADER: ${gl.getShaderInfoLog(this.fshader)}`);\r\n            return this.fshader;\r\n        }\r\n        return this.fshader;\r\n    }\r\n}\r\nclass DataBufferCfg {\r\n    constructor(vname) {\r\n        /**\r\n         * 一组 FLOAT 数据的大小\r\n         */\r\n        this.FLOAT_SIZE = 0;\r\n        /**\r\n         * 一组 INT 数据的大小\r\n         * * 没有这个处理必要 - INT 数据为 绘制的ELEMENT\r\n         * * 所有线数据 - 所有面数据 - 所有点数据 没有混合保存\r\n         */\r\n        this.INT_SIZE = 0;\r\n        /**\r\n         * 一个点的 坐标数据 数据量\r\n         */\r\n        this.VERTEX_SIZE = 3;\r\n        /**\r\n         * 一个点的 颜色数据 数据量\r\n         */\r\n        this.COLOR_SIZE = 4;\r\n        /**\r\n         * 一个点的 UV数据 数据量\r\n         */\r\n        this.UV_SIZE = 2;\r\n        /**\r\n         * 一个面的 点数目数据 数据量\r\n         */\r\n        this.FACE_SIZE = 3;\r\n        /**\r\n         * 一个点的 点数目数据 数据量\r\n         */\r\n        this.LINE_SIZE = 2;\r\n        /**\r\n         * 一条线的 点数目数据 数据量\r\n         */\r\n        this.POINT_SIZE = 1;\r\n        this.float_data = [];\r\n        this.int_data = [];\r\n        this.vertex_data = [];\r\n        // public vertex_buffer:           WebGLBuffer | undefined;\r\n        this.vertex_offset = 0;\r\n        this.color_data = [];\r\n        // public color_buffer:            WebGLBuffer | undefined;\r\n        this.color_offset = 0;\r\n        this.face_data = [];\r\n        // public face_buffer:             WebGLBuffer | undefined;\r\n        this.face_offset = 0;\r\n        this.point_data = [];\r\n        // public face_buffer:             WebGLBuffer | undefined;\r\n        this.point_offset = 0;\r\n        this.line_data = [];\r\n        // public line_buffer:             WebGLBuffer | undefined;\r\n        this.line_offset = 0;\r\n        this.uv_data = [];\r\n        // public uv_buffer:               WebGLBuffer | undefined;\r\n        this.uv_offset = 0;\r\n        this.vname = vname;\r\n    }\r\n    addVertex(x, y, z = 0) {\r\n        this.vertex_data.push([x, y, z]);\r\n    }\r\n    addFace(a, b, c) {\r\n        this.face_data.push([a, b, c]);\r\n    }\r\n    addPoint(data) {\r\n        this.point_data.push(data);\r\n    }\r\n    addColor(r, g, b, a) {\r\n        this.color_data.push([r, g, b, a]);\r\n    }\r\n    addUV(u, v) {\r\n        this.uv_data.push([u, v]);\r\n    }\r\n    addVertex2(data) {\r\n        this.vertex_data.push(data);\r\n    }\r\n    addFace2(data) {\r\n        this.face_data.push(data);\r\n    }\r\n    addPoint2(data) {\r\n        this.point_data.push(data);\r\n    }\r\n    addColor2(data) {\r\n        this.color_data.push(data);\r\n    }\r\n    addUV2(data) {\r\n        this.uv_data.push(data);\r\n    }\r\n    clearVertex() {\r\n        this.vertex_data.length = 0;\r\n    }\r\n    clearFace() {\r\n        this.face_data.length = 0;\r\n    }\r\n    clearPoint() {\r\n        this.point_data.length = 0;\r\n    }\r\n    clearColor() {\r\n        this.color_data.length = 0;\r\n    }\r\n    clearUV() {\r\n        this.uv_data.length = 0;\r\n    }\r\n    update(gl) {\r\n        this.activeFloatBuffer(gl);\r\n        this.activeIntBuffer(gl);\r\n    }\r\n    activeFloatBuffer(gl) {\r\n        if (!this.float_buffer) {\r\n            this.float_buffer = gl.createBuffer();\r\n        }\r\n        this.float_data.length = 0;\r\n        const count = this.vertex_data.length;\r\n        let vertex, color, uv;\r\n        for (let i = 0; i < count; i++) {\r\n            vertex = this.vertex_data[i];\r\n            color = this.color_data[i];\r\n            uv = this.uv_data[i];\r\n            vertex && this.float_data.push(...vertex);\r\n            color && this.float_data.push(...color);\r\n            uv && this.float_data.push(...uv);\r\n        }\r\n        let offset = 0;\r\n        if (this.vertex_data.length > 0) {\r\n            this.vertex_offset = offset;\r\n            offset += this.VERTEX_SIZE;\r\n        }\r\n        if (this.color_data.length > 0) {\r\n            this.color_offset = offset;\r\n            offset += this.COLOR_SIZE;\r\n        }\r\n        if (this.uv_data.length > 0) {\r\n            this.uv_offset = offset;\r\n            offset += this.UV_SIZE;\r\n        }\r\n        this.FLOAT_SIZE = offset;\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.float_buffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.float_data), gl.STATIC_DRAW);\r\n    }\r\n    activeIntBuffer(gl) {\r\n        if (!this.int_buffer) {\r\n            this.int_buffer = gl.createBuffer();\r\n        }\r\n        this.int_data.length = 0;\r\n        let face, line;\r\n        let faces = [], lines = [];\r\n        this.line_data.length = 0;\r\n        const faceCount = this.face_data.length;\r\n        for (let i = 0; i < faceCount; i++) {\r\n            face = this.face_data[i];\r\n            face && faces.push(...face);\r\n            if (face) {\r\n                for (let j = 0; j < 3; j++) {\r\n                    if (j === 0) {\r\n                        this.line_data.push([face[2], face[0]]);\r\n                    }\r\n                    else {\r\n                        this.line_data.push([face[j - 1], face[j]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const lineCount = this.line_data.length;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            line = this.line_data[i];\r\n            line && lines.push(...line);\r\n        }\r\n        let offset = 0;\r\n        if (faces.length > 0) {\r\n            // this.int_data.push(...faces);\r\n            faces.forEach((face) => {\r\n                this.int_data.push(face);\r\n            });\r\n            this.face_offset = offset;\r\n            offset += faces.length;\r\n        }\r\n        if (lines.length > 0) {\r\n            // this.int_data.push(...lines);\r\n            lines.forEach((line) => {\r\n                this.int_data.push(line);\r\n            });\r\n            this.line_offset = offset;\r\n            offset += lines.length;\r\n        }\r\n        if (this.vertex_data.length > 0) {\r\n            this.vertex_data.forEach((point, index) => {\r\n                this.int_data.push(index);\r\n            });\r\n            this.point_offset = offset;\r\n            offset += this.vertex_data.length;\r\n        }\r\n        this.INT_SIZE = offset;\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.int_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.int_data), gl.STATIC_DRAW);\r\n    }\r\n}\r\nclass Mesh {\r\n    constructor(id, geo, material) {\r\n        this.wireFrame = false;\r\n        this.pointFrame = false;\r\n        this.triangleFrame = false;\r\n        this.alphaMode = 0;\r\n        this.translate = [0, 0, 0];\r\n        this.scale = [1, 1, 1];\r\n        this.rotate = [0, 0, 0];\r\n        this.ufloat = 0.0;\r\n        this.id = id;\r\n        this.dataBufferCfg = geo;\r\n        this.shaderCfg = material;\r\n        this.texture = null;\r\n        this.maskTexture = null;\r\n    }\r\n    render(scene) {\r\n        const gl = scene.engine.gl;\r\n        const shader = this.shaderCfg;\r\n        if (this.texture) {\r\n            this.shaderCfg.texActive = this.texture.active();\r\n            if (this.maskTexture) {\r\n                this.shaderCfg.texActive = this.maskTexture.active();\r\n            }\r\n            if (!this.shaderCfg.texActive) {\r\n                return;\r\n            }\r\n        }\r\n        shader.getPrograme(gl);\r\n        shader.u_mouse_loc && gl.uniform2fv(shader.u_mouse_loc, scene.engine.u_mouse);\r\n        shader.u_time_loc && gl.uniform1f(shader.u_time_loc, scene.engine.timestamp * 0.001);\r\n        shader.u_float_loc && gl.uniform1f(shader.u_float_loc, this.ufloat);\r\n        shader.u_resolution_loc && gl.uniform2f(shader.u_resolution_loc, scene.engine.width, scene.engine.height);\r\n        shader.u_translate_loc && gl.uniform3f(shader.u_translate_loc, this.translate[0], this.translate[1], this.translate[2]);\r\n        shader.u_scale_loc && gl.uniform3f(shader.u_scale_loc, this.scale[0], this.scale[1], this.scale[2]);\r\n        shader.u_rotate_loc && gl.uniform3f(shader.u_rotate_loc, this.rotate[0], this.rotate[1], this.rotate[2]);\r\n        if (shader.a_position_loc >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_position_loc, this.dataBufferCfg.VERTEX_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.vertex_offset * 4);\r\n        }\r\n        if (shader.a_color_loc >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_color_loc, this.dataBufferCfg.COLOR_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.color_offset * 4);\r\n        }\r\n        if (shader.a_uv >= 0) {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.dataBufferCfg.float_buffer);\r\n            gl.vertexAttribPointer(shader.a_uv, this.dataBufferCfg.UV_SIZE, gl.FLOAT, false, this.dataBufferCfg.FLOAT_SIZE * 4, this.dataBufferCfg.uv_offset * 4);\r\n        }\r\n        if (this.dataBufferCfg.int_buffer) {\r\n            if (this.wireFrame) {\r\n                if (this.dataBufferCfg.line_data.length > 0) {\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dataBufferCfg.int_buffer);\r\n                    gl.drawElements(gl.LINES, this.dataBufferCfg.line_data.length * this.dataBufferCfg.LINE_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.line_offset * 2);\r\n                }\r\n            }\r\n            if (this.triangleFrame) {\r\n                if (this.dataBufferCfg.face_data.length > 0) {\r\n                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.dataBufferCfg.int_buffer);\r\n                    gl.drawElements(gl.TRIANGLES, this.dataBufferCfg.face_data.length * this.dataBufferCfg.FACE_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.face_offset * 2);\r\n                }\r\n            }\r\n            if (this.pointFrame) {\r\n                if (this.dataBufferCfg.vertex_data.length > 0) {\r\n                    gl.drawElements(gl.POINTS, this.dataBufferCfg.vertex_data.length * this.dataBufferCfg.POINT_SIZE, gl.UNSIGNED_SHORT, this.dataBufferCfg.point_offset * 2);\r\n                }\r\n            }\r\n        }\r\n        gl.flush();\r\n    }\r\n}\r\nclass Scene {\r\n    constructor(sname, engine) {\r\n        this.viewport = [0, 0, 0, 0];\r\n        this.meshMap = new Map();\r\n        this.sname = sname;\r\n        this.engine = engine;\r\n    }\r\n    addMesh(mesh) {\r\n        this.meshMap.set(mesh.id, mesh);\r\n    }\r\n    render(isClear) {\r\n        const gl = this.engine.gl;\r\n        gl.viewport(this.viewport[0], this.viewport[1], this.viewport[2], this.viewport[3]);\r\n        if (isClear) {\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n        }\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);\r\n        this.meshMap.forEach((mesh) => {\r\n            const gl = this.engine.gl;\r\n            gl && gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\r\n            mesh.render(this);\r\n        });\r\n    }\r\n}\r\nclass TextureInstance {\r\n    constructor(name, engine, index) {\r\n        this.fname = name;\r\n        this._engine = engine;\r\n        this._tex = null;\r\n        this._index = index || 0;\r\n        engine.addTexture(this);\r\n        TextureInstance.loadCall(name, engine, TextureInstance.loaded);\r\n    }\r\n    active() {\r\n        let result = false;\r\n        const GL = this._engine.gl;\r\n        if (this._tex) {\r\n            if (this._index === 0) {\r\n                GL.activeTexture(GL.TEXTURE0);\r\n            }\r\n            else if (this._index === 1) {\r\n                GL.activeTexture(GL.TEXTURE1);\r\n            }\r\n            GL.bindTexture(GL.TEXTURE_2D, this._tex);\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n    remove() {\r\n        this._engine.delTexture(this);\r\n    }\r\n}\r\nTextureInstance.loadCall = (path, engine, cb) => {\r\n    try {\r\n        // const img = new Image();\r\n        // img.onload = () => {\r\n        //     cb(img, path, engine);\r\n        // };\r\n        // img.src = path;\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n    }\r\n};\r\nTextureInstance.loaded = (img, fname, engine) => {\r\n    const texIns = engine.getTexture(fname);\r\n    if (texIns) {\r\n        const GL = engine.gl;\r\n        const tex = GL.createTexture();\r\n        GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);\r\n        GL.bindTexture(GL.TEXTURE_2D, tex);\r\n        GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, img);\r\n        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);\r\n        GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST_MIPMAP_LINEAR);\r\n        GL.generateMipmap(GL.TEXTURE_2D);\r\n        GL.bindTexture(GL.TEXTURE_2D, null);\r\n        texIns._tex = tex;\r\n    }\r\n};\r\nclass WebGLInstance {\r\n    constructor(opt) {\r\n        this.u_mouse = [0, 0];\r\n        this.timestamp = 0;\r\n        this.sceneMap = new Map();\r\n        this.textureMap = new Map();\r\n        this._isDestroy = false;\r\n        this.loop = (timestamp) => {\r\n            this.timestamp = timestamp;\r\n            this.renderLoop(timestamp);\r\n            requestAnimationFrame(this.loop);\r\n        };\r\n        this.canvas = opt.canvas;\r\n        this.width = this.canvas.width;\r\n        this.height = this.canvas.height;\r\n        this.gl = WebGLInstance.ctxInitFunc(this.canvas);\r\n    }\r\n    get isDestroy() {\r\n        return this._isDestroy;\r\n    }\r\n    static ctxInitFunc(canvas) {\r\n        let gl = null;\r\n        try {\r\n            for (var ii = 0; ii < WebGLInstance.contentModes.length; ++ii) {\r\n                try {\r\n                    gl = canvas.getContext(WebGLInstance.contentModes[ii], { alpha: true, antialias: false });\r\n                }\r\n                catch (e) {\r\n                    //\r\n                }\r\n                if (gl) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        catch (error) {\r\n            console.warn(`There is not webgl compatible :( `);\r\n        }\r\n        return gl;\r\n    }\r\n    createTexture(fname, index) {\r\n        let tex = this.textureMap.get(fname);\r\n        if (tex === undefined) {\r\n            tex = new TextureInstance(fname, this, index);\r\n        }\r\n        return tex;\r\n    }\r\n    addTexture(tex) {\r\n        this.textureMap.set(tex.fname, tex);\r\n    }\r\n    getTexture(fname) {\r\n        return this.textureMap.get(fname);\r\n    }\r\n    delTexture(tex) {\r\n        this.textureMap.delete(tex.fname);\r\n        this.gl.deleteTexture(tex);\r\n    }\r\n    addScene(cfg) {\r\n        this.sceneMap.set(cfg.sname, cfg);\r\n    }\r\n    clearColor() {\r\n        const gl = this.gl;\r\n        gl.viewport(0, 0, this.width, this.height);\r\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\r\n    }\r\n    renderLoop(timestamp) { }\r\n    destroy() {\r\n        this._isDestroy = true;\r\n        this.textureMap.forEach((tex) => {\r\n            this.delTexture(tex);\r\n        });\r\n    }\r\n}\r\nWebGLInstance.uniforms_1f = ['u_time'];\r\nWebGLInstance.uniforms_2fv = ['u_mouse'];\r\nWebGLInstance.uniforms_2f = ['u_resolution'];\r\nWebGLInstance.contentModes = [\"webgl\", \"experimental-webgl\", \"webgl2\", \"webkit-3d\", \"moz-webgl\"];\r\n\n\n//# sourceURL=webpack:///./mouse_ribbon/native/lib/webgl.ts?");

/***/ }),

/***/ "./mouse_ribbon/native/mouse_move_ribbon/main.ts":
/*!*******************************************************!*\
  !*** ./mouse_ribbon/native/mouse_move_ribbon/main.ts ***!
  \*******************************************************/
/*! exports provided: MouseTrial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MouseTrial\", function() { return MouseTrial; });\n/* harmony import */ var _render_launcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./render_launcher */ \"./mouse_ribbon/native/mouse_move_ribbon/render_launcher.ts\");\n\r\nclass MouseTrial {\r\n    constructor(mesh, gl, canvasWidth, canvasHeight) {\r\n        /**\r\n         * 当前事件点\r\n         */\r\n        this.currX = 0;\r\n        /**\r\n         * 当前事件点\r\n         */\r\n        this.currY = 0;\r\n        /**\r\n         * 插值点列表\r\n         */\r\n        this.points = [];\r\n        /**\r\n         * down事件标识\r\n         */\r\n        this.downFlag = false;\r\n        /**\r\n         * 事件点记录列表\r\n         */\r\n        this.historyX = [];\r\n        /**\r\n         * 事件点记录列表\r\n         */\r\n        this.historyY = [];\r\n        /**\r\n         * 插值点数量\r\n         */\r\n        this.ropeSize = 100;\r\n        /**\r\n         * 事件点记录数量\r\n         */\r\n        this.historySize = 20;\r\n        this.mesh = null;\r\n        /**\r\n         * 丝带从尾部到头部宽度变化函数\r\n         */\r\n        this.weightFunction = (x) => {\r\n            return Math.sin(Math.PI * x) * 0.01;\r\n        };\r\n        /**\r\n         * 点数据更新\r\n         */\r\n        this.update = () => {\r\n            this.historyX.pop();\r\n            this.historyX.unshift(this.currX);\r\n            this.historyY.pop();\r\n            this.historyY.unshift(this.currY);\r\n            // Update the points to correspond with history.\r\n            for (let i = 0; i < this.ropeSize; i++) {\r\n                const p = this.points[i];\r\n                // Smooth the curve with cubic interpolation to prevent sharp edges.\r\n                const ix = MouseTrial.cubicInterpolation(this.historyX, i / this.ropeSize * this.historySize);\r\n                const iy = MouseTrial.cubicInterpolation(this.historyY, i / this.ropeSize * this.historySize);\r\n                p[0] = ix;\r\n                p[1] = iy;\r\n            }\r\n            if (this.mesh) {\r\n                const dataBuffer01 = this.mesh.dataBufferCfg;\r\n                dataBuffer01.clearVertex();\r\n                dataBuffer01.clearColor();\r\n                dataBuffer01.clearFace();\r\n                dataBuffer01.clearUV();\r\n                // const sphere = GeometryTools.ribbon_from_line(points);\r\n                const sphere = MouseTrial.ribbon_from_line2(this.points, 90, undefined, this.weightFunction, this.canvasWidth / this.canvasHeight);\r\n                if (sphere) {\r\n                    if (sphere.vertexs3D) {\r\n                        sphere.vertexs3D.forEach((vertex, index, arr) => {\r\n                            dataBuffer01.addVertex(vertex[0], vertex[1], vertex[2]);\r\n                            dataBuffer01.addColor(0.8, 0, 0, 1 - (index / (arr.length / 2) - Math.floor(index / (arr.length / 2))));\r\n                            if (index < arr.length / 2) {\r\n                                dataBuffer01.addUV(0, index % 2);\r\n                            }\r\n                            else {\r\n                                dataBuffer01.addUV(1, index % 2);\r\n                            }\r\n                        });\r\n                    }\r\n                    sphere.faces.forEach((face) => {\r\n                        dataBuffer01.addFace(face[0], face[1], face[2]);\r\n                    });\r\n                }\r\n                dataBuffer01.update(this.gl);\r\n            }\r\n        };\r\n        this.moveCall = (e) => {\r\n            if (this.downFlag) {\r\n                this.currX = (e.clientX - this.canvasWidth / 2) / this.canvasWidth * 2;\r\n                this.currY = -(e.clientY - this.canvasHeight / 2) / this.canvasHeight * 2;\r\n            }\r\n        };\r\n        this.upCall = (e) => {\r\n            this.downFlag = false;\r\n        };\r\n        this.downCall = (e) => {\r\n            this.downFlag = true;\r\n            this.currX = (e.clientX - this.canvasWidth / 2) / this.canvasWidth * 2;\r\n            this.currY = -(e.clientY - this.canvasHeight / 2) / this.canvasHeight * 2;\r\n            this.historyX.length = 0;\r\n            this.historyY.length = 0;\r\n            // Create history array.\r\n            for (let i = 0; i < this.historySize; i++) {\r\n                this.historyX.push(this.currX);\r\n                this.historyY.push(this.currY);\r\n            }\r\n            this.update();\r\n        };\r\n        this.mesh = mesh;\r\n        this.gl = gl;\r\n        this.canvasWidth = canvasWidth;\r\n        this.canvasHeight = canvasHeight;\r\n        // Create rope points.\r\n        for (let i = 0; i < this.ropeSize; i++) {\r\n            this.points.push([0, 0]);\r\n        }\r\n        // Create history array.\r\n        for (let i = 0; i < this.historySize; i++) {\r\n            this.historyX.push(0);\r\n            this.historyY.push(0);\r\n        }\r\n    }\r\n    // 三次插值线条\r\n    static cubicInterpolation(array, t, tangentFactor) {\r\n        if (tangentFactor == null) {\r\n            tangentFactor = 1;\r\n        }\r\n        const k = Math.floor(t);\r\n        const m = [MouseTrial.getTangent(k, tangentFactor, array), MouseTrial.getTangent(k + 1, tangentFactor, array)];\r\n        const p = [MouseTrial.clipInput(k, array), MouseTrial.clipInput(k + 1, array)];\r\n        t -= k;\r\n        const t2 = t * t;\r\n        const t3 = t * t2;\r\n        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];\r\n    }\r\n    static getTangent(k, factor, array) {\r\n        return factor * (MouseTrial.clipInput(k + 1, array) - MouseTrial.clipInput(k - 1, array)) / 2;\r\n    }\r\n    /**\r\n     * Cubic interpolation based on https://github.com/osuushi/Smooth.js\r\n     */\r\n    static clipInput(k, arr) {\r\n        if (k < 0) {\r\n            k = 0;\r\n        }\r\n        if (k > arr.length - 1) {\r\n            k = arr.length - 1;\r\n        }\r\n        return arr[k];\r\n    }\r\n    // 插值线条结果创建丝带顶点/三角形数据\r\n    static ribbon_from_line2(points, deltaAngle, deltaAngleFunction, weightFunction, widthScaleHeight = 1) {\r\n        const result = {\r\n            vertexs3D: [],\r\n            faces: []\r\n        };\r\n        const detailCount = points.length;\r\n        if (detailCount < 2) {\r\n            return;\r\n        }\r\n        let cos = 0, sin = 0, deltaCos = 0, deltaSin = 0, deltaXY = 0, deltaX = 0, deltaY = 0, prePoint = [points[0][0], points[0][1]], nxtPoint = [points[0][0], points[0][1]];\r\n        let currDeltaAngle;\r\n        let deltaDistance = 0;\r\n        let lastTempPoint = [points[0][0], points[0][1]];\r\n        for (let i = 1; i < detailCount; i++) {\r\n            nxtPoint = points[i];\r\n            deltaX = nxtPoint[0] - prePoint[0];\r\n            deltaY = nxtPoint[1] - prePoint[1];\r\n            deltaXY = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n            cos = deltaXY === 0 ? 0 : deltaX / deltaXY;\r\n            sin = deltaXY === 0 ? 0 : deltaY / deltaXY;\r\n            currDeltaAngle = deltaAngleFunction ? deltaAngle * deltaAngleFunction((i - 1) / detailCount) : deltaAngle;\r\n            deltaCos = Math.cos(Math.PI * currDeltaAngle / 180);\r\n            deltaSin = Math.sin(Math.PI * currDeltaAngle / 180);\r\n            deltaDistance = weightFunction ? weightFunction(i / detailCount) : 0.01;\r\n            // if (deltaXY > deltaDistance) {\r\n            if (result.vertexs3D) {\r\n                result.vertexs3D[i - 1] = [\r\n                    (cos * deltaCos - sin * deltaSin) * deltaDistance / widthScaleHeight + prePoint[0],\r\n                    (sin * deltaCos + cos * deltaSin) * deltaDistance + prePoint[1],\r\n                    0\r\n                ];\r\n                result.vertexs3D[i - 1 + detailCount] = [\r\n                    (cos * deltaCos + sin * deltaSin) * deltaDistance / widthScaleHeight + prePoint[0],\r\n                    (sin * deltaCos - cos * deltaSin) * deltaDistance + prePoint[1],\r\n                    0\r\n                ];\r\n            }\r\n            lastTempPoint = prePoint;\r\n            // } else {\r\n            //     if (result.vertexs3D) {\r\n            //         result.vertexs3D[i - 1] = [\r\n            //             (cos * deltaCos - sin * deltaSin) * deltaDistance + lastTempPoint[0],\r\n            //             (sin * deltaCos + cos * deltaSin) * deltaDistance + lastTempPoint[1],\r\n            //             0\r\n            //         ];\r\n            //         result.vertexs3D[i - 1 + detailCount] = [\r\n            //             (cos * deltaCos + sin * deltaSin) * deltaDistance + lastTempPoint[0],\r\n            //             (sin * deltaCos - cos * deltaSin) * deltaDistance + lastTempPoint[1],\r\n            //             0\r\n            //         ];\r\n            //     }\r\n            // }\r\n            prePoint = points[i];\r\n        }\r\n        deltaCos = Math.cos(Math.PI * 45 / 180);\r\n        deltaSin = Math.sin(Math.PI * 45 / 180);\r\n        if (result.vertexs3D) {\r\n            result.vertexs3D[detailCount - 1] = [\r\n                (cos * deltaCos - sin * deltaSin) * deltaXY / widthScaleHeight + prePoint[0],\r\n                (sin * deltaSin + cos * deltaCos) * deltaXY + prePoint[1],\r\n                0\r\n            ];\r\n            result.vertexs3D[detailCount - 1 + detailCount] = [\r\n                (cos * deltaCos + sin * deltaSin) * deltaXY / widthScaleHeight + prePoint[0],\r\n                (sin * deltaSin - cos * deltaCos) * deltaXY + prePoint[1],\r\n                0\r\n            ];\r\n        }\r\n        result.faces = this.sphereRibbon(0, detailCount);\r\n        return result;\r\n    }\r\n    // 丝带三角形数据\r\n    static sphereRibbon(pointStartIndex, pointCount) {\r\n        const faces = [];\r\n        for (let i = 0; i < pointCount - 1; i++) {\r\n            faces.push([\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1,\r\n                pointStartIndex + i + 1 + pointCount\r\n            ], [\r\n                pointStartIndex + i,\r\n                pointStartIndex + i + 1 + pointCount,\r\n                pointStartIndex + i + pointCount\r\n            ]);\r\n        }\r\n        return faces;\r\n    }\r\n}\r\n// ########################################################################\r\n// Demo\r\nconst canvas = document.getElementById('your_canvas');\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\n// 创建渲染 - 可以是其他渲染引擎\r\nconst mesh = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].active(canvas, null);\r\n// 渲染循环\r\n_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.renderLoop = (timestamp) => {\r\n    _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.clearColor();\r\n    _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].scene.viewport[0] = 0;\r\n    _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].scene.viewport[1] = 0;\r\n    _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].scene.viewport[2] = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.width;\r\n    _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].scene.viewport[3] = _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.height;\r\n    _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].scene.render(true);\r\n};\r\n_render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.loop(0);\r\n// 启动拖尾模块\r\nconst MouseTrial0 = new MouseTrial(mesh, _render_launcher__WEBPACK_IMPORTED_MODULE_0__[\"RenderLauncher\"].webgldemo.gl, canvas.width, canvas.height);\r\n// 拖尾数据更新 - 如果没有操作，点数据将向最后的位置收缩\r\nsetInterval(MouseTrial0.update, 16);\r\ncanvas.addEventListener('pointerdown', MouseTrial0.downCall);\r\ncanvas.addEventListener('pointerup', MouseTrial0.upCall);\r\ncanvas.addEventListener('pointermove', MouseTrial0.moveCall);\r\n// setInterval(() => {\r\n//     // bar.onProcess('', '', 0, Math.abs(Math.sin(Date.now() / 5000) * 100), undefined);\r\n// }, 50);\r\n\n\n//# sourceURL=webpack:///./mouse_ribbon/native/mouse_move_ribbon/main.ts?");

/***/ }),

/***/ "./mouse_ribbon/native/mouse_move_ribbon/render_launcher.ts":
/*!******************************************************************!*\
  !*** ./mouse_ribbon/native/mouse_move_ribbon/render_launcher.ts ***!
  \******************************************************************/
/*! exports provided: RenderLauncher */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RenderLauncher\", function() { return RenderLauncher; });\n/* harmony import */ var _lib_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/webgl */ \"./mouse_ribbon/native/lib/webgl.ts\");\n/* harmony import */ var _lib_shader_ribbon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/shader_ribbon */ \"./mouse_ribbon/native/lib/shader_ribbon.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/math */ \"./mouse_ribbon/math/math.ts\");\n\r\n\r\n\r\nclass RenderLauncher {\r\n    static active(canvas, args) {\r\n        return RenderLauncher.simple(canvas, args);\r\n    }\r\n    static puase() {\r\n    }\r\n    static destroy() {\r\n        if (RenderLauncher.webgldemo && !RenderLauncher.webgldemo.isDestroy) {\r\n            RenderLauncher.webgldemo.destroy();\r\n            RenderLauncher.webgldemo = null;\r\n        }\r\n    }\r\n    static simple(canvas, args) {\r\n        const opt = {};\r\n        opt.canvas = canvas;\r\n        RenderLauncher.webgldemo = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"WebGLInstance\"](opt);\r\n        _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"TextureInstance\"].loadCall = RenderLauncher.createTextureLoad;\r\n        const webgldemo = RenderLauncher.webgldemo;\r\n        if (!RenderLauncher.webgldemo.gl) {\r\n            return;\r\n        }\r\n        const shader01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"ShaderCfg\"]('01', _lib_shader_ribbon__WEBPACK_IMPORTED_MODULE_1__[\"vs_ribbon\"], _lib_shader_ribbon__WEBPACK_IMPORTED_MODULE_1__[\"fs_ribbon\"]);\r\n        this.scene = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]('01', webgldemo);\r\n        const dataBuffer01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"DataBufferCfg\"]('01');\r\n        const mesh01 = new _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]('mesh01', dataBuffer01, shader01);\r\n        mesh01.rotate[0] = 1.57;\r\n        mesh01.triangleFrame = true;\r\n        // mesh01.texture = RenderLauncher.webgldemo.createTexture('/resources/alpha.png');\r\n        RenderLauncher.mesh = mesh01;\r\n        this.scene.addMesh(mesh01);\r\n        return mesh01;\r\n    }\r\n}\r\nRenderLauncher.opt = {};\r\nRenderLauncher.loadImageSucc = (img, fname) => {\r\n    _lib_webgl__WEBPACK_IMPORTED_MODULE_0__[\"TextureInstance\"].loaded(img, fname, RenderLauncher.webgldemo);\r\n};\r\nRenderLauncher.createTextureLoad = (fname, engine, cb) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n        const width = _math_math__WEBPACK_IMPORTED_MODULE_2__[\"MathTools\"].nextPowerOfTwo(img.width);\r\n        const height = _math_math__WEBPACK_IMPORTED_MODULE_2__[\"MathTools\"].nextPowerOfTwo(img.height);\r\n        if (img.width !== width || img.height !== height) {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            // document.body.appendChild(canvas);\r\n            const ctx = canvas.getContext('2d');\r\n            ctx.drawImage(img, 0, 0, width, height);\r\n            ctx.save();\r\n            RenderLauncher.loadImageSucc(canvas, fname);\r\n        }\r\n        else {\r\n            RenderLauncher.loadImageSucc(img, fname);\r\n        }\r\n        // setTimeout(() => { loadImageSucc(img, data.fname); }, 2000);\r\n    };\r\n    img.src = fname;\r\n};\r\n\n\n//# sourceURL=webpack:///./mouse_ribbon/native/mouse_move_ribbon/render_launcher.ts?");

/***/ })

/******/ });