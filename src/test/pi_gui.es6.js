
_$pi.define("pi_gui/gui/combine_image/combine", ["require", "exports", "../../../pi_sys/modules/util/util", "../../../pi_sys/load/app"], function (require, exports, util_1, app_1) {
    "use strict";
    
    class CombineImageMgr {
        /**
         *
         * @param jsonFile 目标配置项目内全路径 <depend 中路径>
         * @param cfg 目标 json 数据，
         * [
         * 		[合并图片1宽度, 合并图片2宽度..],
         * 		[[合并成功源图片1 url, x, y, w, h, index], [合并成功源图片2 url, x, y, w, h, index]..],
         * 		[[合并失败源图片1 url, index, w, h], [合并失败源图片2 url, index, w, h]..]
         * ]
         */
        static register(url, cfg) {
            const wh = cfg[0];
            const success = cfg[1];
            const fail = cfg[2];
            let isPng;
            if (url.endsWith("jpg.imgcfg")) {
                url = url.replace("jpg.imgcfg", "");
                isPng = false;
            }
            else {
                url = url.replace("png.imgcfg", "");
                isPng = true;
            }
            for (var successValue of success) {
                this.combineCfg[successValue[0]] = {
                    left: successValue[1],
                    top: successValue[2],
                    srcWidth: successValue[3],
                    srcHeight: successValue[4],
                    isPng: successValue[0].endsWith('.png'),
                    url: url + successValue[5] + ".combine." + (isPng ? "png" : "jpg"),
                    width: wh[successValue[5] - 1],
                    height: wh[successValue[5] - 1],
                };
            }
            for (var failValue of fail) {
                this.combineCfg[failValue[0]] = {
                    left: 0,
                    top: 0,
                    srcWidth: failValue[2],
                    srcHeight: failValue[3],
                    isPng: failValue[0].endsWith('.png'),
                    url: url + failValue[1] + ".combine_fail." + (isPng ? "png" : "jpg"),
                    width: failValue[2],
                    height: failValue[3],
                };
            }
        }
        /**
         * 获取目标图片的图片集信息
         * @param srcImgUrl 目标图片项目内全路径 <depend 中路径>
         * @returns [w, h, x, y, 合并后图片路径]
         */
        static getImageDecs(srcImgUrl) {
            const imgCfg = this.combineCfg[srcImgUrl];
            if (imgCfg) {
                return {
                    left: imgCfg.left,
                    top: imgCfg.top,
                    srcWidth: imgCfg.srcWidth,
                    srcHeight: imgCfg.srcHeight,
                    isPng: imgCfg.isPng,
                    url: imgCfg.url,
                    width: imgCfg.width,
                    height: imgCfg.height,
                };
            }
            else {
                return null;
            }
        }
        /**
         * 获取目标图片的图片集信息
         * @param srcImgUrl 目标图片项目内全路径 <depend 中路径>
         * @returns [w, h, x, y, 合并后图片路径]
         */
        static addImageDecs(url, decs) {
            this.combineCfg[url] = decs;
        }
    }
    exports.CombineImageMgr = CombineImageMgr;
    CombineImageMgr.combineCfg = {};
    exports.C_IMAGE_SUFF = "imgcfg";
    exports.initCombineImageCfg = () => {
        // 初始化图片的合并配置
        app_1.setCfgHandler(exports.C_IMAGE_SUFF, (file, data) => {
            return new Promise((resolve, _reject) => {
                CombineImageMgr.register(file, JSON.parse(util_1.utf8Decode(data)));
                resolve(null);
            });
        });
    };
});

_$pi.define("pi_gui/gui/gui/enum", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     */
    var YGAlign;
    (function (YGAlign) {
        YGAlign[YGAlign["YGAlignAuto"] = 0] = "YGAlignAuto";
        YGAlign[YGAlign["YGAlignFlexStart"] = 1] = "YGAlignFlexStart";
        YGAlign[YGAlign["YGAlignCenter"] = 2] = "YGAlignCenter";
        YGAlign[YGAlign["YGAlignFlexEnd"] = 3] = "YGAlignFlexEnd";
        YGAlign[YGAlign["YGAlignStretch"] = 4] = "YGAlignStretch";
        YGAlign[YGAlign["YGAlignBaseline"] = 5] = "YGAlignBaseline";
        YGAlign[YGAlign["YGAlignSpaceBetween"] = 6] = "YGAlignSpaceBetween";
        YGAlign[YGAlign["YGAlignSpaceAround"] = 7] = "YGAlignSpaceAround";
    })(YGAlign = exports.YGAlign || (exports.YGAlign = {}));
    var YGDimension;
    (function (YGDimension) {
        YGDimension[YGDimension["YGDimensionWidth"] = 0] = "YGDimensionWidth";
        YGDimension[YGDimension["YGDimensionHeight"] = 1] = "YGDimensionHeight";
    })(YGDimension = exports.YGDimension || (exports.YGDimension = {}));
    var YGDirection;
    (function (YGDirection) {
        YGDirection[YGDirection["YGDirectionInherit"] = 0] = "YGDirectionInherit";
        YGDirection[YGDirection["YGDirectionLTR"] = 1] = "YGDirectionLTR";
        YGDirection[YGDirection["YGDirectionRTL"] = 2] = "YGDirectionRTL";
    })(YGDirection = exports.YGDirection || (exports.YGDirection = {}));
    var YGDisplay;
    (function (YGDisplay) {
        YGDisplay[YGDisplay["YGDisplayFlex"] = 0] = "YGDisplayFlex";
        YGDisplay[YGDisplay["YGDisplayNone"] = 1] = "YGDisplayNone";
    })(YGDisplay = exports.YGDisplay || (exports.YGDisplay = {}));
    var YGEdge;
    (function (YGEdge) {
        YGEdge[YGEdge["YGEdgeLeft"] = 0] = "YGEdgeLeft";
        YGEdge[YGEdge["YGEdgeTop"] = 1] = "YGEdgeTop";
        YGEdge[YGEdge["YGEdgeRight"] = 2] = "YGEdgeRight";
        YGEdge[YGEdge["YGEdgeBottom"] = 3] = "YGEdgeBottom";
        YGEdge[YGEdge["YGEdgeStart"] = 4] = "YGEdgeStart";
        YGEdge[YGEdge["YGEdgeEnd"] = 5] = "YGEdgeEnd";
        YGEdge[YGEdge["YGEdgeHorizontal"] = 6] = "YGEdgeHorizontal";
        YGEdge[YGEdge["YGEdgeVertical"] = 7] = "YGEdgeVertical";
        YGEdge[YGEdge["YGEdgeAll"] = 8] = "YGEdgeAll";
    })(YGEdge = exports.YGEdge || (exports.YGEdge = {}));
    var YGExperimentalFeature;
    (function (YGExperimentalFeature) {
        YGExperimentalFeature[YGExperimentalFeature["YGExperimentalFeatureWebFlexBasis"] = 0] = "YGExperimentalFeatureWebFlexBasis";
    })(YGExperimentalFeature = exports.YGExperimentalFeature || (exports.YGExperimentalFeature = {}));
    var YGFlexDirection;
    (function (YGFlexDirection) {
        YGFlexDirection[YGFlexDirection["YGFlexDirectionColumn"] = 0] = "YGFlexDirectionColumn";
        YGFlexDirection[YGFlexDirection["YGFlexDirectionColumnReverse"] = 1] = "YGFlexDirectionColumnReverse";
        YGFlexDirection[YGFlexDirection["YGFlexDirectionRow"] = 2] = "YGFlexDirectionRow";
        YGFlexDirection[YGFlexDirection["YGFlexDirectionRowReverse"] = 3] = "YGFlexDirectionRowReverse";
    })(YGFlexDirection = exports.YGFlexDirection || (exports.YGFlexDirection = {}));
    var YGJustify;
    (function (YGJustify) {
        YGJustify[YGJustify["YGJustifyFlexStart"] = 0] = "YGJustifyFlexStart";
        YGJustify[YGJustify["YGJustifyCenter"] = 1] = "YGJustifyCenter";
        YGJustify[YGJustify["YGJustifyFlexEnd"] = 2] = "YGJustifyFlexEnd";
        YGJustify[YGJustify["YGJustifySpaceBetween"] = 3] = "YGJustifySpaceBetween";
        YGJustify[YGJustify["YGJustifySpaceAround"] = 4] = "YGJustifySpaceAround";
        YGJustify[YGJustify["YGJustifySpaceEvenly"] = 5] = "YGJustifySpaceEvenly";
    })(YGJustify = exports.YGJustify || (exports.YGJustify = {}));
    var YGLogLevel;
    (function (YGLogLevel) {
        YGLogLevel[YGLogLevel["YGLogLevelError"] = 0] = "YGLogLevelError";
        YGLogLevel[YGLogLevel["YGLogLevelWarn"] = 1] = "YGLogLevelWarn";
        YGLogLevel[YGLogLevel["YGLogLevelInfo"] = 2] = "YGLogLevelInfo";
        YGLogLevel[YGLogLevel["YGLogLevelDebug"] = 3] = "YGLogLevelDebug";
        YGLogLevel[YGLogLevel["YGLogLevelVerbose"] = 4] = "YGLogLevelVerbose";
        YGLogLevel[YGLogLevel["YGLogLevelFatal"] = 5] = "YGLogLevelFatal";
    })(YGLogLevel = exports.YGLogLevel || (exports.YGLogLevel = {}));
    var YGMeasureMode;
    (function (YGMeasureMode) {
        YGMeasureMode[YGMeasureMode["YGMeasureModeUndefined"] = 0] = "YGMeasureModeUndefined";
        YGMeasureMode[YGMeasureMode["YGMeasureModeExactly"] = 1] = "YGMeasureModeExactly";
        YGMeasureMode[YGMeasureMode["YGMeasureModeAtMost"] = 2] = "YGMeasureModeAtMost";
    })(YGMeasureMode = exports.YGMeasureMode || (exports.YGMeasureMode = {}));
    var YGNodeType;
    (function (YGNodeType) {
        YGNodeType[YGNodeType["YGNodeTypeDefault"] = 0] = "YGNodeTypeDefault";
        YGNodeType[YGNodeType["YGNodeTypeText"] = 1] = "YGNodeTypeText";
    })(YGNodeType = exports.YGNodeType || (exports.YGNodeType = {}));
    var YGOverflow;
    (function (YGOverflow) {
        YGOverflow[YGOverflow["YGOverflowVisible"] = 0] = "YGOverflowVisible";
        YGOverflow[YGOverflow["YGOverflowHidden"] = 1] = "YGOverflowHidden";
        YGOverflow[YGOverflow["YGOverflowScroll"] = 2] = "YGOverflowScroll";
    })(YGOverflow = exports.YGOverflow || (exports.YGOverflow = {}));
    var YGPositionType;
    (function (YGPositionType) {
        YGPositionType[YGPositionType["YGPositionTypeRelative"] = 0] = "YGPositionTypeRelative";
        YGPositionType[YGPositionType["YGPositionTypeAbsolute"] = 1] = "YGPositionTypeAbsolute";
    })(YGPositionType = exports.YGPositionType || (exports.YGPositionType = {}));
    var YGPrintOptions;
    (function (YGPrintOptions) {
        YGPrintOptions[YGPrintOptions["YGPrintOptionsLayout"] = 1] = "YGPrintOptionsLayout";
        YGPrintOptions[YGPrintOptions["YGPrintOptionsStyle"] = 2] = "YGPrintOptionsStyle";
        YGPrintOptions[YGPrintOptions["YGPrintOptionsChildren"] = 4] = "YGPrintOptionsChildren";
    })(YGPrintOptions = exports.YGPrintOptions || (exports.YGPrintOptions = {}));
    var YGUnit;
    (function (YGUnit) {
        YGUnit[YGUnit["YGUnitUndefined"] = 0] = "YGUnitUndefined";
        YGUnit[YGUnit["YGUnitPoint"] = 1] = "YGUnitPoint";
        YGUnit[YGUnit["YGUnitPercent"] = 2] = "YGUnitPercent";
        YGUnit[YGUnit["YGUnitAuto"] = 3] = "YGUnitAuto";
    })(YGUnit = exports.YGUnit || (exports.YGUnit = {}));
    var YGWrap;
    (function (YGWrap) {
        YGWrap[YGWrap["YGWrapNoWrap"] = 0] = "YGWrapNoWrap";
        YGWrap[YGWrap["YGWrapWrap"] = 1] = "YGWrapWrap";
        YGWrap[YGWrap["YGWrapWrapReverse"] = 2] = "YGWrapWrapReverse";
    })(YGWrap = exports.YGWrap || (exports.YGWrap = {}));
    var EnabledTypes;
    (function (EnabledTypes) {
        EnabledTypes[EnabledTypes["auto"] = 0] = "auto";
        EnabledTypes[EnabledTypes["none"] = 1] = "none";
        EnabledTypes[EnabledTypes["visible"] = 2] = "visible";
    })(EnabledTypes = exports.EnabledTypes || (exports.EnabledTypes = {}));
    var LengthUnitType;
    (function (LengthUnitType) {
        LengthUnitType[LengthUnitType["Pixel"] = 0] = "Pixel";
        LengthUnitType[LengthUnitType["Percent"] = 1] = "Percent";
        LengthUnitType[LengthUnitType["Auto"] = 2] = "Auto";
    })(LengthUnitType = exports.LengthUnitType || (exports.LengthUnitType = {}));
    var Opacity;
    (function (Opacity) {
        Opacity[Opacity["Opaque"] = 0] = "Opaque";
        Opacity[Opacity["Translucent"] = 1] = "Translucent";
        Opacity[Opacity["Transparent"] = 2] = "Transparent";
    })(Opacity = exports.Opacity || (exports.Opacity = {}));
    var RadialGradientShapes;
    (function (RadialGradientShapes) {
        RadialGradientShapes[RadialGradientShapes["circle"] = 0] = "circle";
        RadialGradientShapes[RadialGradientShapes["ellipse"] = 1] = "ellipse";
    })(RadialGradientShapes = exports.RadialGradientShapes || (exports.RadialGradientShapes = {}));
    var RadialGradientSize;
    (function (RadialGradientSize) {
        RadialGradientSize[RadialGradientSize["ClosestSide"] = 0] = "ClosestSide";
        RadialGradientSize[RadialGradientSize["FarthestSide"] = 1] = "FarthestSide";
        RadialGradientSize[RadialGradientSize["ClosestCorner"] = 2] = "ClosestCorner";
        RadialGradientSize[RadialGradientSize["Farthestcorner"] = 3] = "Farthestcorner";
    })(RadialGradientSize = exports.RadialGradientSize || (exports.RadialGradientSize = {}));
    var FitTypes;
    (function (FitTypes) {
        FitTypes[FitTypes["None"] = 0] = "None";
        FitTypes[FitTypes["Fill"] = 1] = "Fill";
        FitTypes[FitTypes["Contain"] = 2] = "Contain";
        FitTypes[FitTypes["Cover"] = 3] = "Cover";
        FitTypes[FitTypes["ScaleDown"] = 4] = "ScaleDown";
    })(FitTypes = exports.FitTypes || (exports.FitTypes = {}));
    var UndefinedType;
    (function (UndefinedType) {
        // decorate
        UndefinedType[UndefinedType["BorderColor"] = 0] = "BorderColor";
        UndefinedType[UndefinedType["BorderRadius"] = 1] = "BorderRadius";
        UndefinedType[UndefinedType["BoxShadowColor"] = 2] = "BoxShadowColor";
        UndefinedType[UndefinedType["BoxShadowH"] = 3] = "BoxShadowH";
        UndefinedType[UndefinedType["BoxShadowV"] = 4] = "BoxShadowV";
        // BoxShadowBlur, 暂不支持
        UndefinedType[UndefinedType["BackgroundColor"] = 5] = "BackgroundColor";
        //
        UndefinedType[UndefinedType["Opacity"] = 6] = "Opacity";
        UndefinedType[UndefinedType["Overflow"] = 7] = "Overflow";
        UndefinedType[UndefinedType["Visibility"] = 8] = "Visibility";
        // 变换
        UndefinedType[UndefinedType["TransformRotate"] = 9] = "TransformRotate";
        UndefinedType[UndefinedType["TransformScale"] = 10] = "TransformScale";
        UndefinedType[UndefinedType["TransformScaleX"] = 11] = "TransformScaleX";
        UndefinedType[UndefinedType["TransformScaleY"] = 12] = "TransformScaleY";
        UndefinedType[UndefinedType["TransformTranslate"] = 13] = "TransformTranslate";
        UndefinedType[UndefinedType["TransformTranslateX"] = 14] = "TransformTranslateX";
        UndefinedType[UndefinedType["TransformTranslateY"] = 15] = "TransformTranslateY";
        // 布局
        UndefinedType[UndefinedType["AlignContent"] = 16] = "AlignContent";
        UndefinedType[UndefinedType["JustifyContent"] = 17] = "JustifyContent";
        UndefinedType[UndefinedType["FlexDirection"] = 18] = "FlexDirection";
        UndefinedType[UndefinedType["FlexWrap"] = 19] = "FlexWrap";
        UndefinedType[UndefinedType["FlexGrow"] = 20] = "FlexGrow";
        UndefinedType[UndefinedType["FlexShrink"] = 21] = "FlexShrink";
        UndefinedType[UndefinedType["FlexBasis"] = 22] = "FlexBasis";
        UndefinedType[UndefinedType["AlignSelf"] = 23] = "AlignSelf";
        UndefinedType[UndefinedType["Left"] = 24] = "Left";
        UndefinedType[UndefinedType["Top"] = 25] = "Top";
        UndefinedType[UndefinedType["Right"] = 26] = "Right";
        UndefinedType[UndefinedType["Bottom"] = 27] = "Bottom";
        UndefinedType[UndefinedType["Width"] = 28] = "Width";
        UndefinedType[UndefinedType["Height"] = 29] = "Height";
        UndefinedType[UndefinedType["MaxWidth"] = 30] = "MaxWidth";
        UndefinedType[UndefinedType["MaxHeight"] = 31] = "MaxHeight";
        UndefinedType[UndefinedType["MinWidth"] = 32] = "MinWidth";
        UndefinedType[UndefinedType["MinHeight"] = 33] = "MinHeight";
        UndefinedType[UndefinedType["PaddingLeft"] = 34] = "PaddingLeft";
        UndefinedType[UndefinedType["PaddingTop"] = 35] = "PaddingTop";
        UndefinedType[UndefinedType["PaddingRight"] = 36] = "PaddingRight";
        UndefinedType[UndefinedType["PaddingBottom"] = 37] = "PaddingBottom";
        UndefinedType[UndefinedType["MarginLeft"] = 38] = "MarginLeft";
        UndefinedType[UndefinedType["MarginTop"] = 39] = "MarginTop";
        UndefinedType[UndefinedType["MarginRight"] = 40] = "MarginRight";
        UndefinedType[UndefinedType["MarginBottom"] = 41] = "MarginBottom";
    })(UndefinedType = exports.UndefinedType || (exports.UndefinedType = {}));
    /**
     */
    var VerticalAlign;
    (function (VerticalAlign) {
        VerticalAlign[VerticalAlign["Center"] = 0] = "Center";
        VerticalAlign[VerticalAlign["Top"] = 1] = "Top";
        VerticalAlign[VerticalAlign["Bootom"] = 2] = "Bootom";
        VerticalAlign[VerticalAlign["Undefined"] = 3] = "Undefined";
    })(VerticalAlign = exports.VerticalAlign || (exports.VerticalAlign = {}));
    /**
     */
    var TextDirection;
    (function (TextDirection) {
        TextDirection[TextDirection["Left"] = 0] = "Left";
        TextDirection[TextDirection["Right"] = 1] = "Right";
        TextDirection[TextDirection["Top"] = 2] = "Top";
        TextDirection[TextDirection["Bootom"] = 3] = "Bootom";
        TextDirection[TextDirection["Undefined"] = 4] = "Undefined";
    })(TextDirection = exports.TextDirection || (exports.TextDirection = {}));
    /**
     */
    var TextAlign;
    (function (TextAlign) {
        TextAlign[TextAlign["Left"] = 0] = "Left";
        TextAlign[TextAlign["Right"] = 1] = "Right";
        TextAlign[TextAlign["Center"] = 2] = "Center";
        TextAlign[TextAlign["Justify"] = 3] = "Justify";
        TextAlign[TextAlign["Undefined"] = 4] = "Undefined";
    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
    /**
     */
    var WhiteSpace;
    (function (WhiteSpace) {
        WhiteSpace[WhiteSpace["Normal"] = 0] = "Normal";
        WhiteSpace[WhiteSpace["Nowrap"] = 1] = "Nowrap";
        WhiteSpace[WhiteSpace["PreWrap"] = 2] = "PreWrap";
        WhiteSpace[WhiteSpace["Pre"] = 3] = "Pre";
        WhiteSpace[WhiteSpace["PreLine"] = 4] = "PreLine";
        WhiteSpace[WhiteSpace["Undefined"] = 5] = "Undefined";
    })(WhiteSpace = exports.WhiteSpace || (exports.WhiteSpace = {}));
    /**
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["Normal"] = 0] = "Normal";
        FontStyle[FontStyle["Ttalic"] = 1] = "Ttalic";
        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
        FontStyle[FontStyle["Undefined"] = 3] = "Undefined";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     */
    var FontWeight;
    (function (FontWeight) {
        FontWeight[FontWeight["Normal"] = 600] = "Normal";
        FontWeight[FontWeight["Bold"] = 700] = "Bold";
        FontWeight[FontWeight["Bolder"] = 900] = "Bolder";
        FontWeight[FontWeight["Lighter"] = 300] = "Lighter";
        FontWeight[FontWeight["One"] = 100] = "One";
        FontWeight[FontWeight["Two"] = 200] = "Two";
        FontWeight[FontWeight["Three"] = 300] = "Three";
        FontWeight[FontWeight["Four"] = 400] = "Four";
        FontWeight[FontWeight["Five"] = 500] = "Five";
        FontWeight[FontWeight["Six"] = 600] = "Six";
        FontWeight[FontWeight["Seven"] = 700] = "Seven";
        FontWeight[FontWeight["Eight"] = 800] = "Eight";
        FontWeight[FontWeight["Nine"] = 900] = "Nine";
        FontWeight[FontWeight["Undefined"] = 500] = "Undefined";
    })(FontWeight = exports.FontWeight || (exports.FontWeight = {}));
    /**
     */
    var FontSizeType;
    (function (FontSizeType) {
        //   Medium,
        //   XXSmall,
        //   XSmall,
        //   Small,
        //   Large,
        //   XLarge,
        //   XXLarge,
        //   Smaller,
        //   Larger,
        FontSizeType[FontSizeType["Length"] = 0] = "Length";
        FontSizeType[FontSizeType["Percent"] = 1] = "Percent";
        //   Undefined,
    })(FontSizeType = exports.FontSizeType || (exports.FontSizeType = {}));
    var ClipPathBasicShapeType;
    (function (ClipPathBasicShapeType) {
        ClipPathBasicShapeType[ClipPathBasicShapeType["Polygon"] = 0] = "Polygon";
        ClipPathBasicShapeType[ClipPathBasicShapeType["Circle"] = 1] = "Circle"; // 暂不支持
    })(ClipPathBasicShapeType = exports.ClipPathBasicShapeType || (exports.ClipPathBasicShapeType = {}));
    var ClipPathGeometryBoxType;
    (function (ClipPathGeometryBoxType) {
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["MarginBox"] = 0] = "MarginBox";
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["BorderBox"] = 1] = "BorderBox";
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["PaddingBox"] = 2] = "PaddingBox";
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["ContentBox"] = 3] = "ContentBox";
    })(ClipPathGeometryBoxType = exports.ClipPathGeometryBoxType || (exports.ClipPathGeometryBoxType = {}));
    var BorderImageRepeat;
    (function (BorderImageRepeat) {
        BorderImageRepeat[BorderImageRepeat["Stretch"] = 0] = "Stretch";
        BorderImageRepeat[BorderImageRepeat["Repeat"] = 1] = "Repeat";
        BorderImageRepeat[BorderImageRepeat["Round"] = 2] = "Round";
        BorderImageRepeat[BorderImageRepeat["Space"] = 3] = "Space"; // 源图像的边缘区域被平铺（重复）以填充每个边界之间的间隙。可以缩小瓷砖以实现适当的配合。
    })(BorderImageRepeat = exports.BorderImageRepeat || (exports.BorderImageRepeat = {}));
});

/**
 * * 处理 非 2 的 n 次幂图片
 * * 小游戏必须为 2 的 n 次幂
 */
_$pi.define("pi_gui/gui/gui/image_tools", ["require", "exports", "../../../pi_sys/modules/math/math"], function (require, exports, math_1) {
    "use strict";
    
    /**
     * 图片处理工具函数
     */
    // tslint:disable-next-line:no-unnecessary-class
    class ImageTools {
        /**
         * 检查尺寸 - 处理为 2 的 n 次幂尺寸
         * @param image 目标图片
         */
        static check(image) {
            // return image;
            const srcWidth = image.width;
            const srcHeight = image.height;
            let width, height;
            width = math_1.nextPowerOfTwo(srcWidth);
            height = math_1.nextPowerOfTwo(srcHeight);
            if (width === srcWidth && height === srcHeight) {
                return image;
            }
            else {
                const canvas = this.createCanvas(width, height);
                this.imageFillCanvas(image, canvas);
                // document.body.appendChild(canvas);
                return canvas;
            }
        }
        /**
         * 创建指定大小canvas
         * @param width 宽
         * @param height 高
         */
        static createCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        }
        /**
         * 绘制图片到目标画布
         * @param image 目标图片
         * @param canvas 目标canvas
         */
        static imageFillCanvas(image, canvas) {
            const ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
    }
    exports.ImageTools = ImageTools;
});

/**
 * 动画运行的数学方法
 * * tpl 中使用自定义函数方法:
 *      需要在 对应 widget create 中注册对应函数方法
 */
_$pi.define("pi_gui/gui/gui/math_tools", ["require", "exports"], function (require, exports) {
    "use strict";
    
    // tslint:disable-next-line:no-unnecessary-class
    class MathTools {
        /**
         * 初始化 数学工具函数库
         */
        // tslint:disable-next-line:function-name
        static Init() {
            MathTools.MathMap.set('linear', MathTools.linear);
            MathTools.MathMap.set('sin', MathTools.sin);
        }
        /**
         * y=x 的线性函数
         * @param x 自变量
         */
        static linear(x) {
            return x;
        }
        /**
         * y=sin(x) 的正弦函数
         * @param x 自变量
         */
        static sin(x) {
            return Math.sin(x);
        }
        /**
         * 注册 数学函数
         * @param fname 函数名称
         * @param f 函数方程
         */
        static register(fname, f) {
            MathTools.MathMap.set(fname, f);
        }
        /**
         * 使用 数学函数
         * @param fname 函数名称
         * @param x 自变量
         */
        static mathCall(fname, x) {
            const f = MathTools.MathMap.get(fname) || MathTools.MathMap.get('linear');
            return f(x);
        }
    }
    exports.MathTools = MathTools;
    /**
     * 数学工具函数库
     */
    MathTools.MathMap = new Map();
});

_$pi.define("pi_gui/gui/gui/shader_text", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     */
    exports.text_vs_shader_name = 'text_vs';
    exports.text_fs_shader_name = 'text_fs';
    exports.text_vs_code = `
    precision highp float;

    // Attributes
    attribute vec3 position;
    attribute vec2 uv0;
    #ifdef VERTEX_COLOR
    attribute vec4 color;
    #endif

    // Uniforms
    uniform mat4 worldMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectMatrix;
    uniform vec2 textureSize;

    #ifdef CLIP_BOX
        uniform vec4 clipBox;
    #endif

    // Varyings
    #ifdef VERTEX_COLOR
        varying vec4 vColor;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    varying vec2 vUV;

    void main() {
        vec4 p1 = viewMatrix * worldMatrix * vec4(position.x, position.y, 1.0, 1.0);
        vec4 p = projectMatrix * p1;
        gl_Position = vec4(p.x, p.y, worldMatrix[3].z, 1.0);

        #ifdef VERTEX_COLOR
            vColor = color;
        #endif

        // vUV = uv0;
        vUV = vec2(uv0.x/textureSize.x, uv0.y/textureSize.y);

        #ifdef CLIP_BOX
            vClipBox = vec2((p1.x - clipBox.x)/clipBox.z, (p1.y - clipBox.y)/clipBox.w);
        #endif
    }
`;
    exports.text_fs_code = `
    #extension GL_OES_standard_derivatives : enable

    precision highp float;

    #ifdef HSV
        /**
         * h: hue，色相，取值范围[-0.5, 0.5]，对应Photoshop的[-180, 180]
         *    + 注：最好不要越界，越界效果没有测试过，不保证正确性；
         *    + 注：基本能模拟PS的效果，最多只有1个像素值的误差
         *    + 比如：-0.3对应PS的 2 * -0.3 * 180 = -54度，PS的144度 对应 h的 144 * 0.5 / 180 = 0.4
         *
         * s：saturate，饱和度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 注：当PS中的s>0的时候，公式比较复杂，判断特别多，所以这里用了近似公式。不能完全模拟饱和度
         *    + 注：但是，当s<0的时候（变灰），基本能模拟PS的效果，最多只有1个像素值的误差
         *
         * v：brightness，明度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 比如：-0.3对应PS的-30，PS的60对应v=0.6
         */
        uniform vec3 hsvValue;
    #endif

    #ifdef CLIP
    uniform float clipIndices;
    uniform sampler2D clipTexture;
    uniform float clipTextureSize;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    // Varyings
    #ifdef VERTEX_COLOR
    varying vec4 vColor;
    #endif

    varying vec2 vUV;

    // Uniforms
    // uniform float uPxRange;

    uniform float alpha;
    uniform sampler2D texture;
    #ifdef STROKE
    uniform float strokeSize;
    uniform vec4 strokeColor;
    #endif
    #ifdef UCOLOR
    uniform vec4 uColor;
    #endif

    #ifdef HSV
        vec3 rgb2hsv(vec3 c)
        {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c)
        {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, vec3(0.0), vec3(1.0)), c.y);
        }
    #endif

    #ifdef CLIP
        // 8位int型变二进制数组
        void toBit(int num, out bvec4 r1, out bvec4 r2) {
            for (int i = 0; i < 4; ++i) {
                r1[i] = (num / 2) * 2 != num;
                num = (num - int(r1[i])) / 2;
            }

            for (int i = 0; i < 4; ++i) {
                r2[i] = (num / 2) * 2 != num;
                num = (num - int(r2[i])) / 2;
            }
        }

        // 做与运算，返回true表示通过
        bool bitAnd(in bvec4 a1, in bvec4 a2, in bvec4 b1, in bvec4 b2) {

            bvec4 v1 = bvec4(a1.x && b1.x, a1.y && b1.y, a1.z && b1.z, a1.w && b1.w);
            bvec4 v2 = bvec4(a2.x && b2.x, a2.y && b2.y, a2.z && b2.z, a2.w && b2.w);

            return v1 == bvec4(false) && v2 == bvec4(false);
        }
    #endif

    float median(float r, float g, float b) {
        return max(min(r, g), min(max(r, g), b));
    }

    void main() {

        #ifdef CLIP

            vec2 clipCoord = gl_FragCoord.xy / clipTextureSize;
            vec4 clipColor = texture2D(clipTexture, vec2(clipCoord));

            bvec4 m1, m2, i1, i2;
            bvec4 notM1, notM2;

            float remain = clipIndices;

            int b = int(remain / 128.0 / 128.0);
            remain = remain - float(b) * 128.0 * 128.0;
            int mask = int(clipColor.b * 256.0);

            toBit(mask, m1, m2);
            toBit(b, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int g = int(remain / 128.0);
            remain = remain - float(g) * 128.0;
            mask = int(clipColor.g * 256.0);

            toBit(mask, m1, m2);
            toBit(g, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int r = int(remain);
            mask = int(clipColor.r * 256.0);

            toBit(mask, m1, m2);
            toBit(r, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

        #endif


        vec4 c = vec4(1.0);
    #ifdef VERTEX_COLOR
        c = c * vColor;
    #endif

    #ifdef UCOLOR
        c = c * uColor;
    #endif

    vec3 sample = texture2D(texture, vUV).rgb;
        float dist = median(sample.r, sample.g, sample.b);

        // float a = (dist - 0.5) * uPxRange + 0.5;
        // float a = clamp( (dist - 0.5) / fwidth(dist - 0.5) + 0.5, 0.0, 1.0);

        float d = fwidth(dist);
        float a = smoothstep(-d, d, dist - 0.5);
    #ifdef STROKE
        c = mix(strokeColor, c, a);
        a = smoothstep(-d, d, dist - (0.5 - strokeSize));
    #endif

    #ifdef HSV
        vec3 hsv = rgb2hsv(c.rgb);
        hsv.r += hsvValue.r;
        c.rgb = hsv2rgb(hsv);

        // 注：saturate大于0时，公式和PS不大一样
        float gray = max(c.r, max(c.g, c.b)) + min(c.r, min(c.g, c.b));
        c.rgb = mix(c.rgb, vec3(0.5 * gray), -hsvValue.g);

        if (hsvValue.b >= 0.0) {
            c.rgb = mix(c.rgb, vec3(1.0), hsvValue.b);
        } else {
            c.rgb *= 1.0 + hsvValue.b;
        }
    #endif

    #ifdef GRAY
        c.rgb = vec3(c.r * 0.299 + c.g * 0.587 + c.b * 0.114);
    #endif

    #ifdef CLIP_BOX
        float factor = min(1.0-abs(vClipBox.x), 1.0-abs(vClipBox.y));
        c.a *= step(0.0, factor);
    #endif

    gl_FragColor = vec4(c.rgb, a * c.a * alpha);
    if (gl_FragColor.a < 0.02) discard;
}
`;
});

_$pi.define("pi_gui/gui/gui/shader_image", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     */
    exports.image_vs_shader_name = 'image_vs';
    exports.image_fs_shader_name = 'image_fs';
    exports.image_vs_code = `
    precision highp float;

    // Attributes
    attribute vec2 uv0;
    attribute vec2 position;

    // Uniforms
    uniform mat4 worldMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectMatrix;

    #ifdef CLIP_BOX
        uniform vec4 clipBox;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    // Varyings
    varying vec2 vuv;

    void main(void) {
        vec4 p1 = viewMatrix * worldMatrix * vec4(position.x, position.y, 1.0, 1.0);
        vec4 p = projectMatrix * p1;

        gl_Position = vec4(p.x, p.y, worldMatrix[3].z, 1.0);
        vuv = uv0;

        #ifdef CLIP_BOX
            vClipBox = vec2((p1.x - clipBox.x)/clipBox.z, (p1.y - clipBox.y)/clipBox.w);
        #endif
    }
`;
    exports.image_fs_code = `
    precision highp float;

    // Uniforms
    uniform float alpha;
    uniform sampler2D texture;

    #ifdef HSV
        /**
         * h: hue，色相，取值范围[-0.5, 0.5]，对应Photoshop的[-180, 180]
         *    + 注：最好不要越界，越界效果没有测试过，不保证正确性；
         *    + 注：基本能模拟PS的效果，最多只有1个像素值的误差
         *    + 比如：-0.3对应PS的 2 * -0.3 * 180 = -54度，PS的144度 对应 h的 144 * 0.5 / 180 = 0.4
         *
         * s：saturate，饱和度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 注：当PS中的s>0的时候，公式比较复杂，判断特别多，所以这里用了近似公式。不能完全模拟饱和度
         *    + 注：但是，当s<0的时候（变灰），基本能模拟PS的效果，最多只有1个像素值的误差
         *
         * v：brightness，明度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 比如：-0.3对应PS的-30，PS的60对应v=0.6
         */
        uniform vec3 hsvValue;
    #endif

    #ifdef CLIP
    uniform float clipIndices;
    uniform sampler2D clipTexture;
    uniform float clipTextureSize;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    // Varyings
    varying vec2 vuv;

    #ifdef HSV

    vec3 rgb2hsv(vec3 c)
    {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    vec3 hsv2rgb(vec3 c)
    {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, vec3(0.0), vec3(1.0)), c.y);
    }

    #endif

    #ifdef CLIP
        // 8位int型变二进制数组
        void toBit(int num, out bvec4 r1, out bvec4 r2) {
            for (int i = 0; i < 4; ++i) {
                r1[i] = (num / 2) * 2 != num;
                num = (num - int(r1[i])) / 2;
            }

            for (int i = 0; i < 4; ++i) {
                r2[i] = (num / 2) * 2 != num;
                num = (num - int(r2[i])) / 2;
            }
        }

        // 做与运算，返回true表示通过
        bool bitAnd(in bvec4 a1, in bvec4 a2, in bvec4 b1, in bvec4 b2) {

            bvec4 v1 = bvec4(a1.x && b1.x, a1.y && b1.y, a1.z && b1.z, a1.w && b1.w);
            bvec4 v2 = bvec4(a2.x && b2.x, a2.y && b2.y, a2.z && b2.z, a2.w && b2.w);

            return v1 == bvec4(false) && v2 == bvec4(false);
        }
    #endif

    void main(void) {
        #ifdef CLIP

            vec2 clipCoord = gl_FragCoord.xy / clipTextureSize;
            vec4 clipColor = texture2D(clipTexture, vec2(clipCoord));

            bvec4 m1, m2, i1, i2;
            bvec4 notM1, notM2;

            float remain = clipIndices;

            int b = int(remain / 128.0 / 128.0);
            remain = remain - float(b) * 128.0 * 128.0;
            int mask = int(clipColor.b * 256.0);

            toBit(mask, m1, m2);
            toBit(b, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int g = int(remain / 128.0);
            remain = remain - float(g) * 128.0;
            mask = int(clipColor.g * 256.0);

            toBit(mask, m1, m2);
            toBit(g, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int r = int(remain);
            mask = int(clipColor.r * 256.0);

            toBit(mask, m1, m2);
            toBit(r, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

        #endif


        vec4 c = texture2D(texture, vuv);

        #ifdef HSV
            vec3 hsv = rgb2hsv(c.rgb);
            hsv.r += hsvValue.r;
            c.rgb = hsv2rgb(hsv);

            // 注：saturate大于0时，公式和PS不大一样
            float gray = max(c.r, max(c.g, c.b)) + min(c.r, min(c.g, c.b));
            c.rgb = mix(c.rgb, vec3(0.5 * gray), -hsvValue.g);

            if (hsvValue.b >= 0.0) {
                c.rgb = mix(c.rgb, vec3(1.0), hsvValue.b);
            } else {
                c.rgb *= 1.0 + hsvValue.b;
            }
        #endif

        #ifdef GRAY
            c.rgb = dot(c.rgb, vec3(0.21, 0.71, 0.07));
        #endif

        #ifdef CLIP_BOX
            float factor = min(1.0-abs(vClipBox.x), 1.0-abs(vClipBox.y));
            c.a *= step(0.0, factor);
        #endif

        gl_FragColor = vec4(c.rgb, c.a * alpha);

        if (gl_FragColor.a == 0.0) discard;
    }
`;
});

_$pi.define("pi_gui/gui/gui/shader_color", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     */
    exports.color_vs_shader_name = 'color_vs';
    exports.color_fs_shader_name = 'color_fs';
    exports.color_vs_code = `
    precision highp float;

    // Attributes
    attribute vec2 position;

    #ifdef VERTEX_COLOR
        attribute vec4 color;
    #endif

    // Uniforms
    uniform mat4 worldMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectMatrix;

    #ifdef CLIP_BOX
        uniform vec4 clipBox;
    #endif

    #ifdef VERTEX_COLOR
        varying vec4 vColor;
    #endif

    #ifdef BOX_SHADOW_BLUR
        varying vec2 vPosition;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    void main(void) {
        vec4 p1 = viewMatrix * worldMatrix * vec4(position.x, position.y, 1.0, 1.0);
        vec4 p = projectMatrix * p1;

        gl_Position = vec4(p.x, p.y, worldMatrix[3].z, 1.0);

        #ifdef VERTEX_COLOR
            vColor = color;
        #endif

        #ifdef BOX_SHADOW_BLUR
            vPosition = position;
        #endif

        #ifdef CLIP_BOX
            vClipBox = vec2((p1.x - clipBox.x)/clipBox.z, (p1.y - clipBox.y)/clipBox.w);
        #endif
    }
`;
    exports.color_fs_code = `
    precision highp float;

    // Uniforms
    uniform float blur;
    uniform float alpha;

    #ifdef HSV
        /**
         * h: hue，色相，取值范围[-0.5, 0.5]，对应Photoshop的[-180, 180]
         *    + 注：最好不要越界，越界效果没有测试过，不保证正确性；
         *    + 注：基本能模拟PS的效果，最多只有1个像素值的误差
         *    + 比如：-0.3对应PS的 2 * -0.3 * 180 = -54度，PS的144度 对应 h的 144 * 0.5 / 180 = 0.4
         *
         * s：saturate，饱和度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 注：当PS中的s>0的时候，公式比较复杂，判断特别多，所以这里用了近似公式。不能完全模拟饱和度
         *    + 注：但是，当s<0的时候（变灰），基本能模拟PS的效果，最多只有1个像素值的误差
         *
         * v：brightness，明度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 比如：-0.3对应PS的-30，PS的60对应v=0.6
         */
        uniform vec3 hsvValue;
    #endif

    #ifdef CLIP
        uniform float clipIndices;
        uniform sampler2D clipTexture;
        uniform float clipTextureSize;
    #endif

    #ifdef BOX_SHADOW_BLUR
        uniform vec4 uRect; // xy是矩形最小点的坐标，zw是矩阵最大点的坐标；注：矩形必须排除阴影半径。
    #endif

    #ifdef VERTEX_COLOR
        varying vec4 vColor;
    #endif

    #ifdef UCOLOR
        uniform vec4 uColor;
    #endif

    #ifdef BOX_SHADOW_BLUR
        varying vec2 vPosition;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    #ifdef BOX_SHADOW_BLUR

        // 从webrender-15版本中拷贝过来的shader

        // An approximation of the error function, which is related to the integral of the Gaussian
        // function:
        //
        //     "erf"(x) = 2/sqrt(pi) int_0^x e^(-t^2) dt
        //              ~~ 1 - 1 / (1 + a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4)^4
        //
        // where:
        //
        //     a_1 = 0.278393, a_2 = 0.230389, a_3 = 0.000972, a_4 = 0.078108
        //
        // This approximation is accurate to '5 xx 10^-4', more than accurate enough for our purposes.
        //
        // See: https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions
        float erf(float x) {
            bool negative = x < 0.0;
            if (negative)
                x = -x;
            float x2 = x * x;
            float x3 = x2 * x;
            float x4 = x2 * x2;
            float denom = 1.0 + 0.278393 * x + 0.230389 * x2 + 0.000972 * x3 + 0.078108 * x4;
            float result = 1.0 - 1.0 / (denom * denom * denom * denom);
            return negative ? -result : result;
        }

        // A useful helper for calculating integrals of the Gaussian function via the error function:
        //
        //      "erf"_sigma(x) = 2 int 1/sqrt(2 pi sigma^2) e^(-x^2/(2 sigma^2)) dx
        //                     = "erf"(x/(sigma sqrt(2)))
        float erfSigma(float x, float sigma) {
            return erf(x / (sigma * 1.4142135623730951));
        }

        // Returns the blurred color value from the box itself (not counting any rounded corners). 'p_0' is
        // the vector distance to the top left corner of the box; 'p_1' is the vector distance to its
        // bottom right corner.
        //
        //      "colorFromRect"_sigma(p_0, p_1)
        //          = int_{p_{0_y}}^{p_{1_y}} int_{p_{1_x}}^{p_{0_x}} G_sigma(y) G_sigma(x) dx dy
        //          = 1/4 ("erf"_sigma(p_{1_x}) - "erf"_sigma(p_{0_x}))
        //              ("erf"_sigma(p_{1_y}) - "erf"_sigma(p_{0_y}))
        float colorFromRect(vec2 p0, vec2 p1, float sigma) {
            return (erfSigma(p1.x, sigma) - erfSigma(p0.x, sigma)) *
                (erfSigma(p1.y, sigma) - erfSigma(p0.y, sigma)) / 4.0;
        }

       // The blurred color value for the point at 'pos' with the top left corner of the box at
        // 'p_{0_"rect"}' and the bottom right corner of the box at 'p_{1_"rect"}'.
        float getShadowAlpha(vec2 pos, vec2 ptMin, vec2 ptMax, float sigma) {
            // Compute the vector distances 'p_0' and 'p_1'.
            vec2 dMin = pos - ptMin, dMax = pos - ptMax;

            // Compute the basic color '"colorFromRect"_sigma(p_0, p_1)'. This is all we have to do if
            // the box is unrounded.
            return colorFromRect(dMin, dMax, sigma);
        }
    #endif

    #ifdef HSV
        vec3 rgb2hsv(vec3 c)
        {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c)
        {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, vec3(0.0), vec3(1.0)), c.y);
        }
    #endif

    #ifdef CLIP
        // 8位int型变二进制数组
        void toBit(int num, out bvec4 r1, out bvec4 r2) {
            for (int i = 0; i < 4; ++i) {
                r1[i] = (num / 2) * 2 != num;
                num = (num - int(r1[i])) / 2;
            }

            for (int i = 0; i < 4; ++i) {
                r2[i] = (num / 2) * 2 != num;
                num = (num - int(r2[i])) / 2;
            }
        }

        // 做与运算，返回true表示通过
        bool bitAnd(in bvec4 a1, in bvec4 a2, in bvec4 b1, in bvec4 b2) {

            bvec4 v1 = bvec4(a1.x && b1.x, a1.y && b1.y, a1.z && b1.z, a1.w && b1.w);
            bvec4 v2 = bvec4(a2.x && b2.x, a2.y && b2.y, a2.z && b2.z, a2.w && b2.w);

            return v1 == bvec4(false) && v2 == bvec4(false);
        }
    #endif

    void main(void) {
        #ifdef CLIP

            vec2 clipCoord = gl_FragCoord.xy / clipTextureSize;
            vec4 clipColor = texture2D(clipTexture, vec2(clipCoord));

            bvec4 m1, m2, i1, i2;
            bvec4 notM1, notM2;

            float remain = clipIndices;

            int b = int(remain / 128.0 / 128.0);
            remain = remain - float(b) * 128.0 * 128.0;
            int mask = int(clipColor.b * 256.0);

            toBit(mask, m1, m2);
            toBit(b, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int g = int(remain / 128.0);
            remain = remain - float(g) * 128.0;
            mask = int(clipColor.g * 256.0);

            toBit(mask, m1, m2);
            toBit(g, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int r = int(remain);
            mask = int(clipColor.r * 256.0);

            toBit(mask, m1, m2);
            toBit(r, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

        #endif

            vec4 c = vec4(1.0);
        #ifdef VERTEX_COLOR
            c = c * vColor;
        #endif

        #ifdef UCOLOR
            c = c * uColor;
        #endif

        #ifdef HSV
            vec3 hsv = rgb2hsv(c.rgb);
            hsv.r += hsvValue.r;
            c.rgb = hsv2rgb(hsv);

            // 注：saturate大于0时，公式和PS不大一样
            float gray = max(c.r, max(c.g, c.b)) + min(c.r, min(c.g, c.b));
            c.rgb = mix(c.rgb, vec3(0.5 * gray), -hsvValue.g);

            if (hsvValue.b >= 0.0) {
                c.rgb = mix(c.rgb, vec3(1.0), hsvValue.b);
            } else {
                c.rgb *= 1.0 + hsvValue.b;
            }
        #endif

        #ifdef GRAY
            c.rgb = vec3(c.r * 0.299 + c.g * 0.587 + c.b * 0.114);
        #endif

        float blur_size = blur;

        #ifdef BOX_SHADOW_BLUR
            blur_size = 1.0;
            c.a = c.a * getShadowAlpha(vPosition, uRect.xy, uRect.zw, blur / 2.0);
        #endif

        c.a = c.a * alpha * blur_size;

        #ifdef CLIP_BOX
            float factor = min(1.0-abs(vClipBox.x), 1.0-abs(vClipBox.y));
            c.a *= step(0.0, factor);
        #endif

        gl_FragColor = c;

        if (gl_FragColor.a == 0.0) discard;
    }
`;
});

_$pi.define("pi_gui/gui/gui/shader_clip", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     */
    exports.clip_vs_shader_name = 'clip_vs';
    exports.clip_fs_shader_name = 'clip_fs';
    exports.clip_vs_code = `
    precision highp float;

    // Attributes
    attribute vec3 position;
    attribute float skinIndex; // 网格索引

    // Uniforms
    uniform float meshNum;
    uniform mat4 viewMatrix;
    uniform mat4 projectMatrix;

    // Varyings
    varying vec3 vPlaneIndex;

    void main(void) {

        if (skinIndex < 7.0) {
            vPlaneIndex.r = pow(2.0, skinIndex);
            vPlaneIndex.g = 0.0;
            vPlaneIndex.b = 0.0;
        } else if (skinIndex < 14.0) {
            vPlaneIndex.r = 0.0;
            vPlaneIndex.g = pow(2.0, skinIndex - 7.0);
            vPlaneIndex.b = 0.0;
        } else {
            vPlaneIndex.r = 0.0;
            vPlaneIndex.g = 0.0;
            vPlaneIndex.b = pow(2.0, skinIndex - 14.0);
        }

        vec4 pos;
        if (skinIndex < meshNum) {
            pos = projectMatrix * viewMatrix * vec4(position, 1.0);
        } else {
            pos = vec4(2.0, 2.0, 2.0, 1.0);
        }

        gl_Position = pos;
    }
`;
    exports.clip_fs_code = `
    precision highp float;

    // Varyings
    varying vec3 vPlaneIndex;

    void main(void) {
        gl_FragColor = vec4(vPlaneIndex.xyz / 256.0, 1.0);
    }
`;
});

_$pi.define("pi_gui/gui/gui/shader_canvas_text", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     */
    exports.canvas_text_vs_shader_name = 'canvas_text_vs';
    exports.canvas_text_fs_shader_name = 'canvas_text_fs';
    exports.canvas_text_vs_code = `
    precision highp float;

    // Attributes
    attribute vec2 position;
    attribute vec2 uv0;
    #ifdef VERTEX_COLOR
    attribute vec4 color;
    #endif

    // Uniforms
    uniform mat4 worldMatrix;
    uniform mat4 viewMatrix;
    uniform mat4 projectMatrix;
    uniform vec2 textureSize;

    #ifdef CLIP_BOX
        uniform vec4 clipBox;
    #endif

    // Varyings
    #ifdef VERTEX_COLOR
        varying vec4 vColor;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    varying vec2 vUV;

    void main() {
		vec4 p1 = worldMatrix * vec4(position.x, position.y, 1.0, 1.0);
		p1.x = ceil(p1.x);
		p1.y = ceil(p1.y);
		p1 = viewMatrix * p1;
        vec4 p = projectMatrix * p1;


        // vec4 p = projectMatrix * viewMatrix * p1;
        gl_Position = vec4(p.x, p.y, worldMatrix[3].z, 1.0);
    #ifdef VERTEX_COLOR
        vColor = color;
    #endif
        // vUV = vec2(uv0.x/1024.0, uv0.y/1024.0);
        vUV = vec2(uv0.x/textureSize.x, uv0.y/textureSize.y);

        #ifdef CLIP_BOX
            vClipBox = vec2((p1.x - clipBox.x)/clipBox.z, (p1.y - clipBox.y)/clipBox.w);
        #endif
    }
`;
    exports.canvas_text_fs_code = `
    #extension GL_OES_standard_derivatives : enable

    precision highp float;

    #ifdef HSV
        /**
         * h: hue，色相，取值范围[-0.5, 0.5]，对应Photoshop的[-180, 180]
         *    + 注：最好不要越界，越界效果没有测试过，不保证正确性；
         *    + 注：基本能模拟PS的效果，最多只有1个像素值的误差
         *    + 比如：-0.3对应PS的 2 * -0.3 * 180 = -54度，PS的144度 对应 h的 144 * 0.5 / 180 = 0.4
         *
         * s：saturate，饱和度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 注：当PS中的s>0的时候，公式比较复杂，判断特别多，所以这里用了近似公式。不能完全模拟饱和度
         *    + 注：但是，当s<0的时候（变灰），基本能模拟PS的效果，最多只有1个像素值的误差
         *
         * v：brightness，明度，取值范围[-1, 1]，对应Photoshop的[-100, 100]
         *    + 比如：-0.3对应PS的-30，PS的60对应v=0.6
         */
        uniform vec3 hsvValue;
    #endif

    #ifdef CLIP
        uniform float clipIndices;
        uniform sampler2D clipTexture;
        uniform float clipTextureSize;
    #endif

    #ifdef CLIP_BOX
        varying vec2 vClipBox;
    #endif

    // Varyings
    #ifdef VERTEX_COLOR
    varying vec4 vColor;
    #endif

    varying vec2 vUV;

    // Uniforms
    uniform float alpha;
    uniform sampler2D texture;
    uniform vec4 strokeColor;
    #ifdef UCOLOR
    uniform vec4 uColor;
    #endif

    #ifdef HSV
        vec3 rgb2hsv(vec3 c)
        {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c)
        {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, vec3(0.0), vec3(1.0)), c.y);
        }
    #endif

    #ifdef CLIP
        // 8位int型变二进制数组
        void toBit(int num, out bvec4 r1, out bvec4 r2) {
            for (int i = 0; i < 4; ++i) {
                r1[i] = (num / 2) * 2 != num;
                num = (num - int(r1[i])) / 2;
            }

            for (int i = 0; i < 4; ++i) {
                r2[i] = (num / 2) * 2 != num;
                num = (num - int(r2[i])) / 2;
            }
        }

        // 做与运算，返回true表示通过
        bool bitAnd(in bvec4 a1, in bvec4 a2, in bvec4 b1, in bvec4 b2) {

            bvec4 v1 = bvec4(a1.x && b1.x, a1.y && b1.y, a1.z && b1.z, a1.w && b1.w);
            bvec4 v2 = bvec4(a2.x && b2.x, a2.y && b2.y, a2.z && b2.z, a2.w && b2.w);

            return v1 == bvec4(false) && v2 == bvec4(false);
        }
    #endif

    void main() {

        #ifdef CLIP

            vec2 clipCoord = gl_FragCoord.xy / clipTextureSize;
            vec4 clipColor = texture2D(clipTexture, vec2(clipCoord));

            bvec4 m1, m2, i1, i2;
            bvec4 notM1, notM2;

            float remain = clipIndices;

            int b = int(remain / 128.0 / 128.0);
            remain = remain - float(b) * 128.0 * 128.0;
            int mask = int(clipColor.b * 256.0);

            toBit(mask, m1, m2);
            toBit(b, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int g = int(remain / 128.0);
            remain = remain - float(g) * 128.0;
            mask = int(clipColor.g * 256.0);

            toBit(mask, m1, m2);
            toBit(g, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

            int r = int(remain);
            mask = int(clipColor.r * 256.0);

            toBit(mask, m1, m2);
            toBit(r, i1, i2);
            notM1 = bvec4(!m1.x, !m1.y, !m1.z, !m1.w);
            notM2 = bvec4(!m2.x, !m2.y, !m2.z, !m2.w);
            if (!bitAnd(notM1, notM2, i1, i2)) {
                discard;
            }

        #endif

        vec4 c = vec4(1.0);
    #ifdef VERTEX_COLOR
        c = c * vColor;
    #endif

    #ifdef UCOLOR
        c = c * uColor;
    #endif

    vec4 sample = texture2D(texture, vUV);
    c = sample.r * strokeColor + sample.g * c;
    // c.a = 1.0 - sample.b;
    c.a = clamp(sample.a - sample.b, 0.0, 1.0); // 应该 c.a = 1.0 - sample.b, 由于纹理坐标误差， 导致采样到纹理的空白处（rgba都为0）， 会看到一条黑线

    #ifdef HSV
        vec3 hsv = rgb2hsv(c.rgb);
        hsv.r += hsvValue.r;
        c.rgb = hsv2rgb(hsv);

        // 注：saturate大于0时，公式和PS不大一样
        float gray = max(c.r, max(c.g, c.b)) + min(c.r, min(c.g, c.b));
        c.rgb = mix(c.rgb, vec3(0.5 * gray), -hsvValue.g);

        if (hsvValue.b >= 0.0) {
            c.rgb = mix(c.rgb, vec3(1.0), hsvValue.b);
        } else {
            c.rgb *= 1.0 + hsvValue.b;
        }
    #endif

    #ifdef GRAY
        c.rgb = vec3(c.r * 0.299 + c.g * 0.587 + c.b * 0.114);
    #endif

    #ifdef CLIP_BOX
        float factor = min(1.0-abs(vClipBox.x), 1.0-abs(vClipBox.y));
        c.a *= step(0.0, factor);
    #endif
        gl_FragColor = vec4(c.rgb, c.a * alpha);
        // gl_FragColor = vec4(sample.rgb, 1.0);
        if (gl_FragColor.a < 0.02) discard;
    }
`;
});

/**
 * GUI 节点 CSS 动画数据结构
 */
_$pi.define("pi_gui/gui/gui/animation_tools", ["require", "exports", "./tools"], function (require, exports, tools_1) {
    "use strict";
    
    /**
     * 解析动画配置
     */
    class Animation {
        constructor(name) {
            this.name = name;
            this.attrs = [];
        }
    }
    exports.Animation = Animation;
    class RuntimeAnimation {
        constructor(name, cfg, totalTime) {
            /**
             * 已运行时间
             */
            this.runedTime = 0;
            /**
             * 开始时间
             */
            this.startTime = 0;
            /**
             * 动画时长
             */
            this.duration = 0;
            /**
             * 动画进行时函数
             */
            this.timingFunction = 'linear';
            /**
             * 动画延时执行
             */
            this.delayTime = 0;
            /**
             * 重复次数
             */
            this.iteration = 1;
            /**
             * 播放模式
             */
            this.direction = 'normal';
            /**
             * 结束时状态
             */
            this.fillMode = 'none';
            /**
             * 目标属性列表
             */
            this.attrKeysList = [];
            /**
             * 动画开始前状态
             */
            this.stateBefore = new Map();
            /**
             * 当前状态
             */
            this.stateRuntime = new Map();
            /**
             * 当前进行次数
             */
            this.runtimeCount = 0;
            this.name = name;
            this.animaCfg = cfg;
            this.totalTime = totalTime;
            this.duration = totalTime;
            this.animaCfg.attrs.forEach((v) => {
                this.attrKeysList.push(v.key);
            });
        }
    }
    exports.RuntimeAnimation = RuntimeAnimation;
    /**
     * 目标节点动画表
     */
    class Animatable {
        constructor(target) {
            this.target = target;
            this.animations = new Map();
        }
        reset(target) {
            this.target = target;
            this.delayTime = undefined;
            this.lastTime = undefined;
            this.startTime = undefined;
            this.animations.clear();
        }
        clear() {
            this.target = undefined;
            this.delayTime = undefined;
            this.lastTime = undefined;
            this.startTime = undefined;
            this.animations.clear();
        }
        /**
         * 添加动画
         * @param anime 运行时动画数据
         */
        add(anime) {
            this.animations.set(anime.name, anime);
            anime.startListener = this.target.style.animStart;
            anime.iteratListener = this.target.style.animLoop;
            anime.endListener = this.target.style.animEnd;
        }
        /**
         * 移除动画
         * @param anime 运行时动画数据
         */
        remove(anime) {
            this.animations.delete(anime.name);
        }
        /**
         * 移除动画
         * @param anime 运行时动画名称
         */
        removeByName(animeName) {
            this.animations.delete(animeName);
        }
    }
    exports.Animatable = Animatable;
    /**
     * 目标属性的帧数据
     * * 配置数据，用于初始化运行时动画
     */
    class AttrFrames {
        constructor(key) {
            this.key = key;
        }
    }
    exports.AttrFrames = AttrFrames;
    /**
     * 运行时动画帧数据结构
     */
    class RuntimeKeyFrame {
        constructor(progress, key, value) {
            this.progress = progress;
            this.dataKey = key;
            this.dataValue = value;
        }
    }
    exports.RuntimeKeyFrame = RuntimeKeyFrame;
    /**
     * 动画播放模式枚举
     */
    var DirectionTypes;
    (function (DirectionTypes) {
        DirectionTypes["normal"] = "normal";
        DirectionTypes["reverse"] = "reverse";
        DirectionTypes["alternate"] = "alternate";
        DirectionTypes["alternate_reverse"] = "alternate-reverse";
    })(DirectionTypes = exports.DirectionTypes || (exports.DirectionTypes = {}));
    /**
     * 动画显式支持的目标属性表
     */
    exports.FrameClassKeys = {
        transform: tools_1.StyleMap.transform,
        opacity: tools_1.StyleMap.opacity,
        left: tools_1.StyleMap.left,
        top: tools_1.StyleMap.top,
        cellId: 'cellId'
    };
    /**
     * GUI 节点 CSS 动画运行时数据操作工具
     */
    // tslint:disable-next-line:no-unnecessary-class
    class AnimeTools {
        /**
         * 拷贝帧数据
         * @param key 属性名
         * @param frameData 帧数据
         */
        static cloneAttrFrame(key, frame) {
            let value;
            switch (key) {
                case (exports.FrameClassKeys.transform): {
                    value = tools_1.Tools.copyEnumTransformData(frame);
                    break;
                }
                case (exports.FrameClassKeys.left):
                case (exports.FrameClassKeys.top): {
                    value = tools_1.Tools.copyLengthData(frame);
                    break;
                }
                case (exports.FrameClassKeys.opacity):
                case (exports.FrameClassKeys.cellId):
                default: {
                    value = frame;
                }
            }
            return value;
        }
        /**
         * 两个数据中线性取中间数据
         * @param key 属性名称
         * @param comparePercent 百分比
         * @param lastFrame 起点数据
         * @param nextFrame 终点数据
         */
        static mixFrameData(key, comparePercent, lastFrame, nextFrame) {
            let currFrame;
            switch (key) {
                case (exports.FrameClassKeys.transform): {
                    currFrame = tools_1.Tools.mixEnumTransformData(comparePercent, lastFrame, nextFrame);
                    break;
                }
                case (exports.FrameClassKeys.left):
                case (exports.FrameClassKeys.top): {
                    currFrame = tools_1.Tools.mixILengthData(comparePercent, lastFrame, nextFrame);
                    break;
                }
                case (exports.FrameClassKeys.opacity): {
                    currFrame = lastFrame + (nextFrame - lastFrame) * comparePercent;
                    currFrame = tools_1.Tools.clipFloat(currFrame);
                    break;
                }
                case (exports.FrameClassKeys.cellId):
                default: {
                    currFrame = lastFrame + (nextFrame - lastFrame) * comparePercent;
                    currFrame = tools_1.Tools.clipInt(currFrame);
                }
            }
            return currFrame;
        }
        /**
         * 构建运行时动画
         * @param cmd 动画运行命令
         * @param cfg 动画帧数据
         */
        static initRuntimeAnimation(cmd, cfg) {
            // 创建新 运行时动画
            const runtimeAnimation = new RuntimeAnimation(cmd.name, cfg, cmd.duration);
            // 设置 运行时动画参数
            runtimeAnimation.delayTime = cmd.delayTime;
            runtimeAnimation.direction = cmd.direction;
            runtimeAnimation.fillMode = cmd.fillMode;
            runtimeAnimation.timingFunction = cmd.timingFunction;
            runtimeAnimation.iteration = cmd.iteration;
            return runtimeAnimation;
        }
    }
    exports.AnimeTools = AnimeTools;
});

/*
 * 事件广播模块
 */
_$pi.define("pi_gui/util/event", ["require", "exports", "../../pi_sys/modules/lang/time", "../../pi_sys/feature/log", "../../pi_sys/modules/util/util"], function (require, exports, time_1, log_1, util_1) {
    "use strict";
    
    // 3毫秒以上的事件会打印
    const timeout = 3;
    /**
     * @description 处理器返回值
     */
    var HandlerResult;
    (function (HandlerResult) {
        HandlerResult[HandlerResult["OK"] = 0] = "OK";
        HandlerResult[HandlerResult["REMOVE_SELF"] = 1] = "REMOVE_SELF";
        HandlerResult[HandlerResult["BREAK_OK"] = 2] = "BREAK_OK";
        HandlerResult[HandlerResult["BREAK_REMOVE_SELF"] = 3] = "BREAK_REMOVE_SELF"; // 结束此次事件调用，不继续调用处理器，从处理器列表删除自身，以后不会收到事件
    })(HandlerResult = exports.HandlerResult || (exports.HandlerResult = {}));
    /**
     * 创建事件处理器列表
     * @example
     */
    exports.createHandlerList = () => {
        const list = (args) => {
            let i;
            let handler;
            let r;
            let delIndex = -1;
            const arr = list.array;
            const n = arr.length;
            list.handling++;
            for (i = n - 1; i >= 0; i--) {
                handler = arr[i];
                if (handler) {
                    r = call1(handler, args);
                    if (!r) {
                        continue;
                    }
                    else if (r === HandlerResult.REMOVE_SELF) {
                        arr[i] = null;
                        delIndex = i;
                    }
                    else if (r === HandlerResult.BREAK_OK) {
                        break;
                    }
                    else if (r === HandlerResult.BREAK_REMOVE_SELF) {
                        arr[i] = null;
                        delIndex = i;
                        break;
                    }
                }
                else {
                    delIndex = i;
                }
            }
            list.handling--;
            if (delIndex >= 0 && !list.handling) {
                for (i = delIndex + 1; i < n; ++i) {
                    handler = arr[i];
                    if (handler) {
                        arr[delIndex] = handler;
                        ++delIndex;
                    }
                }
                list.count = delIndex;
                arr.length = delIndex;
            }
            return r || HandlerResult.BREAK_OK;
        };
        list.handling = 0;
        list.count = 0;
        list.array = [];
        list.__proto__ = HandlerArray.prototype;
        return list;
    };
    /**
     * 创建事件处理器表
     * @example
     */
    class HandlerMap {
        constructor() {
            /**
             * 事件处理器映射表
             */
            this.map = new Map();
        }
        /**
         * 事件通知
         */
        // tslint:disable:no-reserved-keywords
        notify(type, args) {
            const list = this.map.get(type);
            if (!list) {
                return false;
            }
            // 这是一个bug,如果传入的参数本来就是数组，就会解析出错
            Array.isArray(args) ? list([args]) : list(args);
            return true;
        }
        /**
         * 获得事件处理器表的长度
         */
        size(type) {
            let list;
            let n = 0;
            for (list of this.map.values()) {
                n += list.size();
            }
            return n;
        }
        /**
         * 添加事件处理器
         */
        add(type, h) {
            let list;
            const map = this.map;
            if (!(h && type)) {
                return;
            }
            list = map.get(type);
            if (!list) {
                list = exports.createHandlerList();
                map.set(type, list);
            }
            list.add(h);
        }
        /**
         * 删除事件处理器
         */
        remove(type, h) {
            let list;
            const map = this.map;
            if (!h) {
                if (!type) {
                    return false;
                }
                return map.delete(type);
            }
            if (!type) {
                for (list of this.map.values()) {
                    if (!list.remove(h)) {
                        continue;
                    }
                    if (list.size() === 0) {
                        map.delete(type);
                        return true;
                    }
                }
                return false;
            }
            list = map.get(type);
            if (!list) {
                return false;
            }
            if (!list.remove(h)) {
                return false;
            }
            if (list.size() === 0) {
                map.delete(type);
            }
            return true;
        }
        /**
         * 删除事件处理器
         */
        clear() {
            this.map.clear();
        }
    }
    exports.HandlerMap = HandlerMap;
    /**
     * 事件处理器表
     * @example
     */
    class HandlerTable {
        constructor() {
            // 必须要赋初值，不然new出来的实例里面是没有这些属性的
            this.handlerMap = null; // 事件处理器表
        }
        /**
         * @description 通知组件上的事件监听器
         * @example
         */
        notify(eventType, args) {
            if (this[eventType]) {
                try {
                    if (eventType != "start" && eventType != "click" && eventType != "guide" && eventType != "end" && eventType != "move" && eventType != "down" && eventType != "up" && eventType != "out" && eventType != "onMouseMove" && eventType != "onMouseUp" && eventType != "scroll" && eventType != "scaleMap" && eventType != "hiddeBottom" && eventType != "hiddeTop" && eventType != "gotoGenerals" && eventType != 'gotoShop') {
                        MusicFun && MusicFun(eventType);
                    }
                }
                catch (error) {
                    console.error(error);
                }
                return objCall1(this, eventType, args);
            }
            const map = this.handlerMap;
            if (!map) {
                return;
            }
            const r = map.notify(eventType, args);
            if (r) {
                return r;
            }
            return map.notify('*', args);
        }
        /**
         * 添加事件处理器
         */
        addHandler(type, h) {
            let map = this.handlerMap;
            if (!map) {
                map = this.handlerMap = new HandlerMap();
            }
            map.add(type, h);
        }
        /**
         * 删除事件处理器
         */
        removeHandler(type, h) {
            return this.handlerMap && this.handlerMap.remove(type, h);
        }
        /**
         * 删除事件处理器
         */
        clearHandler() {
            return this.handlerMap && this.handlerMap.clear();
        }
    }
    exports.HandlerTable = HandlerTable;
    /**
     * 创建事件监听器表
     * @example
     */
    class ListenerList {
        constructor() {
            this.list = [];
        }
        /**
         * @description 通知列表上的每个事件监听器
         * @example
         */
        notify(arg) {
            const r = this.list;
            for (const f of r) {
                f(arg);
            }
        }
        /**
         * 获取事件监听器列表的长度
         */
        size() {
            return this.list.length;
        }
        /**
         * 添加事件监听器
         */
        add(f) {
            this.list = util_1.arrInsert(this.list, f);
        }
        /**
         * 删除事件监听器
         */
        remove(f) {
            const old = this.list;
            const r = util_1.arrRemove(this.list, f);
            const b = r === old;
            this.list = r;
            return b;
        }
        /**
         * 清空事件监听器列表
         */
        clear() {
            this.list = [];
        }
    }
    exports.ListenerList = ListenerList;
    // ============================== 本地
    // 函数调用
    const call1 = (func, args) => {
        let r;
        const start = time_1.now();
        try {
            r = util_1.call(func, args);
        }
        catch (ex) {
            return log_1.cc.warn() && log_1.log('event, ex: ', ex, ', func: ', func, args);
        }
        const end = time_1.now();
        if (end - start > timeout) {
            log_1.cc.debug() && log_1.log(`event slow, cost: ${end - start}`, func, args);
        }
        return r;
    };
    // 对象方法调用
    const objCall1 = (obj, func, args) => {
        let r;
        const start = time_1.now();
        try {
            r = util_1.objCall(obj, func, args);
        }
        catch (ex) {
            log_1.cc.warn() && log_1.log('event, ex: ', ex, ', func: ', obj, func, args);
        }
        const end = time_1.now();
        if (end - start > timeout) {
            log_1.cc.debug() && log_1.log(`event slow, cost: ${end - start}`, obj, func, args);
        }
        return r;
    };
    // TODO 以后改成树结构-并且是写时复制的，就可以任意重入。而且删除效率高。js对象不能直接比较大小，可以转成字符串后的hash来比较大小。如果是乱序执行，则只需要1个树。如果是按照放入的顺序执行，则需要2个树。sbtree或fingertree
    // tslint:disable:max-classes-per-file
    class HandlerArray {
        constructor() {
            this.handling = 0;
            this.count = 0;
            this.array = [];
        }
        /**
         * 获得事件处理器列表的长度
         */
        size() {
            return this.count;
        }
        /**
         * 添加事件处理器
         */
        add(handler) {
            this.array.push(handler);
            this.count += 1;
        }
        /**
         * 删除事件处理器
         */
        remove(handler) {
            let i;
            const arr = this.array;
            for (i = arr.length - 1; i >= 0; --i) {
                if (arr[i] === handler) {
                    arr[i] = null;
                    this.count -= 1;
                    return true;
                }
            }
            return false;
        }
        /**
         * 清理事件处理器
         */
        clear() {
            this.array = [];
            this.count = 0;
        }
    }
    let MusicFun;
    exports.addMusicTcouchTap = (msg) => {
        MusicFun = msg;
    };
});

_$pi.define("pi_gui/gui/gui/shader_init", ["require", "exports", "./gui", "./shader_canvas_text", "./shader_clip", "./shader_color", "./shader_image", "./shader_text"], function (require, exports, gui_1, shader_canvas_text_1, shader_clip_1, shader_color_1, shader_image_1, shader_text_1) {
    "use strict";
    
    /**
     *
     */
    exports.initShaders = (engine) => {
        // 设置图片shader
        window.__jsObj = shader_color_1.color_vs_shader_name;
        window.__jsObj1 = shader_color_1.color_vs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_color_1.color_fs_shader_name;
        window.__jsObj1 = shader_color_1.color_fs_code;
        gui_1.gui._set_shader(engine);
        // 设置图片shader
        window.__jsObj = shader_image_1.image_vs_shader_name;
        window.__jsObj1 = shader_image_1.image_vs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_image_1.image_fs_shader_name;
        window.__jsObj1 = shader_image_1.image_fs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_clip_1.clip_vs_shader_name;
        window.__jsObj1 = shader_clip_1.clip_vs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_clip_1.clip_fs_shader_name;
        window.__jsObj1 = shader_clip_1.clip_fs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_text_1.text_vs_shader_name;
        window.__jsObj1 = shader_text_1.text_vs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_text_1.text_fs_shader_name;
        window.__jsObj1 = shader_text_1.text_fs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_canvas_text_1.canvas_text_vs_shader_name;
        window.__jsObj1 = shader_canvas_text_1.canvas_text_vs_code;
        gui_1.gui._set_shader(engine);
        window.__jsObj = shader_canvas_text_1.canvas_text_fs_shader_name;
        window.__jsObj1 = shader_canvas_text_1.canvas_text_fs_code;
        gui_1.gui._set_shader(engine);
    };
});

/**
 * GUI
 * 样式表
 */
_$pi.define("pi_gui/gui/gui/r_sheet", ["require", "exports", "./gui", "./tools"], function (require, exports, gui_1, tools_1) {
    "use strict";
    
    /**
     * 样式表管理
     */
    class RSheet {
        constructor(doc) {
            /**
             * 文本样式表数组
             */
            this.textClassList = [];
            this.doc = doc;
        }
        // /**
        //  * 创建一个文本节点样式表
        //  * @param id 样式表 ID
        //  */
        // public createTextStyleClass(id: number) {
        //     const result = gui._create_text_style_class(this.doc.uniqueID, id);
        //     if (result) {
        //         this.textClassList.push(id);
        //     }
        //     return result;
        // }
        /**
         * 创建一个文本节点样式表
         * @param id 样式表 ID
         * @param css 样式字符串 键名必须 - 连接(css写法)， 必须 “;” 结尾
         *  - font-family:kaiti;font-weight:normal;
         */
        createStyleClass(id, css) {
            if (this.textClassList.indexOf(id) >= 0) {
                tools_1.Tools.warn(`不能重复设置 class ${id}`);
                return;
            }
            window.__jsObj = css;
            const result = gui_1.gui._create_class_by_bin(this.doc.uniqueID);
            // if (result) {
            //     this.textClassList.push(id);
            // }
            // return result;
            this.textClassList.push(id);
            return true;
        }
        /**
         * 设置样式表中内容
         * @param doc 目标上下文
         * @param classID 样式表ID
         * @param key 样式键
         * @param value 样式值
         */
        setTextStyleClass(classID, key, value) {
            if (this.textClassList.indexOf(classID) >= 0) {
                if (this[key]) {
                    this[key](classID, value);
                }
            }
            return this;
        }
        /**
         * 为目标节点设置 样式表
         * @param node 目标节点
         * @param class_id 目标样式表ID
         */
        setNodeTextStyleClass(node, class_id) {
            // gui._set_text_style_class(this.doc.uniqueID, node.uniqueID, class_id);
            gui_1.gui._set_class(this.doc.uniqueID, node.uniqueID, class_id);
        }
        /**
         * 为目标节点设置 样式表
         * @param node 目标节点
         * @param class_id 目标样式表ID
         */
        setNodeStyleClass(node, class_id) {
            gui_1.gui._set_class(this.doc.uniqueID, node.uniqueID, class_id);
        }
        setDefaultStyle(css) {
            window.__jsObj = css;
            gui_1.gui._set_default_style_by_bin(this.doc.uniqueID);
        }
    }
    exports.RSheet = RSheet;
});

/**
 * GUI 使用原生 WebGL 渲染到canvas
 */
_$pi.define("pi_gui/gui/gui/r_render", ["require", "exports"], function (require, exports) {
    "use strict";
    
    class RRender {
        constructor(canvas, gl) {
            this._vertex_data = [];
            this._face_data = [];
            this._uv_data = [];
            /**
             * 外部重设置 渲染前 GL 操作
             */
            this.setBeforeRenderCall = (f) => {
                this.defBeforeRender = f;
            };
            this.doUnbind = () => {
                if (this._fbo) {
                    const gl = this.gl;
                    // 重置 bindFramebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
            };
            this.renderToCanvas = (isClear) => {
                if (this._fbo) {
                    const gl = this.gl;
                    this.beforeRender(isClear);
                    // 纹理激活
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, this._tex);
                    gl.enableVertexAttribArray(this._a_position_loc);
                    gl.enableVertexAttribArray(this._a_uv_loc);
                    gl.useProgram(RRender.shader_program);
                    this._u_sampler && gl.uniform1i(this._u_sampler, 0);
                    if (this._a_position_loc >= 0) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertex_buffer);
                        gl.vertexAttribPointer(this._a_position_loc, 2, gl.FLOAT, false, 4 * 2, 0);
                    }
                    if (this._a_uv_loc >= 0) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._uv_buffer);
                        gl.vertexAttribPointer(this._a_uv_loc, 2, gl.FLOAT, false, 4 * 2, 0);
                    }
                    if (this._face_buffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._face_buffer);
                        gl.drawElements(gl.TRIANGLES, this._face_data.length, gl.UNSIGNED_SHORT, 0);
                    }
                    gl.useProgram(null);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.disableVertexAttribArray(this._a_position_loc);
                    gl.disableVertexAttribArray(this._a_uv_loc);
                    //
                    gl.enable(gl.CULL_FACE);
                }
            };
            this.beforeRender = (isClear) => {
                if (this._fbo) {
                    const gl = this.gl;
                    if (this.vao) {
                        this.vao.bindVertexArrayOES(null);
                    }
                    // 重置 bindFramebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    // 视口
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    this.defBeforeRender && this.defBeforeRender(gl, isClear);
                }
            };
            /**
             * 默认 渲染前操作
             * 外部可重设置
             */
            this.defBeforeRender = (gl, isClear) => {
                // http://192.168.31.241:8181/docs/front_library/front_library-1bcj847dthmps
                gl.depthMask(true);
                if (isClear) {
                    // 清屏
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }
                //
                gl.disable(gl.CULL_FACE);
                gl.disable(gl.DEPTH_TEST);
                // alpha 混合 - 预乘
                gl.enable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
            };
            this.canvas = canvas;
            this.gl = gl;
            this._fboSize = RRender.nextPowerOfTwo(Math.max(this.canvas.width, this.canvas.height));
            this._fboWidth = RRender.nextPowerOfTwo(this.canvas.width);
            this._fboHeight = RRender.nextPowerOfTwo(this.canvas.height);
            this.initData();
            this.updateData();
            this.initFBO();
        }
        get fbo() {
            return this._fbo;
        }
        get fboID() {
            return this.uniqueID;
        }
        set fboID(id) {
            this.uniqueID = id;
        }
        static initShader(gl) {
            if (!RRender.vshader) {
                RRender.getVSShader(gl);
            }
            if (!RRender.fshader) {
                RRender.getFSShader(gl);
            }
        }
        static getVSShader(gl) {
            if (gl === null) {
                return this.vshader;
            }
            if (this.vshader) {
                return this.vshader;
            }
            this.vshader = gl.createShader(gl.VERTEX_SHADER);
            if (this.vshader === null) {
                return this.vshader;
            }
            if (this.vs === undefined) {
                return this.vshader;
            }
            gl.shaderSource(this.vshader, this.vs);
            gl.compileShader(this.vshader);
            if (!gl.getShaderParameter(this.vshader, gl.COMPILE_STATUS)) {
                console.error(`ERROR IN 'VERTEX_SHADER' SHADER: ${gl.getShaderInfoLog(this.vshader)}`);
                return this.vshader;
            }
            return this.vshader;
        }
        static getFSShader(gl) {
            if (gl === null) {
                return this.fshader;
            }
            if (this.fshader) {
                return this.fshader;
            }
            this.fshader = gl.createShader(gl.FRAGMENT_SHADER);
            if (this.fshader === null) {
                return this.fshader;
            }
            if (this.fs === undefined) {
                return this.fshader;
            }
            gl.shaderSource(this.fshader, this.fs);
            gl.compileShader(this.fshader);
            if (!gl.getShaderParameter(this.fshader, gl.COMPILE_STATUS)) {
                console.error(`ERROR IN 'FRAGMENT_SHADER' SHADER: ${gl.getShaderInfoLog(this.fshader)}`);
                return this.fshader;
            }
            return this.fshader;
        }
        getGL() {
            return this.gl;
        }
        bindFBO() {
            // 重置 bindFramebuffer
            this._fbo && this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._fbo);
        }
        render(isClear) {
            this.renderToCanvas(isClear);
        }
        initFBO() {
            const gl = this.gl;
            if (!this._fbo) {
                const fbo = gl.createFramebuffer();
                const tex = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._fboWidth, this._fboHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
                const depth = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, depth);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this._fboWidth, this._fboHeight);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depth);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                const e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (e !== gl.FRAMEBUFFER_COMPLETE) {
                    console.warn('FrameBuffer Error');
                    return;
                }
                RRender.initShader(gl);
                const shader_fragment = RRender.fshader;
                const shader_vertex = RRender.vshader;
                if (RRender.shader_program === undefined && gl.getShaderParameter(shader_fragment, gl.COMPILE_STATUS)) {
                    const shader_program = gl.createProgram();
                    RRender.shader_program = shader_program;
                    gl.attachShader(RRender.shader_program, shader_vertex);
                    gl.attachShader(RRender.shader_program, shader_fragment);
                    gl.linkProgram(RRender.shader_program);
                }
                if (this.vao === undefined) {
                    this.vao = gl.getExtension('OES_vertex_array_object');
                }
                if (this._a_position_loc === undefined) {
                    this._a_position_loc = gl.getAttribLocation(RRender.shader_program, 'a_position');
                }
                if (this._a_uv_loc === undefined) {
                    this._a_uv_loc = gl.getAttribLocation(RRender.shader_program, 'a_uv');
                }
                if (this._u_sampler === undefined) {
                    this._u_sampler = gl.getUniformLocation(RRender.shader_program, 'u_sampler');
                }
                this._fbo = fbo;
                // this._fbo.texture = tex;
                this._tex = tex;
            }
            return this._fbo;
        }
        initData() {
            this._vertex_data = [
                -1, -1,
                1.0, -1,
                1.0, 1.0,
                -1, 1.0
            ];
            this._face_data = [
                0, 1, 2,
                0, 2, 3
            ];
            this._uv_data = [
                0, 0,
                this.canvas.width / this._fboWidth, 0,
                this.canvas.width / this._fboWidth, this.canvas.height / this._fboHeight,
                0, this.canvas.height / this._fboHeight
            ];
        }
        updateData() {
            const gl = this.gl;
            if (!this._vertex_buffer) {
                this._vertex_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this._vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this._vertex_data), gl.STATIC_DRAW);
            }
            if (!this._face_buffer) {
                this._face_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._face_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this._face_data), gl.STATIC_DRAW);
            }
            if (!this._uv_buffer) {
                this._uv_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this._uv_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this._uv_data), gl.STATIC_DRAW);
            }
        }
    }
    exports.RRender = RRender;
    RRender.vs = `
        precision highp float;
        precision highp int;

        attribute   vec2    a_position;
        attribute   vec2    a_uv;
        varying     vec2    v_uv;

        void main( void ){
            v_uv = a_uv;
            gl_Position = vec4( a_position.xy, 0., 1. );
        }
    `;
    RRender.fs = `
        precision highp float;
        precision highp int;

        uniform sampler2D   u_sampler;
        varying     vec2    v_uv;

        void main( void ){
            gl_FragColor = texture2D( u_sampler, v_uv );
        }
    `;
    RRender.nextPowerOfTwo = (value) => {
        --value;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        return ++value;
    };
});

_$pi.define("pi_gui/gui/gui/r_event_limiter", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 事件触发时的限制器
     */
    class REventLimiter {
        constructor(doc) {
            /**
             * 限制时间
             */
            this.forbidEventTime = 0;
            /**
             * 限制范围
             * [left, top, wdith, height]
             */
            this.allowEventRect = [0, 0, 0, 0];
            this.document = doc;
        }
        /**
         * 检查事件是否在允许范围
         * @param x 事件坐标
         * @param y 事件坐标
         */
        checkLimit(x, y) {
            if (this.allowEventRect[2] === 0
                || this.allowEventRect[3] === 0) {
                return true;
            }
            else {
                return (this.allowEventRect[0] < x && x < this.allowEventRect[0] + this.allowEventRect[2] && this.allowEventRect[1] < y && y < this.allowEventRect[1] + this.allowEventRect[3]);
            }
        }
        /**
         * 指定范围(左上角x1y1, 右下角x2y2)外，禁止鼠标和触控事件，直到超时时间
         * @param timeOut 延时时间
         * @param rect 矩形坐标
         */
        setForbid(timeOut, rect) {
            this.forbidEventTime = timeOut ? Date.now() + timeOut : 0;
            if (rect) {
                this.allowEventRect[0] = this.document.viewOption.left + rect[0];
                this.allowEventRect[1] = this.document.viewOption.top + rect[1];
                this.allowEventRect[2] = rect[2];
                this.allowEventRect[3] = rect[3];
            }
            else {
                this.allowEventRect[0] = this.allowEventRect[1] = this.allowEventRect[2] = this.allowEventRect[3] = 0;
            }
        }
        /**
         * 检查事件是否被限制响应
         * @param x 事件点 坐标
         * @param y 事件点 坐标
         */
        checkForbid(x, y) {
            let res = false;
            if (this.forbidEventTime > 0) {
                if (Date.now() < this.forbidEventTime) {
                    res = true;
                }
                else {
                    this.forbidEventTime = 0;
                }
            }
            if (res || !this.checkLimit(x, y)) {
                res = true;
            }
            return res;
        }
    }
    exports.REventLimiter = REventLimiter;
});

/**
 * gui 文本节点结构
 */
_$pi.define("pi_gui/gui/gui/r_textelement", ["require", "exports", "./gui", "./r_datastruct", "./r_element", "./tools"], function (require, exports, gui_1, r_datastruct_1, r_element_1, tools_1) {
    "use strict";
    
    /**
     * 文本节点
     */
    class RTextElement extends r_element_1.RElement {
        constructor(opt) {
            opt.uniqueID = gui_1.gui._create_text_node(opt.document.uniqueID);
            super(opt);
            this._type = r_datastruct_1.RElementTypeList.SPAN;
            this.initDefaultStyle('span');
            // if (RTextElement.defualClassID) {
            //     this.document.sheet.setNodeStyleClass(this, RTextElement.defualClassID);
            // }
            if (r_element_1.RElement.defualtTextClassIDs) {
                this.document.sheet.setNodeStyleClass(this, r_element_1.RElement.defualtTextClassIDs);
            }
        }
        /**
         * 文本内容
         */
        get nodeValue() {
            return this._nodeValue;
        }
        /**
         * 文本内容
         */
        set nodeValue(data) {
            if (RTextElement.BeforeDisplayCall) {
                data = RTextElement.BeforeDisplayCall(data);
            }
            this._nodeValue = data;
            if (this._isDestroy) {
                return;
            }
            window.__jsObj = `${data}`;
            gui_1.gui._set_text_content(this.document.uniqueID, this.uniqueID);
            tools_1.Tools.log(data);
        }
        // public remove() {
        //     super.remove();
        // }
        createCall() {
            //
        }
    }
    exports.RTextElement = RTextElement;
});

/**
 * gui textarea 节点
 */
_$pi.define("pi_gui/gui/gui/r_textarea", ["require", "exports", "./r_datastruct", "./r_inputtext"], function (require, exports, r_datastruct_1, r_inputtext_1) {
    "use strict";
    
    class RTextArea extends r_inputtext_1.RInputText {
        constructor(opt) {
            super(opt);
            this._type = r_datastruct_1.RElementTypeList.textarea;
        }
        /**
         * 文本显示的 align 布局设置调用
         * * TextArea 默认不设置
         */
        alignSet() {
            //
        }
    }
    exports.RTextArea = RTextArea;
});

/**
 * gui Input 节点
 * * canvas 上处理原始事件时必须阻止默认处理，否则 Dom 中 Input 获得焦点后会立即失去焦点<因为其他事件的查询导致>
 */
_$pi.define("pi_gui/gui/gui/r_inputtext", ["require", "exports", "./r_containerelement", "./r_datastruct", "./r_event_base"], function (require, exports, r_containerelement_1, r_datastruct_1, r_event_base_1) {
    "use strict";
    
    class RInputText extends r_containerelement_1.RContainerElement {
        constructor(opt) {
            super(opt);
            this._value = '';
            this._display = '';
            this._placeholder = '';
            this._hasDown = false;
            /**
             * 文本字符串最大长度
             */
            this._maxLength = 100;
            // // 事件响应相关
            // public click(e: REventData) {
            //     // 激活输入
            //     this.active();
            //     // 停止冒泡
            //     e.isPostprocess = true;
            //     super.click(e);
            // }
            /**
             * 更新
             */
            this.changeText = (text) => {
                this.value = text;
            };
            /**
             * 输入结束，重置
             */
            this.resetText = (text) => {
                this.value = text;
            };
            /**
             * 结束/取消输入
             */
            this.cacel = () => {
                if (RInputText.isWXGame() || RInputText.inputText === RInputText.inputTextNotWork) {
                    this.unbindEvent2();
                }
                else {
                    RInputText.domBlur({});
                    this.unbindEvent();
                }
                this.hiddenCursor();
            };
            this.inputProcessKey = (key) => {
                // console.warn('inputProcessKey OK');
                // this.processKey(-1, key);
            };
            this.endProcessKey = (key) => {
                // console.warn('endProcessKey OK');
                // this.processKey(35, key);
                this.value = key;
            };
            this._type = r_datastruct_1.RElementTypeList.input;
            this.createInputText();
            this.createSpan();
            this.createCursor();
        }
        /**
         * 文本内容
         */
        get value() {
            return this._value;
        }
        /**
         * 文本内容
         */
        set value(data) {
            if (this._value !== data) {
                this._value = `${data}`;
                this.drawSpan(true);
                // Tools.log('value', data);
                this.change({ type: 'change', target: this });
            }
            else {
                this.drawSpan();
            }
        }
        /**
         * 文本内容
         */
        set placeholder(data) {
            this._placeholder = `${data}`;
            this.drawSpan();
            this.change({ type: 'change', target: this });
        }
        static toColorHex(num) {
            const str = `0${(Math.round(num * 255)).toString(16)}`;
            return str.substr(str.length - 2, 2);
        }
        /**
         * 是否为 WX 小游戏环境
         */
        static isWXGame() {
            return !!window.wx;
        }
        /**
         * 添加事件监听
         */
        addEventListener(_type, _listener) {
            if (_type === r_event_base_1.REventTypes.change) {
                !this.changeListener && (this.changeListener = r_event_base_1.ListenerListMgr.create());
                this.changeListener.add(_listener);
            }
            else {
                super.addEventListener(_type, _listener);
            }
        }
        /**
         * 移除监听
         * @param _type 监听类型
         * @param _listener 监听方法
         */
        removeEventListener(_type, _listener) {
            if (_type === r_event_base_1.REventTypes.change) {
                this.changeListener.remove(_listener);
            }
            else {
                super.removeEventListener(_type, _listener);
            }
        }
        /**
         * 清空事件监听
         */
        clearListener() {
            super.clearListener();
            r_event_base_1.ListenerListMgr.recycle(this.changeListener);
        }
        // 事件响应相关
        down(e) {
            // 激活输入
            // this.active();
            this._hasDown = true;
            // 停止冒泡
            e.stopPropagation = true;
            super.down(e);
            this.drawSpan();
        }
        // 事件响应相关
        up(e) {
            // 激活输入
            if (this._hasDown && !e.isOnlyBubble) {
                // this.active();
            }
            e.isOnlyBubble = true;
            this._hasDown = false;
            super.up(e);
        }
        focus(e) {
            super.focus(e);
            this.active();
        }
        blur(e) {
            this.cacel();
            super.blur(e);
        }
        change(e) {
            const evt = {
                x: 0,
                y: 0,
                lastX: 0,
                lastY: 0,
                deltaX: 0,
                deltaY: 0,
                type: 'change',
                pointerType: r_event_base_1.REventTypes.wheel,
                pointerID: -1,
                stopPropagation: false,
                preventDefault: false,
                timeStamp: this.document.timeStamp,
                pointers: [],
                path: [],
                timeNow: this.document.timeStamp,
                isPrimary: true
            };
            evt.current = this;
            evt.source = this;
            this.changeListener && this.changeListener.notify(evt);
        }
        remove() {
            this.cacel();
            super.remove();
        }
        alignSet() {
            this.document.applyStyle(this.style, 'alignItems', 2)
                .applyStyle(this.style, 'alignContent', 2);
        }
        drawSpan(asValue) {
            if (asValue || this._hasDown || this._value.length > 0) {
                this._display = this._value;
                this.clipLength();
                this.checkPassWord();
            }
            else {
                this._display = this._placeholder;
            }
            // 绘制
            this._span.nodeValue = this._display;
            // gui._set_text_content(this.document.uniqueID, this._span.uniqueID, this._display);
        }
        createInputText() {
            if (RInputText.inputText !== undefined) {
                return;
            }
            try {
                RInputText.inputText = document.createElement('input');
                RInputText.inputText.onchange = RInputText.domChange;
                RInputText.inputText.oninput = RInputText.domChange;
                RInputText.inputText.style.display = 'none';
                RInputText.inputText.style.position = 'absolute';
                RInputText.inputText.style.zIndex = '1000000';
                RInputText.inputText.style.left = `-1000px`;
                RInputText.inputText.style.top = `-1000px`;
                document.body.appendChild(RInputText.inputText);
            }
            catch (error) {
                RInputText.inputText = RInputText.inputTextNotWork;
            }
        }
        createSpan() {
            this._span = this.document.createElement('span');
            this.appendChild(this._span);
            // this._content.appendChild(this._span);
            this.alignSet();
            setTimeout(() => {
                if (this._isDestroy) {
                    return;
                }
                const p = this.style;
                const a = this._span.style;
                // this._span.style.width        = this.style.width;
                // this._span.style.height       = this.style.height;
                let temp = this.document.readStyle(p, 'color');
                temp && (this.document.applyStyle(a, 'color', temp));
                temp = this.document.readStyle(p, 'fontFamily');
                temp && (this.document.applyStyle(a, 'fontFamily', temp));
                temp = this.document.readStyle(p, 'fontSize');
                temp && (this.document.applyStyle(a, 'fontSize', temp));
                temp = this.document.readStyle(p, 'fontWeight');
                temp && (this.document.applyStyle(a, 'fontWeight', temp));
                temp = this.document.readStyle(p, 'fontStyle');
                temp && (this.document.applyStyle(a, 'fontStyle', temp));
            }, 20);
        }
        clipLength() {
            const attributes = this.attributes;
            if (attributes.maxLength !== undefined) {
                const len = Math.min(attributes.maxLength, this._value.length);
                this._value = this._value.substr(0, len);
                // 超出${this.attributes.maxLength}部分被忽略
            }
            if (attributes.minLength !== undefined) {
                if (attributes.minLength > this._value.length) {
                    // 最小字符数${this.attributes.maxLength}
                }
            }
        }
        checkPassWord() {
            const attributes = this.attributes;
            if (attributes.type === 'password') {
                this._display = '';
                for (let i = this._value.length - 1; i >= 0; i--) {
                    this._display += '\u2022';
                }
            }
        }
        /**
         * 激活输入
         */
        active() {
            if (RInputText.isWXGame() || RInputText.inputText === RInputText.inputTextNotWork) {
                this.bindEvent2();
            }
            else {
                this.bindEvent();
            }
            this.renderCursor();
        }
        bindEvent() {
            RInputText.inputText.style.display = 'block';
            if (this._value !== undefined && this._value !== '') {
                RInputText.inputText.value = this._value;
            }
            else {
                RInputText.inputText.value = '';
            }
            for (const k in this.attributes) {
                RInputText.inputText[k] = this.attributes[k];
            }
            RInputText.domChangeCall = this.changeText;
            RInputText.domBlurCall = undefined;
            RInputText.inputText.focus({ preventScroll: true });
        }
        unbindEvent() {
            for (const k in this.attributes) {
                RInputText.inputText[k] = undefined;
            }
            RInputText.domChangeCall = undefined;
            RInputText.domBlurCall = undefined;
            RInputText.inputText.blur();
            RInputText.inputText.style.display = 'none';
        }
        bindEvent2() {
            this.createKeyBoard();
        }
        unbindEvent2() {
            //
        }
        createKeyBoard() {
            const _window = window;
            // console.warn('createKeyBoard');
            if (_window.Keyboard) {
                const keyBoard = _window.Keyboard;
                keyBoard.onInput = this.inputProcessKey;
                keyBoard.onEnd = this.endProcessKey;
                keyBoard.show({
                    maxLength: this._maxLength,
                    defaultValue: this.value,
                    multiple: true
                });
                console.warn('keyBoard OK');
            }
        }
        renderCursor() {
            this.document.applyStyle(this._cursor.style, 'display', 'flex');
        }
        hiddenCursor() {
            this.document.applyStyle(this._cursor.style, 'display', 'none');
        }
        createCursor() {
            const opt = {
                document: this.document,
                RenderFlag: this.document.RenderFlag
            };
            this._cursor = new r_containerelement_1.RContainerElement(opt);
            this.document
                .applyStyle(this._cursor.style, 'backgroundColor', '#eeeeee')
                .applyStyle(this._cursor.style, 'width', '3px');
            setTimeout(() => {
                if (this._isDestroy) {
                    return;
                }
                this.document
                    .applyStyle(this._cursor.style, 'height', `${this.document.readStyle(this._span.style, 'fontSize')}px`);
            }, 50);
            this.hiddenCursor();
            this.appendChild(this._cursor);
        }
    }
    exports.RInputText = RInputText;
    /**
     * DOM 实现的 Input 是否正常工作的标识
     */
    RInputText.inputTextNotWork = {};
    /**
     * dom 节点 操作响应
     */
    RInputText.domChange = (e) => {
        RInputText.domChangeCall && RInputText.domChangeCall(RInputText.inputText.value);
    };
    /**
     * DOM input 节点blur 调用
     */
    RInputText.domBlur = (e) => {
        RInputText.domChange(e);
        RInputText.domChangeCall = undefined;
    };
});

/**
 * R gui 事件管理器
 */
_$pi.define("pi_gui/gui/gui/r_event", ["require", "exports", "./gui", "./r_event_base"], function (require, exports, gui_1, r_event_base_1) {
    "use strict";
    
    class REventManager {
        constructor(vdocument) {
            /**
             * 根据事件 ID 记录事件执行数据
             * * up 事件结束后 清除所有非主事件，清除非当前主事件，仅保留当前主事件以供下一个事件使用
             */
            // public readonly pointerRecordMap:     Map<number, PointerRecord> = new Map();
            this.pointerRecordList = [];
            /**
             * down 事件
             * * 创建指针事件记录数据
             * * 为非主事件 - 清除长按句柄
             * * 为主事件 - 创建长按句柄 - 创建 down 结果记录
             */
            this.downFire = (e) => {
                let pointerRecord, source, evt;
                evt = this.getEventData(e);
                source = this.pickResult(evt);
                evt.source = source;
                if (evt.isPrimary) {
                    this.clearPointerRecord();
                }
                // 清除优化设置
                this.vdocument.willChangeClear();
                if (!source) {
                    return;
                }
                // 事件触发前
                pointerRecord = this.createPointerRecord(evt);
                pointerRecord.isLongTap = false;
                pointerRecord.isMove = false;
                pointerRecord.moveStartX = evt.x;
                pointerRecord.moveStartY = evt.y;
                pointerRecord.currX = evt.x;
                pointerRecord.currY = evt.y;
                pointerRecord.isDown = true;
                if (pointerRecord.isPrimary !== true) {
                    this.clearLongTapHandler();
                }
                else {
                    pointerRecord.longTapHandler = setTimeout(() => { this.longTapFire(e); }, REventManager.LongTapEffectiveTimeDiff);
                    // 事件起点
                    if (source !== undefined) {
                        evt.isSendNextLayer = source.attributes.isSendNextLayer;
                        source.down(evt);
                        if (this.downResult && this.downResult.path[0] && !this.downResult.path[0].isDestroy) {
                            if (this.downResult.path[0] !== source) {
                                this.downResult.path[0].blur(evt);
                                source.focus(evt);
                            }
                        }
                        else {
                            source.focus(evt);
                        }
                    }
                    this.downResult = new r_event_base_1.REventResult(evt);
                }
            };
            /**
             * up 事件
             * * 未获得指针事件记录数据 - 不响应
             * * 清除长按句柄
             * * 非主事件 - 不响应
             * * 响应后 - 后处理
             * * 清除非当前主事件指针记录
             */
            this.upFire = (e) => {
                let source, evt;
                // alert(`no ${e.pointerId}`);
                // 清理 move 记录
                this.moveResult = undefined;
                // const pointerRecord = this.pointerRecordMap.get(e.pointerId);
                const pointerRecord = this.readPointerRecord(e.pointerId);
                // 清除优化设置
                this.vdocument.willChangeClear();
                if (!pointerRecord) {
                    return;
                }
                evt = this.getEventData(e);
                source = this.pickResult(evt);
                evt.source = source;
                if (source) {
                    this.clearLongTapHandler();
                    pointerRecord.currX = evt.x;
                    pointerRecord.currY = evt.y;
                    if (!pointerRecord.isPrimary) {
                        //
                    }
                    else {
                        // 事件起点
                        // evt.isSendNextLayer = <boolean>source.attributes.isSendNextLayer;
                        evt.isSendNextLayer = true;
                        source.up(evt);
                        this.upPostprocess(e, evt);
                    }
                }
                else {
                    evt.isSendNextLayer = true;
                    evt.isPostprocess = true;
                    // 之前down 事件路径上可能有节点已经被销毁
                    for (let i = 0, len = this.downResult.path.length - 1; i <= len; i++) {
                        source = this.downResult.path[i];
                        if (!source.isDestroy) {
                            source.up(evt);
                            break;
                        }
                    }
                }
                // 事件触发后
                pointerRecord.isMove = false;
                pointerRecord.isDown = false;
                pointerRecord.isLongTap = false;
                this.removePointerRecordID(e.pointerId);
                if (evt.pointerID === this.pointerPrimaryID) {
                    this.pointerPrimaryID = undefined;
                }
            };
            /**
             * 移动事件
             * * 未获取到指针事件记录数据 - 不响应
             * * 未到达 move 有效距离 - 不响应
             * * 非主事件 - 不响应 - 响应多点事件
             * * 成功响应 - 清除长按句柄
             */
            this.moveFire = (e) => {
                let source, evt;
                // 清理 wheel
                this.wheelResult = undefined;
                // const pointerRecord = this.pointerRecordMap.get(e.pointerId);
                const pointerRecord = this.readPointerRecord(e.pointerId);
                if (!pointerRecord || !pointerRecord.isDown) {
                    return;
                }
                evt = this.getEventData(e);
                // source      = this.pickResult(evt);
                // source      = this.downResult.path[0];
                // this.downResult.path.forEach(v => {
                //     if (!source && v.isDestroy === false) {
                //         source = v;
                //     }
                // });
                for (let i = 0, len = this.downResult.path.length - 1; i <= len; i++) {
                    if (this.downResult.path[i].isDestroy === false) {
                        source = this.downResult.path[i];
                        break;
                    }
                }
                evt.source = source;
                if (!source) {
                    return;
                }
                this.checkMoveEffective(pointerRecord, evt);
                if (!pointerRecord.isMove) {
                    return;
                }
                else {
                    this.clearLongTapHandler();
                }
                pointerRecord.currX = evt.x;
                pointerRecord.currY = evt.y;
                if (this.pointerRecordList.length > 1) {
                    // 清理 move 记录， 多点操作生效后，主 move 失效
                    this.moveResult = undefined;
                    this.multiPointerFire(e, source);
                }
                else {
                    const wheelEvt = this.getEventData(e);
                    wheelEvt.source = source;
                    if (this.moveResult) {
                        evt.lastX = this.moveResult.x;
                        evt.lastY = this.moveResult.y;
                        evt.deltaX = evt.lastX - evt.x;
                        evt.deltaY = evt.lastY - evt.y;
                        wheelEvt.lastX = this.moveResult.x;
                        wheelEvt.lastY = this.moveResult.y;
                        wheelEvt.deltaX = evt.lastX - evt.x;
                        wheelEvt.deltaY = evt.lastY - evt.y;
                    }
                    else {
                        evt.lastX = evt.x;
                        evt.lastY = evt.y;
                        evt.deltaX = 0;
                        evt.deltaY = 0;
                        wheelEvt.lastX = evt.x;
                        wheelEvt.lastY = evt.x;
                        wheelEvt.deltaX = 0;
                        wheelEvt.deltaY = 0;
                    }
                    // 事件起点
                    if (source !== undefined) {
                        evt.isSendNextLayer = source.attributes.isSendNextLayer;
                        source.move(evt);
                        source.wheel(wheelEvt);
                    }
                    this.moveResult = undefined;
                    this.moveResult = new r_event_base_1.REventResult(evt);
                }
            };
            /**
             * 单击事件响应
             * @param e 事件数据
             * @param source 事件起点
             * * 响应单击 - 尝试合成双击
             */
            this.clickFire = (e, source) => {
                let evt;
                evt = this.getEventData(e);
                evt.type = r_event_base_1.REventTypes.click;
                evt.pointerType = r_event_base_1.REventTypes.click;
                evt.source = source;
                // 事件起点
                if (source !== undefined) {
                    evt.isSendNextLayer = source.attributes.isSendNextLayer;
                    source.click(evt);
                    this.clickPostprocess(e, evt);
                }
            };
            /**
             * 双击事件响应
             * @param e 事件数据
             * @param source 事件起点
             */
            this.dbclickFire = (e, source) => {
                let evt;
                evt = this.getEventData(e);
                evt.type = r_event_base_1.REventTypes.dbclick;
                evt.pointerType = r_event_base_1.REventTypes.dbclick;
                evt.source = source;
                // 事件起点
                if (source !== undefined) {
                    evt.isSendNextLayer = source.attributes.isSendNextLayer;
                    source.dbclick(evt);
                }
            };
            /**
             * 长按事件
             * * 句柄被清除 - 不响应
             * * 当前指针已产生移动 - 不响应
             */
            this.longTapFire = (e) => {
                let source, evt, result = true;
                const currPath = [];
                // const pointerRecord = this.pointerRecordMap.get(e.pointerId);
                const pointerRecord = this.readPointerRecord(e.pointerId);
                if (!pointerRecord) {
                    return;
                }
                evt = this.getEventData(e);
                evt.type = r_event_base_1.REventTypes.longTap;
                evt.pointerType = r_event_base_1.REventTypes.longTap;
                pointerRecord.longTapHandler && clearTimeout(pointerRecord.longTapHandler);
                pointerRecord.longTapHandler = undefined;
                if (pointerRecord.isMove) {
                    return;
                }
                pointerRecord.isLongTap = true;
                source = this.pickResult(evt);
                if (!source) {
                    return;
                }
                // 从事件源节点 向上遍历节点至根节点 - 记录这些节点为 longTap 响应节点
                while (result) {
                    currPath.push(source);
                    if (source.parentNode && source.level >= 0) {
                        source = source.parentNode;
                    }
                    else {
                        result = false;
                    }
                }
                const [sames, firstDiffs, secondDiffs] = REventManager.comparePath(this.downResult.path, currPath);
                source = undefined;
                sames.forEach((v) => {
                    if (!source && v.isDestroy === false) {
                        source = v;
                    }
                });
                if (source) {
                    evt.source = source;
                    evt.isSendNextLayer = evt.source.attributes.isSendNextLayer;
                    source.longTap(evt);
                }
            };
            /**
             * 多点操作
             * * TODO - 确定节点响应接口
             * * TODO - 确定是否只在全局监听
             */
            this.multiPointerFire = (e, source) => {
                let evt;
                evt = this.getEventData(e);
                evt.type = r_event_base_1.REventTypes.multiPointer;
                evt.pointerType = r_event_base_1.REventTypes.multiPointer;
                // 放入当前 主事件信息
                // const primary   = this.pointerRecordMap.get(this.pointerPrimaryID);
                // const primary   = this.readPointerRecord(this.pointerPrimaryID);
                // evt.pointers.push({ x: primary.currX, y: primary.currY });
                // 放入当前 所有非主事件信息
                // this.pointerRecordMap.forEach((v, k) => {
                //     if (v.isPrimary !== true) {
                //         evt.pointers.push({ x: v.currX, y: v.currY });
                //     }
                // });
                this.pointerRecordList.forEach((v, k) => {
                    // if (v.isPrimary !== true) {
                    evt.pointers.push({ x: v.currX, y: v.currY, id: v.pointerID });
                    // }
                });
                if (source === undefined) {
                    evt.pointers.push({ x: 0, y: 0, id: 0 });
                }
                else {
                    evt.pointers.push({ x: 1, y: 1, id: source.uniqueID });
                }
                // 事件触发
                evt.source = source;
                // 事件起点
                if (source !== undefined) {
                    evt.isSendNextLayer = source.attributes.isSendNextLayer;
                    source.multipointer(evt);
                }
                // evt.pointers.push({ x: 1, y: 1, id: source.uniqueID, len: evt.path.length, Postprocess: evt.isPostprocess, stopPropagation: evt.stopPropagation  });
                // log(evt.pointers);
            };
            /**
             * 检测是否正在 move 操作
             */
            this.checkMoving = () => {
                return this.moveResult !== undefined;
            };
            this.vdocument = vdocument;
        }
        /**
         * 寻找两条节点路径中的第一个共同节点
         * @param firstPath 第一条节点路径
         * @param secondPath 第二条节点路径
         * @returns [samePart, firstHead, secondHead]
         */
        static comparePath(_firstPath, _secondPath) {
            let firstEle, secondEle, firstIndex, secondIndex, isLoop = true;
            const firstPath = [];
            const secondPath = [];
            const samePart = [];
            const firstHead = [];
            const secondHead = [];
            _firstPath.forEach((ele) => {
                if (!ele.isDestroy) {
                    firstPath.push(ele);
                }
            });
            _secondPath.forEach((ele) => {
                if (!ele.isDestroy) {
                    secondPath.push(ele);
                }
            });
            firstIndex = 0;
            secondIndex = 0;
            // 从路径源头节点向上遍历
            while (isLoop) {
                firstEle = firstPath[firstIndex];
                secondEle = secondPath[secondIndex];
                if (firstEle && secondEle) {
                    if (firstEle.level > secondEle.level) {
                        firstIndex++;
                        firstHead.push(firstEle);
                    }
                    else if (firstEle.level < secondEle.level) {
                        secondIndex++;
                        secondHead.push(secondEle);
                    }
                    else {
                        firstIndex++;
                        secondIndex++;
                        if (firstEle === secondEle) {
                            samePart.push(secondEle);
                            isLoop = false;
                        }
                        else {
                            firstHead.push(firstEle);
                            secondHead.push(secondEle);
                        }
                    }
                }
                else {
                    isLoop = false;
                }
            }
            if (firstEle === undefined) {
                for (let i = secondIndex, len = secondPath.length - 1; i <= len; i++) {
                    secondHead.push(secondPath[i]);
                }
            }
            if (secondEle === undefined) {
                for (let i = firstIndex, len = firstPath.length - 1; i <= len; i++) {
                    firstPath.push(firstPath[i]);
                }
            }
            return [samePart, firstHead, secondHead];
        }
        /**
         * 获取节点事件信息
         * @param e 原生事件信息
         */
        getEventData(e) {
            let evt;
            evt = {};
            Object.keys(e).forEach((key) => {
                evt[key] = e[key];
            });
            evt.x = e.clientX;
            evt.y = e.clientY;
            evt.type = e.type;
            evt.pointerType = e.pointerType;
            evt.pointerID = e.pointerId;
            evt.stopPropagation = false;
            evt.preventDefault = () => { e.preventDefault(); };
            evt.timeStamp = Date.now();
            evt.pointers = [];
            evt.path = [];
            evt.timeNow = evt.timeStamp;
            evt.isPrimary = e.isPrimary; // || this.pointerPrimaryID === undefined || e.pointerId === this.pointerPrimaryID;
            if (evt.isPrimary) {
                this.pointerPrimaryID = evt.pointerID;
            }
            return evt;
        }
        /**
         * 获取节点事件信息
         * @param e 原生事件信息
         */
        getEventDataWheel(e) {
            let evt;
            if (e.deltaMode === 0x00) {
                evt = {};
                Object.keys(e).forEach((key) => {
                    evt[key] = e[key];
                });
                evt.x = e.clientX;
                evt.y = e.clientY;
                evt.lastX = evt.x;
                evt.lastY = evt.y;
                evt.deltaX = e.deltaX || e.deltaY; // ***
                evt.deltaY = e.deltaY;
                evt.type = e.type;
                evt.pointerType = r_event_base_1.REventTypes.wheel;
                evt.pointerID = -1;
                evt.stopPropagation = false;
                evt.preventDefault = () => { e.preventDefault(); };
                evt.timeStamp = Date.now();
                evt.pointers = [];
                evt.path = [];
                evt.timeNow = evt.timeStamp;
                evt.isPrimary = true;
            }
            return evt;
        }
        /**
         * 获取节点事件信息
         * @param e 原生事件信息
         */
        createPointerRecord(evt) {
            let pointerRecord;
            // pointerRecord = this.pointerRecordMap.get(evt.pointerID);
            const index = this.pointerRecordList.findIndex((v) => v.pointerID === evt.pointerID);
            // if (pointerRecord === undefined) {
            //     pointerRecord = new PointerRecord(evt.pointerID, evt.isPrimary);
            //     this.pointerRecordMap.set(evt.pointerID, pointerRecord);
            // }
            if (index < 0) {
                pointerRecord = new r_event_base_1.PointerRecord(evt.pointerID, evt.isPrimary);
                this.pointerRecordList.push(pointerRecord);
            }
            else {
                pointerRecord = this.pointerRecordList[index];
            }
            return pointerRecord;
        }
        /**
         * down 事件发生时，目标 id 为 primary 则忽略该次事件前的所有事件
         * * 某些设备上有系统级操作，最终没有返回事件到应用<三指截屏><浏览器debug断点>
         */
        clearPointerRecord() {
            this.pointerRecordList.length = 0;
        }
        readPointerRecord(id) {
            return this.pointerRecordList.find((v) => v.pointerID === id);
        }
        removePointerRecord(evt) {
            const index = this.pointerRecordList.findIndex((v) => v.pointerID === evt.pointerID);
            if (index >= 0) {
                this.pointerRecordList.splice(index, 1);
            }
        }
        removePointerRecordID(id) {
            const index = this.pointerRecordList.findIndex((v) => v.pointerID === id);
            if (index >= 0) {
                this.pointerRecordList.splice(index, 1);
            }
        }
        /**
         * 检测移动事件有效性
         * @param pointerRecord 事件记录 - 已 pointerId 为标识的 事件记录，记录执行情况
         * @param evt 事件数据
         */
        checkMoveEffective(pointerRecord, evt) {
            if (pointerRecord.isMove !== true) {
                if (Math.pow((pointerRecord.moveStartX - evt.x), 2) + Math.pow((pointerRecord.moveStartY - evt.y), 2) > Math.pow(REventManager.MoveEffectiveDistanceDiff, 2)) {
                    pointerRecord.moveStartX = evt.x;
                    pointerRecord.moveStartY = evt.y;
                    pointerRecord.isMove = true;
                }
            }
        }
        /**
         * 检测点击事件有效性
         * @param pointerRecord 事件记录 - 已 pointerId 为标识的 事件记录，记录执行情况
         * @param evt 事件数据
         */
        checkClickEffective(pointerRecord, evt) {
            pointerRecord.isClickEffective = false;
            // 时间检查 && 空间检查
            if (evt.timeNow - this.downResult.time < REventManager.ClickEffectiveTimeDiff
                && Math.pow((this.downResult.x - evt.x), 2) + Math.pow((this.downResult.y - evt.y), 2) < Math.pow(REventManager.CilickEffectiveDistancwDiff, 2)) {
                pointerRecord.isClickEffective = true;
            }
        }
        /**
         *
         * @param e .
         * 1. 命中的元素,
         * 2. 响应-冒泡
         * 3. 有 pointer 事件时 忽略wheel
         */
        wheelFire(e) {
            let source, evt;
            if (this.pointerPrimaryID !== undefined) {
                return;
            }
            evt = this.getEventDataWheel(e);
            if (evt) {
                source = this.pickResult(evt);
                evt.source = source;
                if (!source) {
                    return;
                }
                if (this.wheelResult) {
                    evt.lastX = this.wheelResult.x;
                    evt.lastY = this.wheelResult.y;
                }
                evt.isSendNextLayer = source.attributes.isSendNextLayer;
                source.wheel(evt);
                this.wheelResult = undefined;
                this.wheelResult = new r_event_base_1.REventResult(evt);
            }
            else {
                this.wheelResult = undefined;
            }
        }
        pickResult(evt) {
            let resultEle;
            // const id    = gui._iter_query(this.vdocument.uniqueID, evt.x, evt.y);
            const id = gui_1.gui._query(this.vdocument.uniqueID, evt.x, evt.y);
            resultEle = this.vdocument.elementMap.get(id);
            if (this.vdocument.debug) {
                if (resultEle && this.currPick !== resultEle) {
                    evt.source = resultEle;
                    resultEle.debugFocus();
                    this.currPick = resultEle;
                }
                if (resultEle === undefined && this.currPick !== undefined) {
                    this.currPick.debugBlur();
                }
                resultEle = undefined;
            }
            return resultEle;
        }
        debugFocus(ele) {
            if (ele && this.currPick !== ele) {
                ele.debugFocus();
                this.currPick = ele;
            }
            if (ele === undefined && this.currPick !== undefined) {
                this.currPick.debugBlur();
            }
        }
        /**
         * up 事件响应后处理
         * @param e up 事件源数据
         * @param evt up 事件模拟数据
         * @param pointerRecord up 事件记录数据
         */
        upPostprocess(e, evt) {
            // const pointerRecord = this.pointerRecordMap.get(evt.pointerID);
            const pointerRecord = this.readPointerRecord(evt.pointerID);
            if (!pointerRecord) {
                return;
            }
            evt.isPostprocess = true;
            const [sames, firstDiffs, secondDiffs] = REventManager.comparePath(this.downResult.path, evt.path);
            firstDiffs.forEach((ele) => {
                ele.up(evt);
            });
            // 检查 点击的有效性
            this.checkClickEffective(pointerRecord, evt);
            // up 与 down 时间间隔不符合 click 判定
            if (!pointerRecord.isClickEffective || pointerRecord.isLongTap) {
                return;
            }
            sames[0] && this.clickFire(e, sames[0]);
        }
        /**
         * click 事件响应后处理
         * @param e click 事件源数据
         * @param evt click 事件模拟数据
         * @param pointerRecord click 事件记录数据
         */
        clickPostprocess(e, evt) {
            // 没有前一次点击的记录
            if (!this.clickResult) {
                this.clickResult = new r_event_base_1.REventResult(evt);
                return;
            }
            // 两次 click 时间间隔不符合 click 判定
            if (evt.timeNow - this.clickResult.time > REventManager.DBClickEffectiveTimeDiff) {
                this.clickResult = new r_event_base_1.REventResult(evt);
                return;
            }
            evt.isPostprocess = true;
            const [sames, firstDiffs, secondDiffs] = REventManager.comparePath(this.clickResult.path, evt.path);
            // if (sames.length > 0) {
            //     this.dbclickFire(e, sames[0]);
            // }
            for (let i = 0, len = sames.length - 1; i <= len; i++) {
                if (sames[i].isDestroy === false) {
                    this.dbclickFire(e, sames[i]);
                    break;
                }
            }
            // 双击后 清除 click 记录 - 避免一直响应双击
            this.clickResult = undefined;
        }
        downPostprocess(evt, pointerRecord) {
            //
        }
        /**
         * 清除 长按延时句柄
         */
        clearLongTapHandler() {
            // this.pointerRecordMap.forEach(data => {
            //     if (data.longTapHandler) {
            //         clearTimeout(data.longTapHandler);
            //         data.longTapHandler = undefined;
            //     }
            // });
            this.pointerRecordList.forEach((data) => {
                if (data.longTapHandler) {
                    clearTimeout(data.longTapHandler);
                    data.longTapHandler = undefined;
                }
            });
        }
    }
    exports.REventManager = REventManager;
    /**
     * down - move 空间间隔 限制 click 响应
     */
    REventManager.CilickEffectiveDistancwDiff = 30;
    /**
     * down - up 时间间隔 限制限制时间内 click 响应
     */
    REventManager.ClickEffectiveTimeDiff = 600;
    /**
     * 两次点击时间间隔 限制时间内的 两次click 为 dbclick 响应
     */
    REventManager.DBClickEffectiveTimeDiff = 800;
    /**
     * down 之后 longTap 响应延时时间
     */
    REventManager.LongTapEffectiveTimeDiff = 1000;
    /**
     * move 移动事件的启动距离
     */
    REventManager.MoveEffectiveDistanceDiff = 30;
});
// let div: HTMLDivElement;
// const log  = (arg) => {
//     if (!div) {
//         div = document.createElement('div');
//         document.body.appendChild(div);
//         div.style.cssText = 'position:absolute;color:#f00;';
//     }
//     div.innerText = typeof arg === 'string' ? arg :  JSON.stringify(arg);
// };

/**
 * GUI CSS 动画循环
 * * 每个 gui 帧执行一次
 * * 遍历记录的节点表
 * * 遍历各节点的动画表
 * * 遍历各节点的各动画的样式表
 * * 计算各节点的各动画的各样式的当前值
 * * 应用 计算出的样式值
 */
_$pi.define("pi_gui/gui/gui/animation", ["require", "exports", "./animation_tools", "./math_tools", "./tools"], function (require, exports, animation_tools_1, math_tools_1, tools_1) {
    "use strict";
    
    // tslint:disable-next-line:no-unnecessary-class
    class AnimationControl {
        /**
         * GUI 动画的帧循环调用
         * * GUI 渲染循环内会在GUI渲染前调用
         */
        static loop() {
            this.now = Date.now();
            this.animeMap.forEach((v, k) => {
                this.analy(v);
            });
        }
        /**
         * 添加一个目标节点的动画
         * @param anime 动画表
         */
        static add(anime) {
            if (anime.lastTime === undefined) {
                anime.lastTime = this.now || Date.now();
            }
            this.animeMap.set(anime.target, anime);
        }
        /**
         * 取消目标节点的动画
         * @param anime 动画表
         */
        static remove(anime) {
            this.animeMap.delete(anime.target);
        }
        /**
         * 解析节点的动画表
         * @param anime 节点的动画表
         */
        static analy(anime) {
            anime.delayTime = this.now - anime.lastTime;
            this.analyAnimatable(anime);
            anime.lastTime = this.now;
        }
        /**
         * 处理目标动画表的当前帧
         * @param anime 目标动画表
         */
        static analyAnimatable(anime) {
            anime.animations.forEach((v, i) => {
                v.runedTime += anime.delayTime;
                this.analyRuntimeAnime(anime.target, v, anime.animations);
            });
        }
        /**
         * 处理当前帧的目标运行时动画
         * @param target 目标动画节点
         * @param runtimeAnime 运行时动画数据
         * @param animations 运行时动画数据列表
         */
        // tslint:disable-next-line:max-func-body-length
        static analyRuntimeAnime(target, runtimeAnime, animations) {
            // 延时检查
            const startTime = runtimeAnime.startTime + runtimeAnime.delayTime;
            if (startTime < runtimeAnime.runedTime) {
                // 当前为第几次动画
                const currCount = Math.ceil((runtimeAnime.runedTime - startTime) / runtimeAnime.duration);
                // 新的一轮动画
                if (currCount !== runtimeAnime.runtimeCount) {
                    runtimeAnime.runtimeCount = currCount;
                    if (currCount === 1) {
                        // 动画开始
                        try {
                            runtimeAnime.startListener && runtimeAnime.startListener(runtimeAnime.name);
                        }
                        catch (e) {
                            tools_1.Tools.error(e);
                        }
                    }
                    else {
                        // 动画播放完一次
                        try {
                            runtimeAnime.iteratListener && runtimeAnime.iteratListener(runtimeAnime.name, currCount - 1);
                        }
                        catch (e) {
                            tools_1.Tools.error(e);
                        }
                    }
                    if (runtimeAnime.iteration !== -1 && runtimeAnime.iteration < currCount) {
                        switch (runtimeAnime.fillMode) {
                            case ('forwards'):
                            case ('both'): {
                                // // TODO - 当前实现为 结束时 保持第一帧状态 还是 结束帧状态
                                // // 调用 结束监听前跑最后一帧，因为 结束回调里可能会做节点销毁操作
                                // const timeprogress = 1.0;
                                // // 要表现的帧的计算进度
                                // const renderProgress = this.computeRenderProgress(timeprogress, runtimeAnime.direction, runtimeAnime.runtimeCount);
                                // // 计算目标渲染帧状态
                                // this.computeRuntimeFrame(renderProgress, runtimeAnime);
                                // // 应用帧效果
                                // this.applyKeyFrame(target, runtimeAnime);
                                // break;
                            }
                            default: {
                                // TODO 回到动画运行前的状态
                                // TODO - 当前实现为 结束时 保持第一帧状态 还是 结束帧状态
                                // 调用 结束监听前跑最后一帧，因为 结束回调里可能会做节点销毁操作
                                const timeprogress = 1.0;
                                // 要表现的帧的计算进度
                                const renderProgress = this.computeRenderProgress(timeprogress, runtimeAnime.direction, runtimeAnime.runtimeCount);
                                // 计算目标渲染帧状态
                                this.computeRuntimeFrame(renderProgress, runtimeAnime);
                                // 应用帧效果
                                this.applyKeyFrame(target, runtimeAnime);
                            }
                        }
                        // 非循环动画结束
                        try {
                            runtimeAnime.endListener && runtimeAnime.endListener(runtimeAnime.name);
                        }
                        catch (e) {
                            tools_1.Tools.error(e);
                        }
                        animations.delete(runtimeAnime.name);
                        runtimeAnime = undefined;
                        return;
                    }
                }
                // 当前动画过程的进度
                const timeprogress = (runtimeAnime.runedTime - startTime - (runtimeAnime.runtimeCount - 1) * runtimeAnime.duration) / runtimeAnime.duration;
                // 要表现的帧的计算进度
                const renderProgress = this.computeRenderProgress(timeprogress, runtimeAnime.direction, runtimeAnime.runtimeCount);
                // 计算目标渲染帧状态
                this.computeRuntimeFrame(renderProgress, runtimeAnime);
                // 应用帧效果
                this.applyKeyFrame(target, runtimeAnime);
            }
            else {
                // 处理 等待时间里使用动画第一帧 的模式
                if (runtimeAnime.fillMode === 'backwards' || runtimeAnime.fillMode === 'both') {
                    // 当前动画过程的进度
                    const timeprogress = 0.0;
                    // 要表现的帧的计算进度
                    const renderProgress = this.computeRenderProgress(timeprogress, runtimeAnime.direction, 1);
                    // 计算目标渲染帧状态
                    this.computeRuntimeFrame(renderProgress, runtimeAnime);
                    // 应用帧效果
                    this.applyKeyFrame(target, runtimeAnime);
                }
            }
        }
        /**
         * 计算运行时动画运行进度 <在关键帧配置里的进度>
         * @param timeprogress 运行时长与动画时长百分比
         * @param direction 动画播放模式
         * @param count 当前动画游戏轮次
         */
        static computeRenderProgress(timeprogress, direction, count) {
            let result;
            switch (direction) {
                case (animation_tools_1.DirectionTypes.alternate): {
                    result = count % 2 === 1 ? 1 - timeprogress : timeprogress;
                    break;
                }
                case (animation_tools_1.DirectionTypes.alternate_reverse): {
                    result = count % 2 === 0 ? 1 - timeprogress : timeprogress;
                    break;
                }
                case (animation_tools_1.DirectionTypes.reverse): {
                    result = 1 - timeprogress;
                    break;
                }
                case (animation_tools_1.DirectionTypes.normal):
                default: {
                    result = timeprogress;
                }
            }
            return result;
        }
        /**
         * 计算运行时动画数据
         * @param renderProgress 动画运行进度
         * @param runtimeAnime 运行时动画
         */
        static computeRuntimeFrame(renderProgress, runtimeAnime) {
            renderProgress = renderProgress < 0 ? 0 : renderProgress;
            renderProgress = renderProgress > 1 ? 1 : renderProgress;
            const len = runtimeAnime.attrKeysList.length;
            for (let i = 0; i < len; i++) {
                const attrKey = runtimeAnime.attrKeysList[i];
                const attrFrames = runtimeAnime.animaCfg.attrs.find((v) => {
                    return v.key === attrKey;
                });
                if (attrFrames === undefined) {
                    continue;
                }
                if (runtimeAnime.stateRuntime.get(attrKey) === undefined) {
                    this.analyStartStateRuntime(attrKey, runtimeAnime, attrFrames);
                }
                if (renderProgress === 0) {
                    this.analyStartStateRuntime(attrKey, runtimeAnime, attrFrames);
                }
                else {
                    // const cfgProgress = runtimeAnime.animaCfg._from + renderProgress * runtimeAnime.animaCfg._to;
                    const cfgProgress = renderProgress;
                    const nextkeyIndex = attrFrames.data.findIndex((v, i) => {
                        return (v[0] >= cfgProgress);
                    });
                    if (nextkeyIndex === 0) {
                        this.analyStartStateRuntime(attrKey, runtimeAnime, attrFrames);
                    }
                    else if (nextkeyIndex === -1) {
                        this.analyEndStateRuntime(attrKey, runtimeAnime, attrFrames);
                    }
                    else {
                        const lastFrameCfg = attrFrames.data[nextkeyIndex - 1];
                        const nextFrameCfg = attrFrames.data[nextkeyIndex];
                        // runtimeAnime.stateRuntime.progress = cfgProgress;
                        runtimeAnime.stateRuntime.set(attrKey, this.computeMidFrameData(attrKey, runtimeAnime.timingFunction, cfgProgress, lastFrameCfg, nextFrameCfg));
                    }
                }
            }
        }
        /**
         * 解析动画开始时数据
         * @param attrKey 目标属性名称
         * @param runtimeAnime 运行时动画
         * @param attrFrames 目标属性关键帧列表
         */
        static analyStartStateRuntime(attrKey, runtimeAnime, attrFrames) {
            if (attrFrames.data[0][0] === 0) {
                runtimeAnime.stateRuntime.set(attrKey, animation_tools_1.AnimeTools.cloneAttrFrame(attrKey, attrFrames.data[0][1]));
            }
        }
        /**
         * 解析动画结束时数据
         * @param attrKey 目标属性名称
         * @param runtimeAnime 运行时动画
         * @param attrFrames 目标属性关键帧列表
         */
        static analyEndStateRuntime(attrKey, runtimeAnime, attrFrames) {
            if (attrFrames.data[attrFrames.data.length - 1][0] === 1) {
                runtimeAnime.stateRuntime.set(attrKey, animation_tools_1.AnimeTools.cloneAttrFrame(attrKey, attrFrames.data[attrFrames.data.length - 1][1]));
            }
        }
        /**
         * 计算动画进行时数据
         * @param attrKey 目标属性名称
         * @param math 运行函数
         * @param cfgProgress 在整个动画过程的百分比
         * @param lastFrame 上一个关键帧
         * @param nextFrame 下一个关键帧
         */
        static computeMidFrameData(attrKey, math, cfgProgress, lastFrame, nextFrame) {
            cfgProgress = math_tools_1.MathTools.mathCall(math, ((cfgProgress - lastFrame[0]) / (nextFrame[0] - lastFrame[0])));
            return animation_tools_1.AnimeTools.mixFrameData(attrKey, cfgProgress, lastFrame[1], nextFrame[1]);
        }
        /**
         * 对目标节点应用动画当前状态数据
         * @param target 目标节点
         * @param anime 运行时动画
         */
        static applyKeyFrame(target, runTimeAnima) {
            runTimeAnima.stateRuntime.forEach((v, k) => {
                switch (k) {
                    case (animation_tools_1.FrameClassKeys.transform): {
                        const nv = [];
                        for (const key in v) {
                            nv.push({ t: key, d: v[key] });
                        }
                        target.style[tools_1.StyleMap[k]] = nv;
                        this.changeStyleHook && this.changeStyleHook(target.virtual, k, nv);
                        break;
                    }
                    case (animation_tools_1.FrameClassKeys.cellId): {
                        target.attributes[k] = v;
                        this.changeStyleHook && this.changeStyleHook(target.virtual, k, v);
                        break;
                    }
                    case (animation_tools_1.FrameClassKeys.opacity):
                    default: {
                        target.style[tools_1.StyleMap[k]] = v;
                        this.changeStyleHook && this.changeStyleHook(target.virtual, k, v);
                    }
                }
            });
        }
    }
    exports.AnimationControl = AnimationControl;
    /**
     * 要处理动画列表 <节点>
     */
    AnimationControl.animeMap = new Map();
});

_$pi.define("pi_gui/gui/gui_res/res_mgr", ["require", "exports", "../../../pi_sys/modules/util/res_mgr", "../../../pi_sys/device/image", "../gui/enum", "../gui/gui", "../gui/image_tools", "../combine_image/combine"], function (require, exports, res_mgr_1, image_1, enum_1, gui_1, image_tools_1, combine_1) {
    "use strict";
    
    exports.GUI_IMAGE_TYPE = 'gui_image';
    /**
     * GUI 纹理资源
     */
    class GUIRes extends res_mgr_1.Res {
        /**
         * 初始化
         * @param vdocument 目标上下文
         */
        // tslint:disable-next-line:function-name
        static Init(vdocument) {
            GUIRes.vdocument = vdocument;
            window.__load_image = createGUIResNew;
        }
        static destroyCall(id) {
            // gui._release_texture_res(id);
        }
        /**
         * 创建 GUI 图片资源
         * @param image 图片数据
         * @param url 图片路径 (自定义的路径需要注意 带上后缀 .jpg / .png)
         */
        static createGUITexture(image, url) {
            const result = {};
            result.url = url;
            if (image !== undefined) {
                result.image = image;
                result.width = image.width;
                result.height = image.height;
                result.combineSrcWidth = image.width;
                result.combineSrcHeight = image.height;
            }
            if (GUIRes.vdocument) {
                let target;
                if (image !== undefined) {
                    target = image_tools_1.ImageTools.check(image);
                    result.image = target;
                    result.combineSrcWidth = target.width;
                    result.combineSrcHeight = target.height;
                    window.__jsObj = target;
                    window.__jsObj1 = url;
                    // result.textureID = gui._create_texture_res(GUIRes.vdocument, Opacity.Translucent, 0);
                    result.textureID = gui_1.gui._load_image_success(GUIRes.vdocument, enum_1.Opacity.Translucent, 0);
                }
            }
            if (image !== undefined && image.src) {
                image.src = '';
            }
            result.image = undefined;
            return result;
        }
        /**
         * @description 创建
         * @example
         */
        create(data, _) {
            this.link = data;
        }
        /**
         *
         * @description 销毁，需要子类重载
         * @example v
         */
        destroy() {
            if (this.link) {
                GUIRes.destroyCall(this.link.textureID);
            }
            this.link = undefined;
        }
    }
    exports.GUIRes = GUIRes;
    const resTab = new res_mgr_1.ResTab();
    const createGUIResNew = (document, url) => {
        image_1.loadImageRes(resTab, url).then((res) => {
            const target = image_tools_1.ImageTools.check(res.link);
            window.__jsObj = target;
            window.__jsObj1 = url;
            let opacity = 0;
            if (url.endsWith('png')) {
                opacity = 1;
            }
            gui_1.gui._load_image_success(document, opacity, 0);
            if (!combine_1.CombineImageMgr.getImageDecs(url)) {
                if (target !== res.link) {
                    if (res.link.src) {
                        res.link.src = '';
                    }
                    res.link = target;
                }
                combine_1.CombineImageMgr.addImageDecs(url, {
                    left: 0,
                    top: 0,
                    srcWidth: target.width,
                    srcHeight: target.height,
                    isPng: url.endsWith('png'),
                    url: url,
                    width: target.width,
                    height: target.height,
                });
            }
            else {
                if (res.link.src) {
                    res.link.src = '';
                }
                resTab.delete(res);
            }
        });
    };
    // 预加载图片
    exports.preLoadImage = (url, callback) => {
        image_1.loadImageRes(resTab, url).then((res) => {
            const target = image_tools_1.ImageTools.check(res.link);
            let imageDecs = combine_1.CombineImageMgr.getImageDecs(url);
            if (!imageDecs) {
                if (target !== res.link) {
                    if (res.link.src) {
                        res.link.src = '';
                    }
                    res.link = target;
                }
                imageDecs = {
                    left: 0,
                    top: 0,
                    srcWidth: target.width,
                    srcHeight: target.height,
                    isPng: url.endsWith('png'),
                    url: url,
                    width: target.width,
                    height: target.height,
                };
                combine_1.CombineImageMgr.addImageDecs(url, imageDecs);
                callback(imageDecs, target);
            }
            else {
                callback(imageDecs, target);
                if (res.link.src) {
                    res.link.src = '';
                }
                resTab.delete(res);
            }
        });
    };
});

/**
 * gui 节点样式结构
 * * 节点样式设置
 * * 节点动画设置
 * * 节点动画 添加 - 删除
 * * 节点动画监听 添加 - 删除
 */
_$pi.define("pi_gui/gui/gui/r_style", ["require", "exports", "./animation", "./animation_tools", "./enum", "./gui", "./r_datastruct", "../combine_image/combine", "./tools", "../gui_res/res_mgr"], function (require, exports, animation_1, animation_tools_1, enum_1, gui_1, r_datastruct_1, combine_1, tools_1, res_mgr_1) {
    "use strict";
    
    const DefaultStyle = {
        fontSize: 16,
        fontFamily: '',
        fontStyle: enum_1.FontStyle.Undefined,
        fontVariant: 0,
        fontWeight: enum_1.FontWeight.Normal,
        // Color: new RGBA(1, 1, 1, 1),
        color: [1, 1, 1, 1],
        letterSpacing: 0,
        position: enum_1.YGPositionType.YGPositionTypeRelative,
        textAlign: enum_1.TextAlign.Undefined,
        textIndent: 0,
        alignItems: enum_1.YGAlign.YGAlignAuto,
        justifyContent: enum_1.YGJustify.YGJustifyFlexStart,
        whiteSpace: 0,
        wordSpacing: 0,
        zIndex: 0
    };
    /**
     * R gui 节点样式
     */
    class RStyle {
        constructor(node) {
            // private _rotateZ: number;
            this._scale = [1, 1];
            this._transform = [{ t: 'r', d: 0 }, { t: 's', d: [0, 0] }, { t: 't', d: [[0, 0], [0, 0]] }];
            this._translate = [[0, 0], [0, 0]];
            // private _scroll_translate: ILengthVector2 = [[0,0],[0,0]];
            this._translateX = [0, 0];
            this._translateY = [0, 0];
            this._zIndex = 0;
            this._animListenerMap = new Map();
            this._animListenerHookMap = new Map();
            /**
             * 动画开始时的通用调用
             * @param aname 目标动画名称
             */
            this.animStart = (aname) => {
                const hookList = this._animListenerHookMap.get(aname);
                hookList && hookList[0] && hookList[0]();
                const funcList = this._animListenerMap.get(aname);
                funcList && funcList[0] && funcList[0]();
            };
            /**
             * 动画一次循环结束时的通用调用
             * @param aname 目标动画名称
             */
            this.animLoop = (aname, iter) => {
                const hookList = this._animListenerHookMap.get(aname);
                hookList && hookList[1] && hookList[1]();
                const funcList = this._animListenerMap.get(aname);
                funcList && funcList[1] && funcList[1](iter);
            };
            /**
             * 动画结束时的通用调用
             * @param aname 目标动画名称
             */
            this.animEnd = (aname) => {
                const hookList = this._animListenerHookMap.get(aname);
                hookList && hookList[2] && hookList[2]();
                const funcList = this._animListenerMap.get(aname);
                funcList && funcList[2] && funcList[2]();
            };
            this.createCall(node);
            this._animatable = new animation_tools_1.Animatable(this.ele);
        }
        set backgroundColor(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.backgroundColor(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this._backgroundColor = value;
                this.setStyleUndefined(enum_1.UndefinedType.BackgroundColor);
            }
            else {
                // gui._set_backgroud_rgba_color(this._doc, this._ele, value.r, value.g, value.b, value.a);
                this._backgroundColor = [...value];
                gui_1.gui._set_background_rgba_color(this._doc, this._ele, value[0], value[1], value[2], value[3]);
            }
        }
        get backgroundColor() {
            return this._backgroundColor;
        }
        set background(value) {
            this._background = value;
            if (typeof value === 'string') {
                value = tools_1.Tools.background_(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.BackgroundColor);
            }
            else {
                // Tools.log('gradient', value);
                if (value._t === tools_1.GradientTypes.linear) {
                    window.__jsObj = value.color_and_positions;
                    gui_1.gui._set_background_linear_gradient_color(this._doc, this._ele, value.direction);
                    window.__jsObj = undefined;
                }
                else {
                    window.__jsObj = value.color_and_positions;
                    gui_1.gui._set_background_radial_gradient_color(this._doc, this._ele, value.center_x, value.center_y, value.shape, value.size);
                    window.__jsObj = undefined;
                }
            }
        }
        get background() {
            return this._background;
        }
        set boxShadow(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.boxShadow(value);
            }
            this._boxShadow = value;
            if (tools_1.Tools.noValue(value)) {
                // this.setStyleUndefined(UndefinedType.Textshadow);
            }
            else {
                // gui._set_box_shadow(this._doc, this._ele, value.h, value.v, value.color.r, value.color.g, value.color.b, value.color.a, value.blur);
                // gui._set_box_shadow_color(this._doc, this._ele, value.color.r, value.color.g, value.color.b, value.color.a);
                // gui._set_box_shadow_h(this._doc, this._ele, value.h);
                // gui._set_box_shadow_v(this._doc, this._ele, value.v);
                // gui._set_box_shadow_color(this._doc, this._ele, value[IShadowC][0], value[IShadowC][1], value[IShadowC][2], value[IShadowC][3]);
                // gui._set_box_shadow_h(this._doc, this._ele, value[IShadowH]);
                // gui._set_box_shadow_v(this._doc, this._ele, value[IShadowV]);
                // gui._set_box_shadow_blur(this._doc, this._ele, value[IShadowB]);
                gui_1.gui._set_box_shadow(this._doc, this._ele, value[tools_1.IShadowH], value[tools_1.IShadowV], value[tools_1.IShadowB], value[tools_1.IShadowS], value[tools_1.IShadowC][0], value[tools_1.IShadowC][1], value[tools_1.IShadowC][2], value[tools_1.IShadowC][3]);
            }
        }
        get boxShadow() {
            return this._boxShadow;
        }
        /**
         * _edge： All
         */
        set borderWidth(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.borderWidth(value);
            }
            this._borderWidth = value;
            if (tools_1.Tools.noValue(value)) {
                this.setBorderValue(enum_1.YGEdge.YGEdgeAll, [enum_1.LengthUnitType.Pixel, 0]);
            }
            else {
                if (value[tools_1.BoxA] !== undefined && value[tools_1.BoxA] !== null) {
                    this.setBorderValue(enum_1.YGEdge.YGEdgeAll, value[tools_1.BoxA]);
                }
                else {
                    !tools_1.Tools.noValue(value[tools_1.BoxT]) && (this.setBorderValue(enum_1.YGEdge.YGEdgeTop, value[tools_1.BoxT]));
                    !tools_1.Tools.noValue(value[tools_1.BoxR]) && (this.setBorderValue(enum_1.YGEdge.YGEdgeRight, value[tools_1.BoxR]));
                    !tools_1.Tools.noValue(value[tools_1.BoxB]) && (this.setBorderValue(enum_1.YGEdge.YGEdgeBottom, value[tools_1.BoxB]));
                    !tools_1.Tools.noValue(value[tools_1.BoxL]) && (this.setBorderValue(enum_1.YGEdge.YGEdgeLeft, value[tools_1.BoxL]));
                }
            }
        }
        get borderWidth() {
            return this._borderWidth;
        }
        /**
         * _edge： All
         */
        set borderColor(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.borderColor(value);
            }
            this._borderColor = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.BorderColor);
            }
            else {
                this.setBorderColor(enum_1.YGEdge.YGEdgeAll, value);
            }
        }
        get borderColor() {
            return this._borderColor;
        }
        set borderRadius(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.borderRadius(value);
            }
            this._borderRadius = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.BorderRadius);
            }
            else {
                gui_1.gui._set_border_radius(this._doc, this._ele, value);
            }
        }
        get borderRadius() {
            return this._borderRadius;
        }
        set display(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.display(value);
            }
            // Tools.log('Display', value);
            this._display = value;
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_display(this._doc, this._ele, tools_1.Tools.display(undefined));
            }
            else {
                gui_1.gui._set_display(this._doc, this._ele, value);
            }
        }
        get display() {
            return this._display;
        }
        set visibility(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.visibility(value);
            }
            this._visibility = value;
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_visibility(this._doc, this._ele, true);
            }
            else {
                gui_1.gui._set_visibility(this._doc, this._ele, value);
            }
        }
        get visibility() {
            return this._visibility;
        }
        set flexDirection(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.flexDirection(value);
            }
            this._flexDirection = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.FlexDirection);
            }
            else {
                gui_1.gui._set_flex_direction(this._doc, this._ele, value);
            }
        }
        get flexDirection() {
            return this._flexDirection;
        }
        set flexWrap(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.flexWrap(value);
            }
            this._flexWrap = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.FlexWrap);
            }
            else {
                gui_1.gui._set_flex_wrap(this._doc, this._ele, value);
            }
        }
        get flexWrap() {
            return this._flexWrap;
        }
        set flexGrow(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.flexGrow(value);
            }
            this._flexGrow = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.FlexGrow);
            }
            else {
                gui_1.gui._set_flex_grow(this._doc, this._ele, value);
            }
        }
        get flexGrow() {
            return this._flexGrow;
        }
        set flexShrink(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.flexShrink(value);
            }
            this._flexShrink = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.FlexShrink);
            }
            else {
                gui_1.gui._set_flex_shrink(this._doc, this._ele, value);
            }
        }
        get flexShrink() {
            return this._flexShrink;
        }
        set flexBasis(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.flexBasis(value);
            }
            this._flexBasis = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.FlexBasis);
            }
            else {
                if (value.auto) {
                    gui_1.gui._set_flex_basis_auto(this._doc, this._ele);
                }
                else {
                    gui_1.gui._set_flex_basis(this._doc, this._ele, value.value);
                }
            }
        }
        get flexBasis() {
            return this._flexBasis;
        }
        set fontFamily(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.fontFamily(value);
            }
            this._fontFamily = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                value = DefaultStyle.fontFamily;
                if (RStyle.FontFamilyList.indexOf(value) >= 0) {
                    window.__jsObj = value;
                    gui_1.gui._set_font_family(this._doc, this._ele);
                }
                else {
                    tools_1.Tools.warn(`Font 未下载: ${value}`);
                }
            }
            else {
                if (RStyle.FontFamilyList.indexOf(value) < 0) {
                    value = DefaultStyle.fontFamily;
                }
                if (RStyle.FontFamilyList.indexOf(value) >= 0) {
                    window.__jsObj = value;
                    gui_1.gui._set_font_family(this._doc, this._ele);
                }
                else {
                    tools_1.Tools.warn(`Font 未下载: ${value}`);
                }
            }
            tools_1.Tools.log(value);
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontSize(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.fontSize(value);
            }
            this._fontSize = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_font_size(this._doc, this._ele, DefaultStyle.fontSize);
            }
            else {
                gui_1.gui._set_font_size(this._doc, this._ele, value);
            }
            tools_1.Tools.log(value);
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontStyle(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.fontStyle(value);
            }
            this._fontStyle = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_font_style(this._doc, this._ele, DefaultStyle.fontStyle);
            }
            else {
                gui_1.gui._set_font_style(this._doc, this._ele, value);
            }
        }
        get fontStyle() {
            return this._fontStyle;
        }
        // public set fontVariant(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.fontVariant(<string>value);
        //     }
        //     this._fontVariant = value;
        //     if (!(this.ele._type === RElementTypeList.SPAN)) {
        //         return;
        //     }
        //     if (Tools.noValue(value)) {
        //         Tools.notSupposeStyle('fontVariant');
        //     } else {
        //         Tools.notSupposeStyle('fontVariant');
        //     }
        // }
        // public get fontVariant() {
        //     return this._fontVariant;
        // }
        set fontWeight(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.fontWeight(value);
            }
            this._fontWeight = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_font_weight(this._doc, this._ele, DefaultStyle.fontWeight);
            }
            else {
                gui_1.gui._set_font_weight(this._doc, this._ele, value);
            }
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set height(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.height(value);
            }
            this._height = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Height);
            }
            else {
                switch (value[0]) {
                    case (enum_1.LengthUnitType.Pixel): {
                        gui_1.gui._set_height(this._doc, this._ele, value[1]);
                        break;
                    }
                    case (enum_1.LengthUnitType.Percent): {
                        gui_1.gui._set_height_percent(this._doc, this._ele, value[1]);
                        break;
                    }
                    default: {
                        gui_1.gui._set_height_auto(this._doc, this._ele);
                    }
                }
            }
            tools_1.Tools.log(value);
        }
        get height() {
            return this._height;
        }
        set width(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.width(value);
            }
            this._width = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Width);
            }
            else {
                switch (value[0]) {
                    case (enum_1.LengthUnitType.Pixel): {
                        gui_1.gui._set_width(this._doc, this._ele, value[1]);
                        break;
                    }
                    case (enum_1.LengthUnitType.Percent): {
                        gui_1.gui._set_width_percent(this._doc, this._ele, value[1]);
                        break;
                    }
                    default: {
                        gui_1.gui._set_width_auto(this._doc, this._ele);
                    }
                }
            }
            tools_1.Tools.log(value);
        }
        get width() {
            return this._width;
        }
        set maxHeight(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.maxHeight(value);
            }
            this._maxHeight = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MaxHeight);
            }
            else {
                switch (value[0]) {
                    case (enum_1.LengthUnitType.Pixel): {
                        gui_1.gui._set_max_height(this._doc, this._ele, value[1]);
                        break;
                    }
                    case (enum_1.LengthUnitType.Percent): {
                        gui_1.gui._set_max_height_percent(this._doc, this._ele, value[1]);
                        break;
                    }
                    default:
                }
            }
        }
        get maxHeight() {
            return this._maxHeight;
        }
        set minHeight(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.minHeight(value);
            }
            this._minHeight = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MinHeight);
            }
            else {
                switch (value[0]) {
                    case (enum_1.LengthUnitType.Pixel): {
                        gui_1.gui._set_min_height(this._doc, this._ele, value[1]);
                        break;
                    }
                    case (enum_1.LengthUnitType.Percent): {
                        gui_1.gui._set_min_height_percent(this._doc, this._ele, value[1]);
                        break;
                    }
                    default:
                }
            }
        }
        get minHeight() {
            return this._minHeight;
        }
        set maxWidth(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.maxWidth(value);
            }
            this._maxWidth = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MaxWidth);
            }
            else {
                switch (value[0]) {
                    case (enum_1.LengthUnitType.Pixel): {
                        gui_1.gui._set_max_width(this._doc, this._ele, value[1]);
                        break;
                    }
                    case (enum_1.LengthUnitType.Percent): {
                        gui_1.gui._set_max_width_percent(this._doc, this._ele, value[1]);
                        break;
                    }
                    default:
                }
            }
        }
        get maxWidth() {
            return this._maxWidth;
        }
        set minWidth(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.minWidth(value);
            }
            this._minWidth = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MinWidth);
            }
            else {
                switch (value[0]) {
                    case (enum_1.LengthUnitType.Pixel): {
                        gui_1.gui._set_min_width(this._doc, this._ele, value[1]);
                        break;
                    }
                    case (enum_1.LengthUnitType.Percent): {
                        gui_1.gui._set_min_width_percent(this._doc, this._ele, value[1]);
                        break;
                    }
                    default:
                }
            }
        }
        get minWidth() {
            return this._minWidth;
        }
        // ===================================== margin
        set margin(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.margin(value);
            }
            this._margin = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MarginTop);
                this.setStyleUndefined(enum_1.UndefinedType.MarginBottom);
                this.setStyleUndefined(enum_1.UndefinedType.MarginRight);
                this.setStyleUndefined(enum_1.UndefinedType.MarginLeft);
            }
            else {
                if (value[tools_1.BoxA] !== undefined && value[tools_1.BoxA] !== null) {
                    this.setMarginValue(enum_1.YGEdge.YGEdgeAll, value[tools_1.BoxA]);
                }
                else {
                    value[tools_1.BoxT] !== undefined && value[tools_1.BoxT] !== null && (this.setMarginValue(enum_1.YGEdge.YGEdgeTop, value[tools_1.BoxT]));
                    value[tools_1.BoxR] !== undefined && value[tools_1.BoxR] !== null && (this.setMarginValue(enum_1.YGEdge.YGEdgeRight, value[tools_1.BoxR]));
                    value[tools_1.BoxB] !== undefined && value[tools_1.BoxB] !== null && (this.setMarginValue(enum_1.YGEdge.YGEdgeBottom, value[tools_1.BoxB]));
                    value[tools_1.BoxL] !== undefined && value[tools_1.BoxL] !== null && (this.setMarginValue(enum_1.YGEdge.YGEdgeLeft, value[tools_1.BoxL]));
                }
            }
        }
        get margin() {
            return this._margin;
        }
        set marginBottom(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.marginBottom(value);
            }
            this._marginBottom = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MarginBottom);
            }
            else {
                this.setMarginValue(enum_1.YGEdge.YGEdgeBottom, value);
            }
        }
        get marginBottom() {
            return this._marginBottom;
        }
        set marginLeft(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.marginLeft(value);
            }
            this._marginLeft = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MarginLeft);
            }
            else {
                this.setMarginValue(enum_1.YGEdge.YGEdgeLeft, value);
            }
        }
        get marginLeft() {
            return this._marginLeft;
        }
        set marginRight(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.marginRight(value);
            }
            this._marginRight = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MarginRight);
            }
            else {
                this.setMarginValue(enum_1.YGEdge.YGEdgeRight, value);
            }
        }
        get marginRight() {
            return this._marginRight;
        }
        set marginTop(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.marginTop(value);
            }
            this._marginTop = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.MarginTop);
            }
            else {
                this.setMarginValue(enum_1.YGEdge.YGEdgeTop, value);
            }
        }
        get marginTop() {
            return this._marginTop;
        }
        set opacity(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.opacity(value);
            }
            this._opacity = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Opacity);
            }
            else {
                gui_1.gui._set_opacity(this._doc, this._ele, value);
            }
        }
        get opacity() {
            return this._opacity;
        }
        // public set outlineColor(value: IRGBA | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.outlineColor(<string>value);
        //     }
        //     this._outlineColor = value;
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.OutlineColor);
        //     } else {
        //         Tools.notSupposeStyle('outlineColor');
        //     }
        // }
        // public get outlineColor() {
        //     return this._outlineColor;
        // }
        // public set outlineOffset(value: ILengthData | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.outlineOffset(<string>value);
        //     }
        //     this._outlineOffset = value;
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.OutlineOffset);
        //     } else {
        //         Tools.notSupposeStyle('outlineOffset');
        //     }
        // }
        // public get outlineOffset() {
        //     return this._outlineOffset;
        // }
        // public set outlineStyle(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.outlineStyle(<string>value);
        //     }
        //     this._outlineStyle = value;
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.OutlineStyle);
        //     } else {
        //         Tools.notSupposeStyle('outlineStyle');
        //     }
        // }
        // public get outlineStyle() {
        //     return this._outlineStyle;
        // }
        // public set outlineWidth(value: ILengthData | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.outlineWidth(<string>value);
        //     }
        //     this._outlineWidth = value;
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.OutlineWidth);
        //     } else {
        //         Tools.notSupposeStyle('outlineWidth');
        //     }
        // }
        // public get outlineWidth() {
        //     return this._outlineWidth;
        // }
        // ====================== Overflow
        set overflow(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.overflow(value);
            }
            this._overflow = value;
            if (tools_1.Tools.noValue(value)) {
                this._overflow = false;
            }
            else {
                this._overflow = value;
            }
            gui_1.gui._set_overflow(this._doc, this._ele, this._overflow);
        }
        get overflow() {
            return this._overflow;
        }
        set overflowWrap(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.oveflowWrap(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Overflow);
            }
            else {
                // gui._set_overflow_wrap(this._doc, this._ele, value);
            }
        }
        // public set clip(value: number | string) {
        //     if (typeof value === 'string') {
        //         // value = Tools.clip(<string>value);
        //     }
        //     this._clip = <any>value;
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.Clip);
        //     } else {
        //         Tools.notSupposeStyle('clip');
        //     }
        // }
        // public get clip() {
        //     return this._clip;
        // }
        // ====================== PADDING
        /**
         * _edge
         */
        set padding(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.padding(value);
            }
            this._padding = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.PaddingBottom);
                this.setStyleUndefined(enum_1.UndefinedType.PaddingLeft);
                this.setStyleUndefined(enum_1.UndefinedType.PaddingRight);
                this.setStyleUndefined(enum_1.UndefinedType.PaddingTop);
            }
            else {
                if (value[tools_1.BoxA] !== undefined && value[tools_1.BoxA] !== null) {
                    this.setPaddingValue(enum_1.YGEdge.YGEdgeAll, value[tools_1.BoxA]);
                }
                else {
                    value[tools_1.BoxT] !== undefined && value[tools_1.BoxT] !== null && (this.setPaddingValue(enum_1.YGEdge.YGEdgeTop, value[tools_1.BoxT]));
                    value[tools_1.BoxR] !== undefined && value[tools_1.BoxR] !== null && (this.setPaddingValue(enum_1.YGEdge.YGEdgeRight, value[tools_1.BoxR]));
                    value[tools_1.BoxB] !== undefined && value[tools_1.BoxB] !== null && (this.setPaddingValue(enum_1.YGEdge.YGEdgeBottom, value[tools_1.BoxB]));
                    value[tools_1.BoxL] !== undefined && value[tools_1.BoxL] !== null && (this.setPaddingValue(enum_1.YGEdge.YGEdgeLeft, value[tools_1.BoxL]));
                }
            }
        }
        get padding() {
            return this._padding;
        }
        set paddingBottom(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.paddingBottom(value);
            }
            this._paddingBottom = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.PaddingBottom);
            }
            else {
                this.setPaddingValue(enum_1.YGEdge.YGEdgeBottom, value);
            }
        }
        get paddingBottom() {
            return this._paddingBottom;
        }
        set paddingLeft(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.paddingLeft(value);
            }
            this._paddingLeft = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.PaddingLeft);
            }
            else {
                this.setPaddingValue(enum_1.YGEdge.YGEdgeLeft, value);
            }
        }
        get paddingLeft() {
            return this._paddingLeft;
        }
        set paddingRight(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.paddingRight(value);
            }
            this._paddingRight = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.PaddingRight);
            }
            else {
                this.setPaddingValue(enum_1.YGEdge.YGEdgeRight, value);
            }
        }
        get paddingRight() {
            return this._paddingRight;
        }
        set paddingTop(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.paddingTop(value);
            }
            this._paddingTop = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.PaddingTop);
            }
            else {
                this.setPaddingValue(enum_1.YGEdge.YGEdgeTop, value);
            }
        }
        get paddingTop() {
            return this._paddingTop;
        }
        // ========================== position
        set position(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.position(value);
            }
            this._position = value;
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_position_type(this._doc, this._ele, DefaultStyle.position);
            }
            else {
                gui_1.gui._set_position_type(this._doc, this._ele, value);
            }
        }
        get position() {
            return this._position;
        }
        set bottom(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.bottom(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Bottom);
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeBottom, [enum_1.LengthUnitType.Pixel, NaN]);
            }
            else {
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeBottom, value);
            }
            this._bottom = value;
        }
        get bottom() {
            return this._bottom;
        }
        set left(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.left(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Left);
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeLeft, [enum_1.LengthUnitType.Pixel, NaN]);
            }
            else {
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeLeft, value);
            }
            this._left = value;
        }
        get left() {
            return this._left;
        }
        set right(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.right(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Right);
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeRight, [enum_1.LengthUnitType.Pixel, NaN]);
            }
            else {
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeRight, value);
            }
            this._right = value;
        }
        get right() {
            return this._right;
        }
        set top(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.top(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.Top);
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeTop, [enum_1.LengthUnitType.Pixel, NaN]);
            }
            else {
                this.setPositionTRBL(enum_1.YGEdge.YGEdgeTop, value);
            }
            this._top = value;
        }
        get top() {
            return this._top;
        }
        set zIndex(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.zIndex(value);
            }
            this._zIndex = value;
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_zindex(this._doc, this._ele, DefaultStyle.zIndex);
            }
            else {
                gui_1.gui._set_zindex(this._doc, this._ele, value);
            }
        }
        get zIndex() {
            return this._zIndex;
        }
        // public set direction(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.direction(<string>value);
        //     }
        //     this._direction = <any>value;
        //     if (Tools.noValue(value)) {
        //         Tools.notSupposeStyle('direction');
        //     } else {
        //         Tools.notSupposeStyle('direction');
        //     }
        // }
        // public get direction() {
        //     return this._direction;
        // }
        // ===================================== text
        set color(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.color(value);
            }
            this._color = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                value = DefaultStyle.color;
            }
            gui_1.gui._set_text_rgba_color(this._doc, this._ele, value[0], value[1], value[2], value[3]);
        }
        get color() {
            return this._color;
        }
        set letterSpacing(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.letterSpacing(value);
            }
            this._letterSpacing = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_letter_spacing(this._doc, this._ele, DefaultStyle.letterSpacing);
            }
            else {
                gui_1.gui._set_letter_spacing(this._doc, this._ele, value[1]);
            }
        }
        get letterSpacing() {
            return this._letterSpacing;
        }
        set lineHeight(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.lineHeight(value);
            }
            this._lineHeight = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                // this.setStyleUndefined(UndefinedType.lineHeight);
            }
            else {
                gui_1.gui._set_line_height(this._doc, this._ele, value[1]);
            }
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set textContent(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.textContent(value);
            }
            this._textContent = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                // gui._set_text_content(this._doc, this._ele, value);
            }
            else {
                // gui._set_text_content(this._doc, this._ele, value);
            }
        }
        get textContent() {
            return this._textContent;
        }
        set textAlign(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.textAlign(value);
            }
            this._textAlign = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_text_align(this._doc, this._ele, DefaultStyle.textAlign);
                // Tools.notSupposeStyle('text-align');
            }
            else {
                gui_1.gui._set_text_align(this._doc, this._ele, value);
                // Tools.notSupposeStyle('text-align');
            }
        }
        get textAlign() {
            return this._textAlign;
        }
        // public set textDecoration(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.textDecoration(<string>value);
        //     }
        //     this._textDecoration = value;
        //     if (!(this.ele._type === RElementTypeList.SPAN)) {
        //         return;
        //     }
        //     if (Tools.noValue(value)) {
        //         Tools.notSupposeStyle('textDecoration');
        //     } else {
        //         Tools.notSupposeStyle('textDecoration');
        //     }
        // }
        // public get textDecoration() {
        //     return this._textDecoration;
        // }
        set textIndent(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.textIndent(value);
            }
            this._textIndent = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_text_indent(this._doc, this._ele, 0);
            }
            else {
                gui_1.gui._set_text_indent(this._doc, this._ele, value);
            }
        }
        get textIndent() {
            return this._textIndent;
        }
        set textShadow(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.textShadow(value);
            }
            this._textShadow = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                // this.setStyleUndefined(UndefinedType.Textshadow);
            }
            else {
                // gui._set_text_shadow(this._doc, this._ele,
                //     value[IShadowH], value[IShadowV],
                //     value[IShadowC][0], value[IShadowC][1], value[IShadowC][2], value[IShadowC][3],
                //     value[IShadowB]
                // );
                gui_1.gui._set_text_shadow(this._doc, this._ele, value[tools_1.IShadowH], value[tools_1.IShadowV], value[tools_1.IShadowB], value[tools_1.IShadowC][0], value[tools_1.IShadowC][1], value[tools_1.IShadowC][2], value[tools_1.IShadowC][3]);
            }
        }
        get textShadow() {
            return this._textShadow;
        }
        get textStroke() {
            return this._textStroke;
        }
        set textStroke(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.textStroke(value);
            }
            this._textStroke = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.BackgroundColor);
            }
            else {
                gui_1.gui._set_text_stroke(this._doc, this._ele, value[0], value[1], value[2], value[3], value[4]);
            }
        }
        get textGradient() {
            return this._textGradient;
        }
        set textGradient(value) {
            this._textGradient = value;
            if (typeof value === 'string') {
                value = tools_1.Tools.textGradient_(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.BackgroundColor);
            }
            else {
                // Tools.log('gradient', value);
                if (value._t === tools_1.GradientTypes.linear) {
                    window.__jsObj = value.color_and_positions;
                    gui_1.gui._set_text_linear_gradient_color(this._doc, this._ele, value.direction);
                    window.__jsObj = undefined;
                }
                else {
                    // (<any>window).__jsObj = value.color_and_positions;
                    // gui._set_background_radial_gradient_color(this._doc, this._ele, value.center_x, value.center_y, value.shape, value.size);
                    // (<any>window).__jsObj = undefined;
                }
            }
        }
        // public set textTransform(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.textTransform(<string>value);
        //     }
        //     this._textTransform = value;
        //     if (!(this.ele._type === RElementTypeList.SPAN)) {
        //         return;
        //     }
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.TextTransform);
        //     } else {
        //         Tools.notSupposeStyle('textTransform');
        //     }
        // }
        // public get textTransform() {
        //     return this._textTransform;
        // }
        // public set textOverflow(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.textOverflow(<string>value);
        //     }
        //     if (!(this.ele._type === RElementTypeList.SPAN)) {
        //         return;
        //     }
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.TextOverflow);
        //     } else {
        //         Tools.notSupposeStyle('textOverflow');
        //     }
        // }
        set whiteSpace(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.whiteSpace(value);
            }
            this._whiteSpace = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_white_space(this._doc, this._ele, DefaultStyle.whiteSpace);
            }
            else {
                gui_1.gui._set_white_space(this._doc, this._ele, value);
            }
        }
        get whiteSpace() {
            return this._whiteSpace;
        }
        set wordSpacing(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.wordSpacing(value);
            }
            this._wordSpacing = value;
            if (!(this.ele._type === r_datastruct_1.RElementTypeList.SPAN)) {
                return;
            }
            if (tools_1.Tools.noValue(value)) {
                // this.setStyleUndefined(UndefinedType.WordSpacing);
            }
            else {
                tools_1.Tools.notSupposeStyle('wordSpacing');
            }
        }
        get wordSpacing() {
            return this._wordSpacing;
        }
        // ============================== item
        // public set unicodeBidi(value: number | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.unicodeBidi(<string>value);
        //     }
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.UnicodeBidi);
        //     } else {
        //         Tools.notSupposeStyle('unicodeBidi');
        //     }
        // }
        // public set verticalAlign(value: VerticalAlign | string) {
        //     if (typeof value === 'string') {
        //         value = Tools.verticalAlign(<string>value);
        //     }
        //     this._verticalAlign = value;
        //     if (Tools.noValue(value)) {
        //         // this.setStyleUndefined(UndefinedType.VerticalAlign);
        //     } else {
        //         Tools.notSupposeStyle('verticalAlign');
        //     }
        // }
        // public get verticalAlign() {
        //     return this._verticalAlign;
        // }
        // public set alignSelf(data: string) {
        //     const value = Tools.alignSelf(data);
        set alignSelf(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.alignSelf(value);
            }
            this._alignSelf = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.AlignSelf);
            }
            else {
                gui_1.gui._set_align_self(this._doc, this._ele, value);
            }
        }
        get alignSelf() {
            return this._alignSelf;
        }
        // public set alignContent(data: string) {
        // const value = Tools.alignContent(data);
        set alignContent(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.alignContent(value);
            }
            this._alignContent = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.AlignContent);
            }
            else {
                gui_1.gui._set_align_content(this._doc, this._ele, value);
            }
        }
        get alignContent() {
            return this._alignContent;
        }
        // public set alignItems(data: string) {
        //     const value = Tools.alignItems(data);
        set alignItems(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.alignItems(value);
            }
            this._alignItems = value;
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_align_items(this._doc, this._ele, DefaultStyle.alignItems);
            }
            else {
                gui_1.gui._set_align_items(this._doc, this._ele, value);
            }
        }
        get alignItems() {
            return this._alignItems;
        }
        // public set justifyContent(data: string) {
        //     const value = Tools.justifyContent(data);
        set justifyContent(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.justifyContent(value);
            }
            this._justifyContent = value;
            if (tools_1.Tools.noValue(value)) {
                gui_1.gui._set_justify_content(this._doc, this._ele, DefaultStyle.justifyContent);
            }
            else {
                gui_1.gui._set_justify_content(this._doc, this._ele, value);
            }
        }
        get justifyContent() {
            return this._justifyContent;
        }
        set pointerEvents(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.pointerEvents(value);
            }
            this._pointerEvents = value;
            this.ele.enabled(value);
        }
        get pointerEvents() {
            return this._pointerEvents;
        }
        set objectFit(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.objectFit(value);
            }
            this._objectFit = value;
            gui_1.gui._set_object_fit(this._doc, this._ele, value);
        }
        get objectFit() {
            return this._objectFit;
        }
        // ======================================= Transform
        // public set transform(data: string) {
        //     const value = Tools.transform(data);
        set transform(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.transform(value);
            }
            gui_1.gui._clear_transform(this._doc, this._ele);
            this._translateX[1] = 0;
            this._translateY[1] = 0;
            this._scale[0] = 0;
            this._scale[1] = 0;
            this._rotate = 0;
            this._transform = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.BackgroundColor);
            }
            else {
                value.forEach((v) => {
                    switch (v.t) {
                        case tools_1.ITransformDataType.translate: {
                            this.translate = v.d;
                            break;
                        }
                        case tools_1.ITransformDataType.rotateZ: {
                            this.rotate = v.d;
                            break;
                        }
                        case tools_1.ITransformDataType.scale: {
                            this.scale = v.d;
                            break;
                        }
                        default:
                    }
                });
            }
        }
        get transform() {
            return this._transform;
        }
        set transformOrigin(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.transformOrigin(value);
            }
            this._transformOrigin = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.TransformTranslate);
            }
            else {
                gui_1.gui._transform_origin(this._doc, this._ele, value[0][0], value[0][1], value[1][0], value[1][1]);
            }
        }
        get transformOrigin() {
            return this._transformOrigin;
        }
        set translate(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.translate(value);
            }
            this._translate = value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.TransformTranslate);
            }
            else {
                this.translateX = value[0];
                this.translateY = value[1];
            }
        }
        get translate() {
            return this._translate;
        }
        set scale(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.scale(value);
            }
            // this._scale = <any>value;
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.TransformScale);
                this._scale[0] = 1;
                this._scale[1] = 1;
            }
            else {
                gui_1.gui._transform_scale(this._doc, this._ele, value[0] - this._scale[0], value[1] - this._scale[1]);
                this._scale[0] = value[0];
                this._scale[1] = value[1];
            }
        }
        get scale() {
            return this._scale;
        }
        set rotate(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.rotate(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.TransformRotate);
                this._rotate = 0;
            }
            else {
                gui_1.gui._transform_rotate(this._doc, this._ele, value - this._rotate);
                this._rotate = value;
            }
        }
        get rotate() {
            return this._rotate;
        }
        set translateX(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.translateX(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.TransformTranslateX);
                this._translateX[0] = 0;
                this._translateX[1] = 0;
            }
            else {
                if (value[0] === enum_1.LengthUnitType.Percent) {
                    gui_1.gui._transform_translate_x_percent(this._doc, this._ele, value[1] - this._translateX[1]);
                }
                else {
                    gui_1.gui._transform_translate_x(this._doc, this._ele, value[1] - this._translateX[1]);
                }
                this._translateX[0] = value[0];
                this._translateX[1] = value[1];
            }
        }
        get translateX() {
            return this._translateX;
        }
        set translateY(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.translateY(value);
            }
            if (tools_1.Tools.noValue(value)) {
                this.setStyleUndefined(enum_1.UndefinedType.TransformTranslateY);
                this._translateY[0] = 0;
                this._translateY[1] = 0;
            }
            else {
                if (value[0] === enum_1.LengthUnitType.Percent) {
                    gui_1.gui._transform_translate_y_percent(this._doc, this._ele, value[1] - this._translateY[1]);
                }
                else {
                    gui_1.gui._transform_translate_y(this._doc, this._ele, value[1] - this._translateY[1]);
                }
                this._translateY[0] = value[0];
                this._translateY[1] = value[1];
            }
        }
        get translateY() {
            return this._translateY;
        }
        set animation(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.animation(value);
            }
            const currAnimeNames = [];
            if (value && value.length > 0) {
                value.forEach((v) => {
                    // 记录当前动画配置 RuntimeAnimation
                    currAnimeNames.push(v.name);
                    if (!this._animatable.animations.get(v.name)) {
                        // 创建新 RuntimeAnimation
                        const runtimeAnimation = new animation_tools_1.RuntimeAnimation(v.name, RStyle.AnimationCfgRequest(this.ele, v.name), v.duration);
                        // TODO
                        v.delayTime !== undefined && v.delayTime !== null && (runtimeAnimation.delayTime = v.delayTime);
                        v.direction !== undefined && v.direction !== null && (runtimeAnimation.direction = v.direction);
                        v.fillMode !== undefined && v.fillMode !== null && (runtimeAnimation.fillMode = v.fillMode);
                        v.timingFunction !== undefined && v.timingFunction !== null && (runtimeAnimation.timingFunction = v.timingFunction);
                        v.iteration !== undefined && v.iteration !== null && (runtimeAnimation.iteration = v.iteration);
                        this._animatable.add(runtimeAnimation);
                    }
                });
            }
            // 移除不再设置的动画
            this._animatable.animations.forEach((v) => {
                if (currAnimeNames.indexOf(v.name) < 0) {
                    this._animatable.removeByName(v.name);
                    this.delAnimListener(v.name);
                }
            });
            if (this._animatable.animations.size > 0) {
                animation_1.AnimationControl.add(this._animatable);
            }
            else {
                animation_1.AnimationControl.remove(this._animatable);
            }
        }
        set borderImage(value) {
            this._borderImage = value;
        }
        get borderImage() {
            return this._borderImage;
        }
        set borderImageSource(value) {
            // value = Tools.borderImageSource(<string>value);
            if (tools_1.Tools.noValue(value)) {
                //
            }
            else {
                // this._borderImageSource = value;
                const imageDecs = combine_1.CombineImageMgr.getImageDecs(value);
                if (imageDecs) {
                    imageDecs.srcUrl = value;
                    const width = imageDecs.srcUrl ? imageDecs.srcWidth : imageDecs.width;
                    const height = imageDecs.srcUrl ? imageDecs.srcHeight : imageDecs.height;
                    if (imageDecs) {
                        this._borderImageDecs = imageDecs;
                        this.setBoxWithImage(imageDecs);
                        this.borderImageClip = [imageDecs.top, imageDecs.left + width, imageDecs.top + height, imageDecs.left, 0];
                        this.activeBorderImageSlice();
                        window.__jsObj = imageDecs.url;
                        gui_1.gui._set_border_image(this.ele.document.uniqueID, this.ele.uniqueID);
                    }
                }
                else {
                    // TODO 加载图片， 图片加载成功后， setBoxWithImage， activeBorderImageClip， activeBorderImageSlice， 创建纹理， 设置url
                    window.__jsObj = value;
                    res_mgr_1.preLoadImage(value, (imageDecs, _image) => {
                        const width = imageDecs.srcUrl ? imageDecs.srcWidth : imageDecs.width;
                        const height = imageDecs.srcUrl ? imageDecs.srcHeight : imageDecs.height;
                        if (imageDecs) {
                            this._borderImageDecs = imageDecs;
                            this.setBoxWithImage(imageDecs);
                            this.borderImageClip = [imageDecs.top, imageDecs.left + width, imageDecs.top + height, imageDecs.left, 0];
                            this.activeBorderImageSlice();
                            window.__jsObj = imageDecs.url;
                            gui_1.gui._set_border_image(this.ele.document.uniqueID, this.ele.uniqueID);
                        }
                    });
                    // (<any>window).__jsObj = url;
                    // gui._set_border_image(this.ele.document.uniqueID, this.ele.uniqueID);
                }
                // if (imageDecs) {
                // } else {
                // 	(<RContainerElement>this.ele).loadBorderImage();
                // }
            }
        }
        get borderImageSource() {
            return this._borderImageSource;
        }
        set borderImageSlice(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.borderImageSlice(value);
            }
            if (tools_1.Tools.noValue(value)) {
                //
            }
            else {
                this._borderImageSlice = value;
                this.activeBorderImageSlice();
            }
        }
        get borderImageSlice() {
            return this._borderImageSlice;
        }
        set borderImageClip(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.borderImageClip(value);
            }
            if (tools_1.Tools.noValue(value)) {
                //
            }
            else {
                this._borderImageClip = value;
                this.activeBorderImageClip();
            }
        }
        get borderImageClip() {
            return this._borderImageClip;
        }
        set borderImageRepeat(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.borderImageRepeat(value);
            }
            if (tools_1.Tools.noValue(value)) {
                //
            }
            else {
                this._borderImageRepeat = value;
                gui_1.gui._set_border_image_repeat(this._doc, this._ele, this._borderImageRepeat[0], this._borderImageRepeat[1]);
            }
        }
        get borderImageRepeat() {
            return this._borderImageRepeat;
        }
        set imageClip(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.imageClip(value);
            }
            if (tools_1.Tools.noValue(value)) {
                //
            }
            else {
                this.ele.attributes.imageClip = value;
            }
        }
        get imageClip() {
            return this.ele.attributes.imageClip;
        }
        static create(node) {
            let r;
            if (this.recycleList.length > 0) {
                r = this.recycleList.pop();
                r.createCall(node);
                r._animatable.reset(node);
            }
            else {
                r = new RStyle(node);
            }
            return r;
        }
        static addDefaultStyle(key, value) {
            if (tools_1.Tools[key] !== undefined) {
                DefaultStyle[key] = tools_1.Tools[key](value);
            }
        }
        static getDefaultStyle(key) {
            return DefaultStyle[key];
        }
        /**
         * 设置 animation 的帧数据获取方法
         */
        static setAnimationCfgRequest(f) {
            this.AnimationCfgRequest = f;
        }
        static recycle(r) {
            this.recycleList.push(r);
        }
        ///////////////////////////////////////////////
        /**
         * 添加目标动画的监听
         * @param animName 动画名称
         * @param listenType 监听类型
         * @param f 监听方法
         */
        addAnimListener(animName, listenType, f) {
            let funcList = this._animListenerMap.get(animName);
            if (!funcList) {
                funcList = [];
                this._animListenerMap.set(animName, funcList);
            }
            switch (listenType) {
                case 'start': {
                    funcList[0] = f;
                    break;
                }
                case 'loop': {
                    funcList[1] = f;
                    break;
                }
                default: {
                    funcList[2] = f;
                }
            }
        }
        delAnimListener(animName) {
            this._animListenerMap.delete(animName);
        }
        /**
         * 添加目标动画的监听
         * @param animName 动画名称
         * @param listenType 监听类型
         * @param f 监听方法
         * * 由底层使用的接口
         */
        addAnimListenerHook(animName, listenType, f) {
            let funcList = this._animListenerHookMap.get(animName);
            if (!funcList) {
                funcList = [];
                this._animListenerHookMap.set(animName, funcList);
            }
            switch (listenType) {
                case 'start': {
                    funcList[0] = f;
                    break;
                }
                case 'loop': {
                    funcList[1] = f;
                    break;
                }
                default: {
                    funcList[2] = f;
                }
            }
        }
        /**
         * 添加运行时动画
         * @param runtimeAnimation 运行时动画
         */
        addAnimation(runtimeAnimation) {
            this._animatable.add(runtimeAnimation);
            if (this._animatable.animations.size > 0) {
                animation_1.AnimationControl.add(this._animatable);
            }
            else {
                animation_1.AnimationControl.remove(this._animatable);
            }
        }
        /**
         * 移除运行时动画
         * @param animeName 目标动画名称
         */
        removeAnimation(animeName) {
            // 移除不再设置的动画
            this._animatable.removeByName(animeName);
            if (this._animatable.animations.size > 0) {
                animation_1.AnimationControl.add(this._animatable);
            }
            else {
                animation_1.AnimationControl.remove(this._animatable);
            }
        }
        /**
         * 销毁
         */
        remove() {
            this.removeCall();
            RStyle.recycle(this);
        }
        createCall(node) {
            this.ele = node;
            this._ele = node.uniqueID;
            this._doc = node.document.uniqueID;
        }
        ///////////////////////////////////////////////
        /**
         *
         * @param _edge 要设置的 border 选择
         * @param data border 数据
         */
        setBorderValue(_edge, data) {
            switch (data[0]) {
                case (enum_1.LengthUnitType.Pixel): {
                    gui_1.gui._set_border(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                default:
            }
        }
        /**
         *
         * @param _edge 要设置的 border 选择
         * @param data border 数据
         */
        setBorderColor(_edge, data) {
            gui_1.gui._set_border_color(this._doc, this._ele, data[0], data[1], data[2], data[3]);
        }
        /**
         *
         * @param _edge 要设置的 padding 选择
         * @param data padding 数据
         */
        setPaddingValue(_edge, data) {
            switch (data[0]) {
                case (enum_1.LengthUnitType.Pixel): {
                    gui_1.gui._set_padding(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                case (enum_1.LengthUnitType.Percent): {
                    gui_1.gui._set_padding_percent(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                default:
            }
        }
        /**
         *
         * @param _edge 要设置的 Margin 选择
         * @param data Margin 数据
         */
        setMarginValue(_edge, data) {
            switch (data[0]) {
                case (enum_1.LengthUnitType.Pixel): {
                    gui_1.gui._set_margin(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                case (enum_1.LengthUnitType.Percent): {
                    gui_1.gui._set_margin_percent(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                default: {
                    gui_1.gui._set_margin_auto(this._doc, this._ele, _edge);
                }
            }
        }
        /**
         *
         * @param _edge 要设置的 Position 选择
         * @param data Position 数据
         */
        setPositionTRBL(_edge, data) {
            switch (data[0]) {
                case (enum_1.LengthUnitType.Pixel): {
                    gui_1.gui._set_position(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                case (enum_1.LengthUnitType.Percent): {
                    gui_1.gui._set_position_percent(this._doc, this._ele, _edge, data[1]);
                    break;
                }
                default:
            }
        }
        removeCall() {
            animation_1.AnimationControl.remove(this._animatable);
            this._animatable.clear();
            this.ele = undefined;
            this._ele = undefined;
            this._doc = undefined;
            this._backgroundColor = undefined;
            this._alignContent = undefined;
            this._alignItems = undefined;
            this._alignSelf = undefined;
            this._background = undefined;
            this._borderColor = undefined;
            this._borderImage = undefined;
            this._borderImageSource = undefined;
            this._borderImageClip = undefined;
            this._borderImageRepeat = undefined;
            this._borderImageSlice = undefined;
            this._borderRadius = undefined;
            this._borderWidth = undefined;
            this._bottom = undefined;
            this._boxShadow = undefined;
            this._color = undefined;
            this._display = undefined;
            this._flexBasis = undefined;
            this._flexDirection = undefined;
            this._flexGrow = undefined;
            this._flexShrink = undefined;
            this._flexWrap = undefined;
            this._fontFamily = undefined;
            this._fontSize = undefined;
            this._fontStyle = undefined;
            this._fontWeight = undefined;
            this._height = undefined;
            this._justifyContent = undefined;
            this._left = undefined;
            this._letterSpacing = undefined;
            this._lineHeight = undefined;
            this._margin = undefined;
            this._marginLeft = undefined;
            this._marginTop = undefined;
            this._marginRight = undefined;
            this._marginBottom = undefined;
            this._maxHeight = undefined;
            this._maxWidth = undefined;
            this._minHeight = undefined;
            this._minWidth = undefined;
            this._objectFit = undefined;
            this._opacity = undefined;
            this._overflow = undefined;
            this._padding = undefined;
            this._paddingLeft = undefined;
            this._paddingTop = undefined;
            this._paddingRight = undefined;
            this._paddingBottom = undefined;
            this._pointerEvents = undefined;
            this._position = undefined;
            this._right = undefined;
            this._rotate = undefined;
            this._scale = [1, 1];
            this._textContent = undefined;
            this._top = undefined;
            this._transform = [{ t: 'r', d: 0 }, { t: 's', d: [0, 0] }, { t: 't', d: [[0, 0], [0, 0]] }];
            this._transformOrigin = undefined;
            this._translate = [[0, 0], [0, 0]];
            this._translateX = [0, 0];
            this._translateY = [0, 0];
            this._visibility = undefined;
            this._whiteSpace = undefined;
            this._width = undefined;
            this._wordSpacing = undefined;
            this._zIndex = 0;
            this._textStroke = undefined;
            this._textGradient = undefined;
            this._animListenerMap.clear();
            this._animListenerHookMap.clear();
        }
        setStyleUndefined(key) {
            // gui._reset_style(this._doc, this._ele, key);
        }
        // private radial_gradient(data: string) {
        //     //
        // }
        // private linear_gradient(data: string) {
        //     //
        // }
        /**
         * BorderImageSlice 的激活调用
         * css clip: (top, right, bottom, left) 相对边缘的量
         * gui clip: (top, right, bottom, left) 相对边缘的量
         */
        activeBorderImageSlice() {
            let value = this.ele.document.readStyle(this.ele.style, 'borderImageSlice');
            if (typeof value === 'string') {
                value = tools_1.Tools.borderImageSlice(value);
            }
            if (!tools_1.Tools.noValue(value)) {
                const _value = [];
                // value[5] === 0 表示borderImageSlice描述了像素值
                if (value[5] === 0) {
                    if (this._borderImageDecs) {
                        let width = this._borderImageDecs.srcUrl ? this._borderImageDecs.srcWidth : this._borderImageDecs.width;
                        let height = this._borderImageDecs.srcUrl ? this._borderImageDecs.srcHeight : this._borderImageDecs.height;
                        _value[0] = value[0] / height;
                        _value[1] = value[1] / width;
                        _value[2] = value[2] / height;
                        _value[3] = value[3] / width;
                        gui_1.gui._set_border_image_slice(this.ele.document.uniqueID, this.ele.uniqueID, _value[0], _value[1], _value[2], _value[3], value[4] === 1);
                    }
                }
                else {
                    _value[0] = value[0];
                    _value[1] = value[1];
                    _value[2] = value[2];
                    _value[3] = value[3];
                    gui_1.gui._set_border_image_slice(this.ele.document.uniqueID, this.ele.uniqueID, _value[0], _value[1], _value[2], _value[3], value[4] === 1);
                }
            }
        }
        /**
         * BorderImageClip 的激活调用
         * css clip: (top, right, bottom, left) 为坐标
         * gui clip: (x0, y0, x1, y1) 左上-右下坐标
         */
        activeBorderImageClip() {
            let value = this.ele.document.readStyle(this.ele.style, 'borderImageClip');
            if (typeof value === 'string') {
                value = tools_1.Tools.borderImageClip(value);
            }
            if (!tools_1.Tools.noValue(value)) {
                const _value = [];
                if (value[4] === 0) {
                    if (this._borderImageDecs) {
                        _value[0] = value[0] / this._borderImageDecs.height;
                        _value[1] = value[1] / this._borderImageDecs.width;
                        _value[2] = value[2] / this._borderImageDecs.height;
                        _value[3] = value[3] / this._borderImageDecs.width;
                        gui_1.gui._set_border_image_clip(this.ele.document.uniqueID, this.ele.uniqueID, _value[3], _value[0], _value[1], _value[2]);
                    }
                }
                else {
                    _value[0] = value[0];
                    _value[1] = value[1];
                    _value[2] = value[2];
                    _value[3] = value[3];
                    gui_1.gui._set_border_image_clip(this.ele.document.uniqueID, this.ele.uniqueID, _value[3], _value[0], _value[1], _value[2]);
                }
            }
        }
        // 一些节点在样式中没有设置宽高， 自动为其应用其设置的图片的宽高（Image或BorderImage）
        setBoxWithImage(imageDecs) {
            let ele = this.ele;
            if (!ele.document.readStyle(ele.style, 'width')) {
                // this.document.applyStyle(this.style, 'width', `${this._imageWidth}px`);
                ele.defWidth(imageDecs.srcUrl ? imageDecs.srcWidth : imageDecs.width);
            }
            if (!ele.document.readStyle(ele.style, 'height')) {
                // this.document.applyStyle(this.style, 'height',`${this._imageHeight}px`);
                ele.defHeight(imageDecs.srcUrl ? imageDecs.srcHeight : imageDecs.height);
            }
        }
    }
    exports.RStyle = RStyle;
    /////////////////////////////////////////////////////////////
    // private set matrix(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.matrix);
    //     } else {
    //         Tools.notSupposeStyle('matrix');
    //     }
    // }
    // private set matrix3d(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.matrix3d);
    //     } else {
    //         Tools.notSupposeStyle('matrix3d');
    //     }
    // }
    // private set translate3d(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.translate3d);
    //     } else {
    //         Tools.notSupposeStyle('translate3d');
    //     }
    // }
    // private set translateZ(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformTranslateZ);
    //     } else {
    //         Tools.notSupposeStyle('translateZ');
    //     }
    // }
    // private set scale3d(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformScale3D);
    //     } else {
    //         Tools.notSupposeStyle('scale3d');
    //     }
    // }
    // public set scaleX(value: string | number) {
    //     if (typeof value === 'string') {
    //         value = (<any>(<string>value).trim()) - 0;
    //     }
    //     this._scaleX = value;
    //     if (Tools.noValue(value)) {
    //         this._scale[0] = 1;
    //         this.setStyleUndefined(UndefinedType.TransformScaleX);
    //     } else {
    //         this._scale[0] = value;
    //         gui._transform_scale(this._doc, this._ele, this._scale[0], this._scale[1]);
    //     }
    // }
    // public get scaleX() {
    //     return this._scaleX;
    // }
    // public set scaleY(value: string | number) {
    //     if (typeof value === 'string') {
    //         value = (<any>(<string>value).trim()) - 0;
    //     }
    //     this._scaleY = value;
    //     if (Tools.noValue(value)) {
    //         this._scale[1] = 1;
    //         this.setStyleUndefined(UndefinedType.TransformScaleY);
    //     } else {
    //         this._scale[1] = value;
    //         gui._transform_scale(this._doc, this._ele, this._scale[0], this._scale[1]);
    //     }
    // }
    // public get scaleY() {
    //     return this._scaleY;
    // }
    // private set scaleZ(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformScaleZ);
    //     } else {
    //         Tools.notSupposeStyle('scaleZ');
    //     }
    // }
    // private set rotate3d(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformRotate3d);
    //     } else {
    //         Tools.notSupposeStyle('rotate3d');
    //     }
    // }
    // private set rotateX(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformRotateX);
    //     } else {
    //         Tools.notSupposeStyle('rotateX');
    //     }
    // }
    // private set rotateY(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformRotateY);
    //     } else {
    //         Tools.notSupposeStyle('rotateY');
    //     }
    // }
    // private set rotateZ(data: string) {
    //     if (data === undefined) {
    //         // this.setStyleUndefined(UndefinedType.TransformRotateZ);
    //     } else {
    //         Tools.notSupposeStyle('rotateZ');
    //     }
    // }
    /**
     * 项目内设置支持的字体名称
     */
    RStyle.FontFamilyList = [];
    RStyle.recycleList = [];
});

/**
 * gui dom 层事件模块数据结构
 */
_$pi.define("pi_gui/gui/gui/r_event_base", ["require", "exports", "../../util/event"], function (require, exports, event_1) {
    "use strict";
    
    /**
     * 事件结果记录
     * * 记录事件冒泡的路径节点
     * * 记录事件坐标
     * * 记录事件时间
     */
    class REventResult {
        constructor(evt) {
            this.x = evt.x;
            this.y = evt.y;
            this._type = evt.pointerType;
            this.time = evt.timeNow;
            this.path = evt.path;
        }
    }
    exports.REventResult = REventResult;
    /**
     * R gui 节点事件类型
     */
    var REventTypes;
    (function (REventTypes) {
        REventTypes["up"] = "pointerup";
        REventTypes["down"] = "pointerdown";
        REventTypes["click"] = "pointerclick";
        REventTypes["move"] = "pointermove";
        REventTypes["longTap"] = "longTap";
        REventTypes["dbclick"] = "dbclick";
        REventTypes["multiPointer"] = "multipointer";
        REventTypes["wheel"] = "wheel";
        REventTypes["scroll"] = "scroll";
        REventTypes["change"] = "change";
        REventTypes["blur"] = "blur";
        REventTypes["focus"] = "focus";
    })(REventTypes = exports.REventTypes || (exports.REventTypes = {}));
    /**
     * 以 PointerID 为区分的事件数据记录
     * * 对 具有相同 pointerID 的 up,down,move 等事件做执行状态记录
     */
    class PointerRecord {
        constructor(id, isPrimary) {
            /**
             * 按下 标识
             */
            this.isDown = false;
            /**
             * 移动 标识
             */
            this.isMove = false;
            /**
             * 点击 有效标识 - move 超出限制后不能响应 click
             */
            this.isClickEffective = false;
            /**
             * 移动起点
             */
            this.moveStartX = 0;
            /**
             * 移动起点
             */
            this.moveStartY = 0;
            /**
             * 本次事件 长按 标识
             */
            this.isLongTap = false;
            this.pointerID = id;
            this.isPrimary = isPrimary;
        }
    }
    exports.PointerRecord = PointerRecord;
    /**
     * 回收 ListenerList
     */
    // tslint:disable-next-line:no-unnecessary-class
    class ListenerListMgr {
        static create() {
            if (this.list.length) {
                return this.list.pop();
            }
            else {
                return new event_1.ListenerList();
            }
        }
        static recycle(l) {
            if (l) {
                l.clear();
                this.list.push(l);
            }
        }
    }
    exports.ListenerListMgr = ListenerListMgr;
    ListenerListMgr.list = [];
});

/**
 * 上下文节点
 * * 对应 document
 * * 节点操作接口
 * * 事件处理
 * * 渲染控制
 * * 调试控制
 */
_$pi.define("pi_gui/gui/gui/r_document", ["require", "exports", "../../../pi_sys/modules/util/event", "./animation", "./gui", "./r_containerelement", "./r_datastruct", "./r_event", "./r_event_base", "./r_imageelement", "./r_inputtext", "./r_textarea", "./r_textelement", "./r_event_limiter", "./r_render", "./r_sheet", "./shader_init", "./tools"], function (require, exports, event_1, animation_1, gui_1, r_containerelement_1, r_datastruct_1, r_event_1, r_event_base_1, r_imageelement_1, r_inputtext_1, r_textarea_1, r_textelement_1, r_event_limiter_1, r_render_1, r_sheet_1, shader_init_1, tools_1) {
    "use strict";
    
    /**
     * GUI 上下文
     */
    class RDocument {
        constructor(canvas, fbo, opt, renderFlag = r_datastruct_1.GUIRenderFlags.BIND) {
            /**
             * 子节点列表
             */
            this.childNodes = [];
            /**
             * 节点堆
             */
            this.elementMap = new Map();
            /**
             * 上下文根上的事件监听列表
             */
            this.upCaps = new event_1.ListenerList();
            /**
             * 上下文根上的事件监听列表
             */
            this.downCaps = new event_1.ListenerList();
            /**
             * 上下文根上的事件监听列表
             */
            this.moveCaps = new event_1.ListenerList();
            /**
             * 是否开启命中检查 - 高亮节点矩形信息
             */
            this.debug = false;
            /**
             * GUI 更新时是否始终设置脏
             */
            this.dirtyDebug = false;
            /**
             * 节点插入时的检测是否抛出异常
             */
            this.appendDebug = false;
            /**
             * 是否 隔离 gui 库接口的调用
             */
            this.debugUseLIB = true;
            /**
             * 渲染层资源释放延时
             */
            this.resTimeOut = 3000;
            /**
             *
             */
            this.renderAuto = false;
            this.autoClear = true;
            /**
             * 保留的上一帧时间戳
             */
            this.lastFPSTime = 0;
            /**
             * JS 层脏标记
             */
            // tslint:disable-next-line:variable-name
            this._layoutDirty = true;
            /**
             * 渲染循环计数
             */
            // tslint:disable-next-line:variable-name
            this._renderCount = 0;
            /**
             * 可滚动节点的记录
             */
            // tslint:disable-next-line:variable-name
            this._scrollEles = new Map();
            /**
             * 渲染模式 是否直接渲染到 canvas
             */
            // tslint:disable-next-line:variable-name
            this._renderModeToCanvas = false;
            /**
             * canvas 上坐标转换为GUI内显示坐标
             * * 刘海兼容
             * * GUI 预期缩放兼容
             */
            this.canvasPosToGUIPos = (x, y) => {
                x = (x - this.viewOption.left) / (this.viewOption.scale || 1) - this.viewOption.notchWidth;
                y = (y - this.viewOption.top) / (this.viewOption.scale || 1) - this.viewOption.notchHeight;
                return [x, y];
            };
            this.afterDisplayDebugLayer = (node) => {
                //
            };
            /**
             * 预留节点所属Widget是否可操作的查询接口
             * * 默认为true
             * * 外层重载获得确实的结果
             */
            this.askWidgetClosedCall = (ele) => {
                return false;
            };
            /**
             * 预留节点所属Widget是否可操作的查询接口
             * * 默认为true
             * * 外层重载获得确实的结果
             */
            this.askWidgetEnableCall = (ele) => {
                return true;
            };
            /**
             * 上下文渲染接口 - 渲染 GUI 内容
             */
            this.renderContent = () => {
                this._renderCount++;
                this.timeStamp = Date.now();
                if (this.timeStamp - this.lastFPSTime > 500) {
                    this.renderFps(Math.ceil(this._renderCount * 2 * 500 / (this.timeStamp - this.lastFPSTime)));
                    this.lastFPSTime = this.timeStamp;
                    this._renderCount = 0;
                }
                // 动画循环
                animation_1.AnimationControl.loop();
                // gui 强制脏
                this.dirtyDebug && gui_1.gui._set_render_dirty(this.uniqueID);
                // 调试节点 高亮 隐藏
                !this.debug && this.hiddenDebugLayer();
                // 检查激活 scroll 的节点的状态
                this.checkScrollEles();
                // const now = Date.now();
                // console.warn(`gui._render : begin`);
                // gui 渲染调用
                gui_1.gui._render(this.uniqueID);
                // console.warn(`gui._render : ${Date.now() - now}`);
                this.layoutDirty = false;
                // 全局通信对象重置
                window.__jsObj = undefined;
                // this._renderImpl && this._renderImpl.doUnbind();
            };
            /**
             * GUI 结果渲染
             */
            this.renderToCanvas = () => {
                if (this._renderModeToCanvas) {
                    // gui 渲染调用
                    this.renderContent();
                }
                else {
                    if (this._renderImpl) {
                        this._renderImpl.render(this.autoClear);
                    }
                    else {
                        console.log('渲染错误');
                    }
                }
            };
            /**
             * 渲染到 FBO
             */
            this.renderToFBO = () => {
                if (this._renderModeToCanvas === false) {
                    if (this._renderImpl) {
                        // this._renderImpl.bindFBO();
                        // gui 渲染调用
                        this.renderContent();
                    }
                    else {
                        console.log('渲染错误');
                    }
                }
            };
            this.setBeforeRenderCall = (f) => {
                this._renderImpl.setBeforeRenderCall(f);
            };
            /**
             * 根上 down 事件触发
             * * 1. 捕获处理
             * * 2. 冒泡响应
             */
            this.downFire = (e) => {
                if (!this.eventLimit.checkForbid(e.clientX, e.clientY)) {
                    // 1. 捕获处理
                    const evt = this.eventMgr.getEventData(e);
                    this.downCaps.notify(evt);
                    // 2. 冒泡响应
                    if (!evt.stopPropagation) {
                        this.eventMgr.downFire(e);
                    }
                }
            };
            /**
             * 根上 up 事件触发
             * * 1. 捕获处理
             * * 2. 冒泡响应
             */
            this.upFire = (e) => {
                if (!this.eventLimit.checkForbid(e.clientX, e.clientY)) {
                    // 1. 捕获处理
                    const evt = this.eventMgr.getEventData(e);
                    this.upCaps.notify(evt);
                    // 2. 冒泡响应
                    // if (!evt.stopPropagation) {
                    this.eventMgr.upFire(e);
                    // }
                }
            };
            /**
             * 根上 move 事件触发
             * * 1. 捕获处理
             * * 2. 冒泡响应
             */
            this.moveFire = (e) => {
                if (!this.eventLimit.checkForbid(e.clientX, e.clientY)) {
                    // 1. 捕获处理
                    const evt = this.eventMgr.getEventData(e);
                    this.moveCaps.notify(evt);
                    // 2. 冒泡响应
                    if (!evt.stopPropagation) {
                        this.eventMgr.moveFire(e);
                    }
                    else {
                        if (this.debug) {
                            this.eventMgr.pickResult(evt);
                        }
                    }
                }
            };
            /**
             * 滑轮事件响应
             */
            this.wheelFire = (e) => {
                if (!this.eventLimit.checkForbid(e.clientX, e.clientY)) {
                    // 2. 冒泡响应
                    this.eventMgr.wheelFire(e);
                }
            };
            this.viewOption = opt || {
                left: 0,
                top: 0,
                width: canvas.width,
                height: canvas.height,
                notchHeight: 0,
                notchWidth: 0,
                clearColor: '#000000'
            };
            this.RenderFlag = renderFlag;
            this.eventMgr = new r_event_1.REventManager(this);
            this.eventLimit = new r_event_limiter_1.REventLimiter(this);
            this.canvas = canvas;
            if (RDocument.MainDocumentUniqueID === undefined) {
                RDocument.createMainEngine(canvas);
            }
            this.gl = RDocument.MainGL;
            this.engine = RDocument.MainEngine;
            this.uniqueID = RDocument.MainDocumentUniqueID;
            this.setClearColor();
            if (!fbo) {
                this._renderImpl = new r_render_1.RRender(canvas, this.gl);
                fbo = this._renderImpl.fbo || undefined;
                window.__fbo = fbo;
                this._renderImpl.fboID = gui_1.gui._create_render_target(this.uniqueID);
                gui_1.gui._bind_render_target(this.uniqueID, this._renderImpl.fboID);
            }
            else {
                window.__fbo = fbo;
                const fboID = gui_1.gui._create_render_target(this.uniqueID);
                gui_1.gui._bind_render_target(this.uniqueID, fboID);
            }
            this.body = this.createBody();
            this.sheet = new r_sheet_1.RSheet(this);
        }
        /**
         * JS 层设置脏
         */
        get layoutDirty() {
            return this._layoutDirty;
        }
        /**
         * JS 层设置脏
         */
        set layoutDirty(b) {
            this._layoutDirty = b;
        }
        /**
         * 获取目标节点 底层信息
         * @param _doc 目标上下文标识
         * @param id 目标节点标识
         */
        // tslint:disable-next-line:variable-name
        static nodeInfo(_doc, id) {
            if (gui_1.gui._node_info) {
                gui_1.gui._node_info(_doc, id);
                // tslint:disable-next-line:no-unnecessary-local-variable
                const res = window.__jsObj;
                tools_1.Tools.log(res);
            }
            else {
                console.warn('已取消接口 _node_info');
            }
        }
        static createMainEngine(canvas) {
            const gl = canvas.getContext('webgl', {
                antialias: false,
                alpha: false,
                // antialias?: GLboolean;
                depth: true,
                stencil: true,
                // failIfMajorPerformanceCaveat?: boolean;
                // powerPreference?: WebGLPowerPreference;
                // premultipliedAlpha?: GLboolean;
                preserveDrawingBuffer: false
                // stencil?: GLboolean;
            });
            let pre = Date.now();
            // 底层创建上下文接口
            window.__gl = gl;
            // 重置 bindFramebuffer -
            // https://developers.weixin.qq.com/community/minigame/doc/0008ee10cd8c789fa439ebbc45fc01
            // 微信 7.0.7 Android 小游戏 离屏 webgl 黑屏临时解决方案
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            const engine = gui_1.gui._create_engine(0);
            console.warn(`_create_engine use: ${Date.now() - pre}`);
            shader_init_1.initShaders(engine);
            pre = Date.now();
            // tslint:disable-next-line:variable-name
            const _doc = gui_1.gui._create_gui(engine, canvas.width, canvas.height);
            console.warn(`_create_gui use: ${Date.now() - pre}`);
            RDocument.MainDocumentUniqueID = _doc;
            RDocument.MainEngine = engine;
            RDocument.MainGL = gl;
            RDocument.dcssList.forEach((css) => {
                RDocument._dcssRegist(css);
            });
            RDocument.dcssList.length = 0;
        }
        setRenderMode(toCanvas) {
            if (this._renderModeToCanvas !== toCanvas) {
                if (this._renderModeToCanvas === true) {
                    gui_1.gui._bind_render_target(this.uniqueID, this._renderImpl.fboID);
                }
                else {
                    gui_1.gui._bind_render_target(this.uniqueID, 0);
                }
            }
            this._renderModeToCanvas = toCanvas;
        }
        /**
         * 应用目标样式
         * @param s 目标样式
         * @param key 样式键
         * @param value 样式值
         */
        applyStyle(s, key, value) {
            // s[`set${key}`] && s[`set${key}`](value);
            s[key] = value;
            return this;
        }
        /**
         * 获取目标样式
         * @param s 目标样式
         * @param key 样式键
         */
        readStyle(s, key) {
            // if (s[`get${key}`]) {
            //     return s[`get${key}`]();
            // } else {
            //     return ;
            // }
            return s[key];
        }
        /**
         * 手动执行布局
         */
        layout() {
            this._layoutDirty === true && gui_1.gui._cal_layout(this.uniqueID);
            this._layoutDirty = false;
        }
        willChange(node) {
            if (node && this._willChangeNode !== node) {
                this.willChangeClear();
                this._willChangeNode = node;
                gui_1.gui._set_transform_will_change(this.uniqueID, node.uniqueID, 1);
            }
        }
        /**
         * 清除 willchange 状态
         * * 每帧渲染前会检查 可滚动节点的滚动属性
         *      - 如果节点滚动属性需要做调整 则会 设置其 willChange 、 修改transform
         *      - 如果节点滚动属性不需要做调整 则会 清除其 willChange
         * * 节点设置
         * @param node
         */
        willChangeClear(node) {
            // 节点销毁
            if (node) {
                if (this._willChangeNode && node.uniqueID === this._willChangeNode.uniqueID) {
                    gui_1.gui._set_transform_will_change(this.uniqueID, this._willChangeNode.uniqueID, 0);
                }
            }
            else {
                // 操作停止
                if (this._willChangeNode) {
                    gui_1.gui._set_transform_will_change(this.uniqueID, this._willChangeNode.uniqueID, 0);
                }
            }
            this._willChangeNode = undefined;
        }
        /**
         * 创建指定类型节点
         * - 向 DOM createElement 接口对齐
         * * 1. 创建指定类型节点
         * * 2. 记录创建的节点
         * @param _type 节点类型
         */
        // tslint:disable-next-line:variable-name
        createElement(_type) {
            let ele;
            // 1. 创建指定类型节点
            switch (_type) {
                case r_datastruct_1.RElementTypeList.DIV: {
                    ele = new r_containerelement_1.RContainerElement({ document: this, RenderFlag: this.RenderFlag });
                    break;
                }
                case r_datastruct_1.RElementTypeList.IMAGE: {
                    ele = new r_imageelement_1.RImageElement({ document: this, RenderFlag: this.RenderFlag });
                    break;
                }
                case r_datastruct_1.RElementTypeList.SPAN: {
                    ele = new r_textelement_1.RTextElement({ document: this, RenderFlag: this.RenderFlag });
                    break;
                }
                case r_datastruct_1.RElementTypeList.textarea: {
                    ele = new r_textarea_1.RTextArea({ document: this, RenderFlag: this.RenderFlag });
                    break;
                }
                case r_datastruct_1.RElementTypeList.input: {
                    ele = new r_inputtext_1.RInputText({ document: this, RenderFlag: this.RenderFlag });
                    break;
                }
                default:
            }
            // 2. 记录创建的节点
            if (ele) {
                this.elementMap.set(ele.uniqueID, ele);
            }
            // Tools.log('Create Element', ele.uniqueID);
            return ele;
        }
        /**
         * 节点销毁调用
         * @param ele 目标节点
         * * 节点移除前调用，清除节点在根上的记录
         * * 仅 RElement.remove 调用
         */
        destroyElement(ele) {
            if (ele) {
                this.willChangeClear(ele);
                this.elementMap.delete(ele.uniqueID);
            }
        }
        /**
         * 添加全局事件监听
         * @param _type 监听类型
         * @param _listener 监听函数
         * @param isCap 是否在捕获期执行
         */
        // tslint:disable-next-line:variable-name
        addCapEventListener(_type, _listener, isCap = true) {
            switch (_type) {
                case (r_event_base_1.REventTypes.up): {
                    this.upCaps.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.down): {
                    this.downCaps.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.move): {
                    this.moveCaps.add(_listener);
                    break;
                }
                default:
            }
        }
        /**
         * 移除全局事件监听
         * @param _type 监听类型
         * @param _listener 监听函数
         * @param isCap 是否在捕获期执行
         */
        // tslint:disable-next-line:variable-name
        removeCapEventListener(_type, _listener, isCap) {
            switch (_type) {
                case (r_event_base_1.REventTypes.up): {
                    this.upCaps.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.down): {
                    this.downCaps.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.move): {
                    this.moveCaps.remove(_listener);
                    break;
                }
                default:
            }
        }
        /**
         * 渲染 调试的目标节点的 调试信息
         * @param ele 目标节点
         */
        renderDebugLayer(ele) {
            this.hiddenDebugLayer();
            if (this.debug) {
                this.createDebugLayer();
                if (ele) {
                    this.displayDebugLayer(ele);
                    tools_1.Tools.log(ele);
                    RDocument.nodeInfo(this.uniqueID, ele.uniqueID);
                    window.debugNode = ele;
                    this.afterDisplayDebugLayer(ele);
                }
            }
        }
        /**
         * 添加激活 scroll 的节点记录
         */
        addScrollEle(ele) {
            this._scrollEles.set(ele.uniqueID, ele);
        }
        /**
         * 移除激活 scroll 的节点记录
         */
        removeScrollEle(ele) {
            this._scrollEles.delete(ele.uniqueID);
        }
        /**
         * 执行激活 scroll 的节点 在渲染前的检查
         */
        checkScrollEles() {
            this._scrollEles.forEach((ele) => {
                if (this.askWidgetClosedCall && this.askWidgetClosedCall(ele)) {
                    //
                }
                else {
                    ele.checkScroll();
                }
            });
        }
        /**
         * 创建 FPS 显示
         */
        createFPS() {
            try {
                const div = document.createElement('div');
                div.style.cssText = 'position:absolute;width:60px;height:26px;top:0;left:0;z-index:1000000;';
                const bg = document.createElement('div');
                bg.style.cssText = 'position:absolute;width:60px;height:26px;top:0;left:0;backkground-color:#ddd;opacity:0.8;';
                this.FPSDom = document.createElement('span');
                this.FPSDom.style.cssText = 'position:absolute;width:60px;height:26px;font-size:20px;font-weight:bold;color:#e00;';
                document.body.appendChild(div);
                div.appendChild(bg);
                div.appendChild(this.FPSDom);
            }
            catch (error) {
                this.FPSDom = undefined;
            }
        }
        /**
         * 创建上下文 - canvas 全屏
         */
        createDocument() {
            // tslint:disable-next-line:variable-name
            const _doc = gui_1.gui._create_gui(this.engine, this.canvas.width, this.canvas.height);
            const rgba = tools_1.Tools.backgroundColor(this.viewOption.clearColor);
            // 设置 GUI 清屏颜色
            gui_1.gui._set_clear_color(_doc, rgba[0], rgba[1], rgba[2], rgba[3]);
            return _doc;
        }
        /**
         * 创建上下文 - canvas 全屏
         */
        setClearColor() {
            const rgba = tools_1.Tools.backgroundColor(this.viewOption.clearColor);
            // 设置 GUI 清屏颜色
            gui_1.gui._set_clear_color(this.uniqueID, rgba[0], rgba[1], rgba[2], rgba[3]);
        }
        /**
         * 创建 body 节点
         * * 项目指定显示范围
         */
        createBody() {
            const root = this.createElement(`div`);
            const rootStyle = root.style;
            this.applyStyle(rootStyle, 'left', `${this.viewOption.left}px`)
                .applyStyle(rootStyle, 'top', `${this.viewOption.top}px`)
                .applyStyle(rootStyle, 'width', `${this.viewOption.width}px`)
                .applyStyle(rootStyle, 'height', `${this.viewOption.height}px`)
                .applyStyle(rootStyle, 'position', `absolute`)
                .applyStyle(rootStyle, 'transform', `scale(${this.viewOption.scale || 1})`)
                .applyStyle(rootStyle, 'transformOrigin', `0px 0px`);
            gui_1.gui._append_child(this.uniqueID, root.uniqueID, 1); // 父节点为 document 特殊处理
            this.notchBar = this.createElement(`div`);
            const notchBarStyle = this.notchBar.style;
            this.applyStyle(notchBarStyle, 'left', `0px`)
                .applyStyle(notchBarStyle, 'top', `0px`)
                // tslint:disable-next-line:max-line-length
                .applyStyle(notchBarStyle, 'width', `${this.viewOption.notchWidth ? this.viewOption.notchWidth : this.viewOption.notchHeight ? this.viewOption.width : 0}px`)
                // tslint:disable-next-line:max-line-length
                .applyStyle(notchBarStyle, 'height', `${this.viewOption.notchHeight ? this.viewOption.notchHeight : this.viewOption.notchWidth ? this.viewOption.height : 0}px`)
                .applyStyle(notchBarStyle, 'position', `absolute`)
                .applyStyle(notchBarStyle, 'backgroundColor', '#000000');
            gui_1.gui._append_child(this.uniqueID, this.notchBar.uniqueID, root.uniqueID); // 父节点为 document 特殊处理
            const ele = this.createElement(`div`);
            const s = ele.style;
            this.applyStyle(s, 'left', `${this.viewOption.notchWidth}px`)
                .applyStyle(s, 'top', `${this.viewOption.notchHeight}px`)
                .applyStyle(s, 'width', `${this.viewOption.width - this.viewOption.notchWidth}px`)
                .applyStyle(s, 'height', `${this.viewOption.height - this.viewOption.notchHeight}px`)
                .applyStyle(s, 'position', `absolute`);
            gui_1.gui._append_child(this.uniqueID, ele.uniqueID, root.uniqueID); // 父节点为 document 特殊处理
            return ele;
        }
        renderFps(time) {
            if (this.FPSDom) {
                this.FPSDom.textContent = `${time}-FPS`;
            }
        }
        /**
         * 创建调试节点
         */
        createDebugLayer() {
            if (this._debugLayer === undefined) {
                this._debugLayer = new r_containerelement_1.RContainerElement({ document: this, RenderFlag: this.RenderFlag });
                const a = this._debugLayer.style;
                this.applyStyle(a, 'position', 'absolute')
                    .applyStyle(a, 'borderColor', '#0e20ff')
                    .applyStyle(a, 'borderWidth', '2px')
                    .applyStyle(a, 'backgroundColor', '#5cb3cc77')
                    .applyStyle(a, 'left', '-10px')
                    .applyStyle(a, 'top', '-10px')
                    .applyStyle(a, 'width', '10px')
                    .applyStyle(a, 'height', '10px');
                this._debugLayer.enabled(1);
                this.hiddenDebugLayer();
                gui_1.gui._append_child(this.uniqueID, this._debugLayer.uniqueID, 1);
            }
        }
        displayDebugLayer(ele) {
            const [l, t, w, h] = ele.getScreenInfo();
            const a = this._debugLayer.style;
            this.applyStyle(a, 'display', 'flex')
                .applyStyle(a, 'left', `${l}px`)
                .applyStyle(a, 'top', `${t}px`)
                .applyStyle(a, 'width', `${w * this.viewOption.scale}px`)
                .applyStyle(a, 'height', `${h * this.viewOption.scale}px`);
        }
        hiddenDebugLayer() {
            if (this._debugLayer) {
                this.applyStyle(this._debugLayer.style, 'display', 'none');
            }
        }
    }
    exports.RDocument = RDocument;
    RDocument.dcssList = [];
    RDocument.dcssRegist = (css) => {
        if (!ArrayBuffer.isView(css)) {
            css = new Uint8Array(css);
        }
        RDocument.dcssList.push(css);
        if (RDocument.MainDocumentUniqueID) {
            RDocument._dcssRegist(css);
        }
        // if (RDocument.MainDocumentUniqueID === undefined) {
        //     RDocument.dcssList.push(css);
        // } else {
        //     RDocument._dcssRegist(css);
        // }
    };
    // tslint:disable-next-line:variable-name
    RDocument._dcssRegist = (css) => {
        const pre = Date.now();
        window.__jsObj = css;
        gui_1.gui._create_class_by_bin(RDocument.MainDocumentUniqueID);
        console.warn(`dcss use: ${Date.now() - pre}`);
    };
});

/**
 * gui dom 层基础数据表
 */
_$pi.define("pi_gui/gui/gui/r_datastruct", ["require", "exports"], function (require, exports) {
    "use strict";
    
    exports.GUIRenderFlags = {
        /**
         * DOM 渲染
         */
        DOM: 1,
        /**
         * BIND 渲染
         */
        BIND: 2,
        /**
         * BABYLON-GUI 渲染
         */
        BABYLONGUI: 3,
        PIXI: 4,
        THREE3D: 5,
        CANVAS2D: 6
    };
    /**
     * R gui 节点类型
     */
    exports.RElementTypeList = {
        DIV: 'div',
        IMAGE: 'img',
        SPAN: 'span',
        input: 'input',
        textarea: 'textarea',
        LIST: ['div', 'img', 'span', 'input', 'textarea']
    };
});
// /**
//  * GUI 图片资源配置
//  */
// export interface GUIImageResCfg {
//     /**
//      * 资源 项目路径
//      */
//     path: string;
//     /**
//      * 资源链接
//      * * 同时为 GUI 底层缓冲路径 - 合并在一起的图片共用该路径
//      */
//     url: string;
//     /**
//      * 是否 有缓冲
//      */
//     hasBuffer: boolean;
//     /**
//      * 图片宽
//      */
//     width: number;
//     /**
//      * 图片高
//      */
//     height: number;
//     /**
//      * 纹理 ID
//      */
//     textureID: number;
//     /**
//      * 图片对象，当 检查缓冲存在时，没有 image 对象
//      */
//     image?: HTMLImageElement | HTMLCanvasElement;
//     isCombine?: boolean;
//     combineWidth?: number;
//     combineHeight?: number;
//     combineLeft?: number;
//     combineTop?: number;
//     combineSrcWidth?: number;
//     combineSrcHeight?: number;
// }
// // Texture
// export interface TextureRes {
// 	left: number, // 源图片左上角在合并图片中的偏移 x_offset
// 	top: number, // 源图片左上角在合并图片中的偏移 y_offset
// 	width: number, // 源图片宽度
// 	height: number, //  源图片高度
// 	isPng: boolean,	// 源图片是否为png图片
// 	combineUrl: string, // 源图片所在合并图片的url
// 	combineWidth: number, // 源图片所在合并图片的宽度
// 	combineHeight: number, // 源图片所在合并图片的高度
// }

/**
 * 容器节点
 * * 对应 DIV
 */
_$pi.define("pi_gui/gui/gui/r_containerelement", ["require", "exports", "./gui", "./r_datastruct", "./r_element", "./tools"], function (require, exports, gui_1, r_datastruct_1, r_element_1, tools_1) {
    "use strict";
    
    /**
     * 容器节点
     */
    class RContainerElement extends r_element_1.RElement {
        constructor(opt) {
            opt.uniqueID = gui_1.gui._create_node(opt.document.uniqueID);
            super(opt);
            this._type = r_datastruct_1.RElementTypeList.DIV;
            this.childNodes = [];
            this._scrollLeft = 0;
            this._scrollTop = 0;
            this._scrollDirty = false;
            this.initDefaultStyle('div');
        }
        /**
         * 子节点滚动属性
         */
        get scrollX() {
            return this.childNodes[0] ? this.childNodes[0].scrollLeft : 0;
        }
        /**
         * 子节点滚动属性
         */
        set scrollX(value) {
            this.childNodes[0] && (this.childNodes[0].scrollLeft = value);
            this._scrollDirty = true;
        }
        /**
         * 子节点滚动属性
         */
        get scrollY() {
            return this.childNodes[0] ? this.childNodes[0].scrollTop : 0;
        }
        /**
         * 子节点滚动属性
         */
        set scrollY(value) {
            this.childNodes[0] && (this.childNodes[0].scrollTop = value);
            this._scrollDirty = true;
        }
        /**
         * 自身滚动属性
         */
        get scrollLeft() {
            if (this._scrollLeft === 0) {
                this._scrollLeft = gui_1.gui._offset_left(this.document.uniqueID, this.uniqueID);
            }
            return this._scrollLeft;
        }
        /**
         * 自身滚动属性
         */
        set scrollLeft(value) {
            if (this._scrollLeft !== value) {
                this._scrollLeft = value;
                this.doScroll(-this._scrollLeft, -this._scrollTop);
                this.document.willChangeClear();
                this._scrollDirty = true;
            }
            else {
                this.document.willChangeClear();
            }
        }
        /**
         * 自身滚动属性
         */
        get scrollTop() {
            if (this._scrollTop === 0) {
                this._scrollTop = gui_1.gui._offset_top(this.document.uniqueID, this.uniqueID);
            }
            return this._scrollTop;
        }
        /**
         * 自身滚动属性
         */
        set scrollTop(value) {
            if (this._scrollTop !== value) {
                this._scrollTop = value;
                this.doScroll(-this._scrollLeft, -this._scrollTop);
                this.document.willChangeClear();
                this._scrollDirty = true;
            }
            else {
                this.document.willChangeClear();
            }
        }
        /**
         * 自身滚动属性
         */
        get scrollWidth() {
            this._scrollWidth = this.contentWidth;
            return this._scrollWidth;
        }
        /**
         * 自身滚动属性
         */
        get scrollHeight() {
            this._scrollHeight = this.contentHeight;
            return this._scrollHeight;
        }
        /**
         * 节点销毁
         */
        remove() {
            for (let len = this.childNodes.length - 1; len >= 0; len--) {
                const child = this.childNodes[len];
                child.remove();
            }
            this.document.removeScrollEle(this);
            super.remove();
        }
        /**
         * 移除子节点
         * @param child 目标子节点
         */
        removeChild(child) {
            const index = this.childNodes.indexOf(child);
            this.childNodes.splice(index, 1);
        }
        /**
         * 移除子节点
         * @param child 目标子节点
         */
        removeChild2(child) {
            const index = this.childNodes.indexOf(child);
            this.childNodes.splice(index, 1);
            gui_1.gui._remove_node(this.document.uniqueID, child.uniqueID);
        }
        /**
         * 添加子节点
         * @param node 目标节点
         */
        appendChild(node) {
            if (this.isDestroy) {
                console.warn(`父节点已销毁！`);
                return;
            }
            if (this.findChild(node)) {
                return;
            }
            this.appendChildCall(node);
            this.childNodes.push(node);
            node.parentNode = this;
            node.updateLevel();
            // Tools.log(`appendChild level parent : ${this.level} child: ${node.level}`);
            // Tools.log(`appendChild uniqueID parent : ${this.uniqueID} child: ${node.uniqueID}`);
            return this;
        }
        /**
         * 添加子节点
         * @param node 目标节点
         */
        appendChild2(node) {
            if (this.isDestroy) {
                console.warn(`父节点已销毁！`);
                return;
            }
            if (this.findChild(node)) {
                return;
            }
            this.appendChildCall(node);
            this.childNodes.push(node);
            node.parentNode = this;
            node.updateLevel();
            // Tools.log(`appendChild level parent : ${this.level} child: ${node.level}`);
            // Tools.log(`appendChild uniqueID parent : ${this.uniqueID} child: ${node.uniqueID}`);
            return this;
        }
        /**
         * 插入子节点
         * @param node 目标节点
         * @param refNode 此节点前插入
         */
        insertBefore(node, refNode) {
            if (this.isDestroy) {
                console.warn(`父节点已销毁！`);
                return;
            }
            if (this.findChild(node)) {
                return;
            }
            if (refNode === undefined) {
                this.appendChildCall(node);
                this.childNodes.push(node);
            }
            else {
                const index = this.childNodes.indexOf(refNode);
                this.insertBeforeCall(node, refNode, index);
                for (let i = this.childNodes.length; i > index; i--) {
                    this.childNodes[i] = this.childNodes[i - 1];
                }
                this.childNodes[index] = node;
            }
            node.parentNode = this;
            node.updateLevel();
            tools_1.Tools.log(`insertBefore parent: ${this.level} child: ${node.level}`);
            tools_1.Tools.log(`insertBefore parent: ${this.uniqueID} child: ${node.uniqueID}`);
            return this;
        }
        replaceChild(newNode, oldNode) {
            // TODO
            return this;
        }
        /**
         * 更新节点层级
         * * 遍历更新子节点层级
         */
        updateLevel() {
            if (this._level === this.parentNode._level + 1) {
                return;
            }
            super.updateLevel();
            for (const child of this.childNodes) {
                child.updateLevel();
            }
        }
        /**
         * 节点内部滚动处理
         * * 优先 Y 方向滚动
         * * Y 方向 没有剩余滚动量时，X 方向滚动
         * * x 方向 没有剩余滚动量时，向上冒泡
         */
        wheel(e) {
            tools_1.Tools.log('scroll', this._level);
            let diffX = 0, diffY = 0, isX, isY;
            const attributes = this.attributes;
            this.document.layout();
            switch (attributes.scroll_path) {
                case (tools_1.ScrollPaths.XY): {
                    [isY, diffY] = this.scroll_Y(e);
                    [isX, diffX] = this.scroll_X(e);
                    break;
                }
                case (tools_1.ScrollPaths.Y): {
                    [isY, diffY] = this.scroll_Y(e);
                    break;
                }
                case (tools_1.ScrollPaths.X): {
                    [isX, diffX] = this.scroll_X(e);
                    break;
                }
                default: {
                    isX = false;
                    isY = false;
                }
            }
            if (isX === true || isY === true) {
                this.childNodes[0] && this.childNodes[0].doScroll(-this.scrollX, -this.scrollY);
                this._scrollDirty = true;
            }
            e.stopPropagation = isX === true || isY === true;
            super.wheel(e);
        }
        // /**
        //  * 加载 border-image-source 的接口
        //  */
        // public loadBorderImage() {
        //     if (this.document.readStyle(this.style, 'borderImageSource') && this.loadImageCall) {
        //         // tslint:disable-next-line:max-line-length
        //         this.loadImageCall && this.loadImageCall(this.document.readStyle(this.style, 'borderImageSource'), (cfg: ImageDecs) => { this.loadedBorderImage(cfg); });
        //     }
        // }
        // /**
        //  * 加载 border-image-source 的成功的回调
        //  */
        // public loadedBorderImage(imageDecs: ImageDecs) {
        //     if (this._isDestroy) { return; }
        // 	this._borderImageDecs = imageDecs;
        //     if (!this.document.readStyle(this.style, 'width')) {
        //         // this.document.applyStyle(this.style, 'width', `${this._imageWidth}px`);
        //         this.defWidth(imageDecs.srcUrl? imageDecs.srcWidth: imageDecs.width);
        //     }
        //     if (!this.document.readStyle(this.style, 'height')) {
        //         // this.document.applyStyle(this.style, 'height',`${this._imageHeight}px`);
        //         this.defHeight(imageDecs.srcUrl? imageDecs.srcHeight: imageDecs.height);
        //     }
        //     this.activeBorderImageClip();
        //     this.activeBorderImageSlice();
        //     // gui._set_border_src_with_texture(this.document.uniqueID, this.uniqueID, cfg.textureID);
        //     (<any>window).__jsObj = imageDecs.url;
        //     gui._set_border_image(this.document.uniqueID, this.uniqueID);
        // }
        /**
         * 节点设置 scroll_path 后的处理
         */
        activeScroll() {
            super.activeScroll();
            switch (this.attributes.scroll_path) {
                case (tools_1.ScrollPaths.XY): {
                    this.document.addScrollEle(this);
                    this.document.applyStyle(this.style, 'overflow', 'hidden');
                    break;
                }
                case (tools_1.ScrollPaths.Y): {
                    this.document.addScrollEle(this);
                    this.document.applyStyle(this.style, 'overflow', 'hidden');
                    break;
                }
                case (tools_1.ScrollPaths.X): {
                    this.document.addScrollEle(this);
                    this.document.applyStyle(this.style, 'overflow', 'hidden');
                    break;
                }
                default: {
                    this.document.applyStyle(this.style, 'overflow', 'none');
                    this.document.removeScrollEle(this);
                }
            }
        }
        /**
         * 检查滚动量是否超出可滚动量 - <内容产生变化，节点可能减少了>
         * * 节点刚创建时 不需要检测 -
         */
        checkScroll() {
            if (!this._isDestroy && this._scrollDirty) {
                switch (this.attributes.scroll_path) {
                    case (tools_1.ScrollPaths.XY): {
                        this.checkScrollX();
                        this.checkScrollY();
                        break;
                    }
                    case (tools_1.ScrollPaths.Y): {
                        this.checkScrollY();
                        break;
                    }
                    case (tools_1.ScrollPaths.X): {
                        this.checkScrollX();
                        break;
                    }
                    default: {
                        this.document.removeScrollEle(this);
                    }
                }
                // this._scrollDirty = false;
            }
        }
        /**
         * 查找直接子节点是否已包含目标节点
         * @param node 目标子节点
         */
        findChild(node) {
            let result = false;
            const index = this.childNodes.findIndex((n) => {
                return n.uniqueID === node.uniqueID;
            });
            if (index >= 0) {
                tools_1.Tools.error('node has parent!', node);
                if (this.document.appendDebug) {
                    throw new Error('node has parent!');
                }
                result = true;
            }
            return result;
        }
        /**
         * 内部调用设置 _scrollX - 区别于暴露给外部的接口
         * * 应用于内部修改滚动属性的优化 -
         * @param value
         */
        setScrollX(value) {
            this.childNodes[0] && (this.childNodes[0].setScrollLeft(value));
            this._scrollDirty = true;
        }
        /**
         * 内部调用设置 _scrollY - 区别于暴露给外部的接口
         * @param value
         */
        setScrollY(value) {
            this.childNodes[0] && (this.childNodes[0].setScrollTop(value));
            this._scrollDirty = true;
        }
        /**
         * 内部调用设置 _scrollLeft - 区别于暴露给外部的接口
         * * 应用于内部修改滚动属性的优化 -
         * @param value
         */
        setScrollLeft(value) {
            if (this._scrollLeft !== value) {
                this._scrollLeft = value;
                this._scrollDirty = true;
            }
        }
        /**
         * 内部调用设置 _scrollTop - 区别于暴露给外部的接口
         * @param value
         */
        setScrollTop(value) {
            if (this._scrollTop !== value) {
                this._scrollTop = value;
                this._scrollDirty = true;
            }
        }
        /**
         * 检查、控制 X 方向滚动量
         */
        checkScrollX() {
            let overScrollX = this.childNodes[0] && this.childNodes[0].scrollWidth - (this.width);
            overScrollX = overScrollX > 0 ? overScrollX : 0;
            this.scrollX = Math.min(overScrollX, this.scrollX);
        }
        /**
         * 检查、控制 Y 方向滚动量
         */
        checkScrollY() {
            let overScrollY = this.scrollHeight - (this.height);
            overScrollY = overScrollY > 0 ? overScrollY : 0;
            let target = Math.min(overScrollY, this.scrollY);
            if (target !== this.scrollY) {
                this.scrollY = Math.min(overScrollY, this.scrollY);
            }
        }
        /**
         * 节点内部滚动处理
         * * 优先 Y 方向滚动
         * * Y 方向 没有剩余滚动量时，X 方向滚动
         * * x 方向 没有剩余滚动量时，向上冒泡
         */
        scroll_X(e) {
            tools_1.Tools.log('scroll_X', this._level);
            // tslint:disable-next-line:max-line-length
            let overScrollX = this.childNodes[0] && this.childNodes[0].scrollWidth - (this.scrollX + this.width);
            overScrollX = overScrollX > 0 ? overScrollX : 0;
            let isScroll = false;
            let diff = 0;
            // 向 右 滚动
            if (e.deltaX > 0) {
                isScroll = overScrollX > 0;
                diff = Math.min(e.deltaX, overScrollX);
            }
            else {
                isScroll = this.scrollX > 0;
                diff = Math.max(e.deltaX, -this.scrollX);
            }
            if (isScroll) {
                this.setScrollX(this.scrollX + diff);
                // this.scrollX = this.scrollX + diff;
            }
            return [isScroll, this.scrollX + diff];
        }
        /**
         * 节点内部滚动处理
         * * 优先 Y 方向滚动
         * * Y 方向 没有剩余滚动量时，X 方向滚动
         * * x 方向 没有剩余滚动量时，向上冒泡
         */
        scroll_Y(e) {
            tools_1.Tools.log('scroll_Y', this._level);
            let overScrollY = this.scrollHeight - (this.scrollY + this.height);
            overScrollY = overScrollY > 0 ? overScrollY : 0;
            let isScroll = false;
            let diff = 0;
            // 向 右 滚动
            if (e.deltaY > 0) {
                isScroll = overScrollY > 0;
                diff = Math.min(e.deltaY, overScrollY);
            }
            else {
                isScroll = this.scrollY > 0;
                diff = Math.max(e.deltaY, -this.scrollY);
            }
            if (isScroll) {
                this.setScrollY(this.scrollY + diff);
                // this.scrollY = this.scrollY + diff;
            }
            return [isScroll, this.scrollY + diff];
        }
        /**
         * 添加子节点
         * @param node 目标节点
         */
        appendChildCall(node) {
            tools_1.Tools.log(`appendChildCall `);
            gui_1.gui._append_child(this.document.uniqueID, (node.uniqueID), (this.uniqueID));
            this.document.layoutDirty = true;
        }
        /**
         * 插入子节点
         * @param node 目标节点
         * @param refNode 此节点前插入
         */
        insertBeforeCall(node, refNode, refNodeIndex) {
            gui_1.gui._insert_before(this.document.uniqueID, (node.uniqueID), refNode.uniqueID);
            this.document.layoutDirty = true;
        }
    }
    exports.RContainerElement = RContainerElement;
});

_$pi.define("pi_gui/gui/gui/tools", ["require", "exports", "./enum"], function (require, exports, enum_1) {
    "use strict";
    
    /**
     * 颜色 数据类型集
     */
    exports.BackgroundColorType = {
        RGBA: 1,
        RGB: 2
    };
    var ScrollPaths;
    (function (ScrollPaths) {
        ScrollPaths[ScrollPaths["x"] = 1] = "x";
        ScrollPaths[ScrollPaths["y"] = 2] = "y";
        ScrollPaths[ScrollPaths["xy"] = 3] = "xy";
        ScrollPaths["X"] = "x";
        ScrollPaths["Y"] = "y";
        ScrollPaths["XY"] = "xy";
    })(ScrollPaths = exports.ScrollPaths || (exports.ScrollPaths = {}));
    var ScrollTypes;
    (function (ScrollTypes) {
        ScrollTypes[ScrollTypes["none"] = 0] = "none";
        ScrollTypes[ScrollTypes["xianpi"] = 1] = "xianpi";
        ScrollTypes["NONE"] = "none";
        ScrollTypes["XianPi"] = "xianpi";
    })(ScrollTypes = exports.ScrollTypes || (exports.ScrollTypes = {}));
    var GradientTypes;
    (function (GradientTypes) {
        GradientTypes[GradientTypes["linear"] = 0] = "linear";
        GradientTypes[GradientTypes["radial"] = 1] = "radial";
    })(GradientTypes = exports.GradientTypes || (exports.GradientTypes = {}));
    /**
     * 工具方法
     */
    class FlexBasis {
    }
    exports.FlexBasis = FlexBasis;
    /**
     * RGB 数据模板
     */
    class RGB {
        constructor(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
        }
    }
    exports.RGB = RGB;
    class LengthData {
        constructor(_t, _d) {
            this._t = _t;
            this._d = _d;
        }
        // tslint:disable-next-line:function-name
        static Zero() {
            return new LengthData(enum_1.LengthUnitType.Pixel, 0);
        }
        static mix(percent, first, second, target) {
            target._d = first._d + percent * (second._d - first._d);
        }
        static mixILengthData(percent, first, second) {
            const result = [0, 0];
            result[0] = first[0];
            result[1] = Tools.clipFloat(first[1] + percent * (second[1] - first[1]));
            return result;
        }
        static cloneFrom(src) {
            return new LengthData(src._t, src._d);
        }
        static cloneFromILengthData(src) {
            return [src[0], src[1]];
        }
        clone() {
            return new LengthData(this._t, this._d);
        }
        cloneILengthData() {
            return [this._t, this._d];
        }
        get value() {
            return [this._t, this._d];
        }
    }
    exports.LengthData = LengthData;
    /**
     * RGBA 数据模板
     */
    class RGBA extends RGB {
        constructor(r, g, b, a) {
            super(r, g, b);
            this.a = a;
        }
    }
    exports.RGBA = RGBA;
    class Vector2 {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        static mix(percent, first, second, target) {
            target.x = first.x + percent * (second.x - first.x);
            target.y = first.y + percent * (second.y - first.y);
        }
        static mixIVector2(percent, first, second) {
            const result = [];
            result[0] = Tools.clipFloat(first[0] + percent * (second[0] - first[0]));
            result[1] = Tools.clipFloat(first[1] + percent * (second[1] - first[1]));
            return result;
        }
        static cloneFrom(src) {
            return new Vector2(src.x, src.y);
        }
        static cloneFromIVector2(src) {
            return [src[0], src[1]];
        }
    }
    exports.Vector2 = Vector2;
    class LengthVector2 {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        // tslint:disable-next-line:function-name
        static Zero() {
            return new LengthVector2(LengthData.Zero(), LengthData.Zero());
        }
        static mix(percent, first, second, target) {
            LengthData.mix(percent, first.x, second.x, target.x);
            LengthData.mix(percent, first.y, second.y, target.y);
        }
        static mixILengthVector2(percent, first, second) {
            const result = [];
            result[0] = LengthData.mixILengthData(percent, first[0], second[0]);
            result[1] = LengthData.mixILengthData(percent, first[1], second[1]);
            return result;
        }
        static cloneFrom(src) {
            return new LengthVector2(LengthData.cloneFrom(src.x), LengthData.cloneFrom(src.y));
        }
        static cloneFromILengthVector2(src) {
            return [LengthData.cloneFromILengthData(src[0]), LengthData.cloneFromILengthData(src[1])];
        }
    }
    exports.LengthVector2 = LengthVector2;
    exports.ITransT = 0;
    exports.ITransR = 1;
    exports.ITransS = 2;
    exports.ITransM = 3;
    exports.ITransM3 = 4;
    class Transform {
    }
    exports.Transform = Transform;
    exports.ITransformDataTypes = ['r', 't', 's'];
    var ITransformDataType;
    (function (ITransformDataType) {
        ITransformDataType["translate"] = "t";
        ITransformDataType["scale"] = "s";
        ITransformDataType["rotateZ"] = "r";
    })(ITransformDataType = exports.ITransformDataType || (exports.ITransformDataType = {}));
    // h
    exports.IShadowH = 0;
    // v
    exports.IShadowV = 1;
    // color
    exports.IShadowC = 2;
    // blur
    exports.IShadowB = 3;
    // spread
    exports.IShadowS = 3;
    class Shadow {
    }
    exports.Shadow = Shadow;
    class OverFlow {
    }
    exports.OverFlow = OverFlow;
    class ScrollInfo {
    }
    exports.ScrollInfo = ScrollInfo;
    exports.BoxA = 0;
    exports.BoxT = 1;
    exports.BoxR = 2;
    exports.BoxB = 3;
    exports.BoxL = 4;
    class BoxData {
    }
    exports.BoxData = BoxData;
    class GradientData {
    }
    exports.GradientData = GradientData;
    class AnimationCmd {
        constructor(name) {
            /**
             * 动画时长
             */
            this.duration = 0;
            /**
             * 动画执行应用的数学过程
             */
            this.timingFunction = 'linear';
            /**
             * 动画延时
             */
            this.delayTime = 0;
            /**
             * 动画循环次数
             */
            this.iteration = 1;
            /**
             * 动画循环模式
             */
            this.direction = 'normal';
            /**
             * 动画结束状态
             */
            this.fillMode = 'none';
            this.name = name;
        }
    }
    exports.AnimationCmd = AnimationCmd;
    /**
     * R gui 工具方法集
     */
    // tslint:disable-next-line:no-unnecessary-class
    class Tools {
        static log(...args) {
            if (this.logFlag) {
                console.log(...args);
            }
        }
        static warn(...args) {
            if (this.warnFlag) {
                if (this.isDev) {
                    this.devError(args.toString());
                }
                else {
                    console.warn(...args);
                }
            }
        }
        static error(...args) {
            if (this.errorFlag) {
                if (this.isDev) {
                    this.devError(args.toString());
                }
                else {
                    console.warn(...args);
                }
            }
        }
        static devError(msg) {
            try {
                throw new Error(msg);
            }
            catch (error) {
                //
            }
        }
        /**
         * 解析长度数据
         * @param data 表示长度的字符串
         * * 20px
         * * 20%
         */
        // public static lengthData(data: string): LengthData {
        static lengthData(data) {
            data = data.trim();
            if (data === undefined) {
                return;
            }
            else if (data === 'auto') {
                return [enum_1.LengthUnitType.Auto, 0];
            }
            else {
                const len = data.length;
                let _t, _d;
                if (data[len - 2] === `p` && data[len - 1] === `x`) {
                    _t = enum_1.LengthUnitType.Pixel;
                    _d = data.substring(0, len - 2);
                }
                else if (data[len - 1] === `%`) {
                    _t = enum_1.LengthUnitType.Percent;
                    _d = data.substring(0, len - 1);
                    _d = (_d - 0);
                }
                else {
                    _t = enum_1.LengthUnitType.Pixel;
                    _d = 0;
                    if (data !== '0') {
                        Tools.warn(`无效 lengthData : ${data}, 设置为默认 0%`);
                    }
                }
                _d = _d - 0;
                // return new LengthData(_t, _d);
                return [_t, _d];
            }
        }
        /**
         * 打印不支持的属性名称
         * @param _t 属性名称
         * * debug 反馈不支持的属性名称
         */
        static notSupposeStyle(_t) {
            Tools.log(`暂不支持属性 ${_t}`);
        }
        /**
         * 解析 border 数据
         * @param data border
         */
        static color(data) {
            return Tools.backgroundColor(data);
        }
        /**
         *
         * @param data 表示颜色的字符串
         * * #fff
         * * #ffff00
         * * #ffff0066
         * * rgb(255, 0, 255)
         * * rgba(255, 0, 0, 0.5)
         * @returns RGBA : {r: <0~1>, g: <0~1>, b: <0~1>, a: <0~1>}
         */
        static backgroundColor(data) {
            data = data || '';
            data = this.format_space(data);
            let _t, r = 0, g = 0, b = 0, a = 1;
            // let _d: RGBA;
            let _d;
            // hex 类型颜色设置
            if (data[0] === '#') {
                _t = exports.BackgroundColorType.RGBA;
                // #FFF
                if (data.length === 4) {
                    [r, g, b] = [parseInt(data[1], 16) / 15, parseInt(data[2], 16) / 15, parseInt(data[3], 16) / 15];
                    // #FFFFFF
                }
                else if (data.length === 7) {
                    [r, g, b] = [parseInt(data[1] + data[2], 16) / 255, parseInt(data[3] + data[4], 16) / 255, parseInt(data[5] + data[6], 16) / 255];
                }
                else if (data.length === 9) {
                    [r, g, b, a] = [parseInt(data[1] + data[2], 16) / 255, parseInt(data[3] + data[4], 16) / 255, parseInt(data[5] + data[6], 16) / 255, parseInt(data[7] + data[8], 16) / 255];
                }
                // rgb() 类型颜色设置
            }
            else if (data[0] === 'r' && data[1] === 'g' && data[2] === 'b') {
                let list;
                // rgba(255, 255, 255, 0.5)
                if (data[3] === 'a') {
                    _t = exports.BackgroundColorType.RGBA;
                    data = data.trim();
                    data = data.substring(5, data.length - 1);
                    list = data.split(',');
                    [r, g, b, a] = [(list[0] - 0) / 255, (list[1] - 0) / 255, (list[2] - 0) / 255, (list[3] - 0)];
                    // rgb(255, 255, 255)
                }
                else {
                    _t = exports.BackgroundColorType.RGBA;
                    data = data.substring(4, data.length - 1);
                    list = data.split(',');
                    [r, g, b] = [(list[0] - 0) / 255, (list[1] - 0) / 255, (list[2] - 0) / 255];
                }
            }
            else {
                a = 0;
                Tools.warn(`无效 RGBA : ${data}`);
            }
            // _d = new RGBA(Tools.clipFloat(r), Tools.clipFloat(g), Tools.clipFloat(b), Tools.clipFloat(a));
            _d = [Tools.clipFloat(r), Tools.clipFloat(g), Tools.clipFloat(b), Tools.clipFloat(a)];
            return _d;
        }
        static clipFloat(v) {
            return (Math.round(v * 100) / 100);
        }
        static clipInt(v) {
            return Math.round(v);
        }
        /**
         * 构建期调用, 不解析，因为生成的类型数组经过 json 处理会变成简单对象
         * @param data html样式
         */
        static background(data) {
            data = this.format_space(data);
            return data;
        }
        /**
         * 运行期调用，生成的类型数组可生效
         * @param data html样式
         */
        static background_(data) {
            data = this.format_space(data);
            const startChar = data[0];
            let graidient;
            switch (startChar) {
                case ('l'): {
                    graidient = this.lineGradient(data);
                    break;
                }
                case ('r'): {
                    graidient = this.radioGradient(data);
                    break;
                }
                default: {
                    Tools.warn(`无效 background : ${data}`);
                }
            }
            return graidient;
        }
        // public static width(data: string): LengthData {
        static width(data) {
            return Tools.lengthData(data);
        }
        // public static height(data: string): LengthData {
        static height(data) {
            return Tools.lengthData(data);
        }
        // public static minWidth(data: string): LengthData {
        static minWidth(data) {
            return Tools.lengthData(data);
        }
        // public static maxWidth(data: string): LengthData {
        static maxWidth(data) {
            return Tools.lengthData(data);
        }
        // public static minHeight(data: string): LengthData {
        static minHeight(data) {
            return Tools.lengthData(data);
        }
        // public static maxHeight(data: string): LengthData {
        static maxHeight(data) {
            return Tools.lengthData(data);
        }
        /**
         * 解析 display 属性
         * @param data html 样式数据
         */
        static display(data) {
            let value;
            switch (data) {
                case ('none'): {
                    value = enum_1.YGDisplay.YGDisplayNone;
                    break;
                }
                // 默认flex布局为 inline-flex
                default: {
                    value = enum_1.YGDisplay.YGDisplayFlex;
                }
            }
            return value;
        }
        /**
         * 不透明度
         * @param data html 样式数据
         * * 未处理 0-1 范围外的值
         */
        static opacity(data) {
            let value = data - 0;
            if (isNaN(value)) {
                value = 1;
                Tools.warn(`无效 opacity : ${data}`);
            }
            return value;
        }
        static zIndex(data) {
            let value = data - 0;
            if (isNaN(value)) {
                value = undefined;
                Tools.warn(`无效 zIndex : ${data}`);
            }
            return value;
        }
        /**
         * 是否可见
         * @param data html 样式数据
         */
        static visibility(data) {
            let value;
            switch (data) {
                case ('hidden'): {
                    value = false;
                    break;
                }
                default: {
                    value = true;
                }
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static flexDirection(data) {
            let value;
            switch (data) {
                case ('column'): {
                    value = enum_1.YGFlexDirection.YGFlexDirectionColumn;
                    break;
                }
                case ('column-reverse'): {
                    value = enum_1.YGFlexDirection.YGFlexDirectionColumnReverse;
                    break;
                }
                case ('row'): {
                    value = enum_1.YGFlexDirection.YGFlexDirectionRow;
                    break;
                }
                case ('row-reverse'): {
                    value = enum_1.YGFlexDirection.YGFlexDirectionRowReverse;
                    break;
                }
                default: {
                    Tools.warn(`无效 flexDirection : ${data}`);
                }
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static flexWrap(data) {
            let value;
            switch (data) {
                case ('nowrap'): {
                    value = enum_1.YGWrap.YGWrapNoWrap;
                    break;
                }
                case ('wrap'): {
                    value = enum_1.YGWrap.YGWrapWrap;
                    break;
                }
                case ('wrap-reverse'): {
                    value = enum_1.YGWrap.YGWrapWrapReverse;
                    break;
                }
                default: {
                    Tools.warn(`无效 flexWrap : ${data}`);
                }
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         * *
         */
        static flexGrow(data) {
            let value;
            switch (data) {
                case ('inherit'): {
                    value = 0;
                    break;
                }
                default: {
                    value = data - 0;
                }
            }
            isNaN(value) && (value = 0);
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static flexShrink(data) {
            let value;
            switch (data) {
                case ('initial'):
                case ('inherit'): {
                    value = 1;
                    break;
                }
                default: {
                    value = data - 0;
                }
            }
            isNaN(value) && (value = 0);
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static flexBasis(data) {
            const value = new FlexBasis();
            switch (data) {
                case ('auto'): {
                    value.auto = true;
                    break;
                }
                default: {
                    // value.value = Tools.lengthData(data)._d;
                    value.value = Tools.lengthData(data)[1];
                }
            }
            return value;
        }
        /**
         * 解析 border 数据
         * @param data border
         */
        static borderWidth(data) {
            data = this.format_space(data);
            return this.box(data, enum_1.YGEdge.YGEdgeAll);
            // // let _d: LengthData;
            // let _d: ILengthData;
            // if (data === undefined) {
            //     // _d = new LengthData(LengthUnitType.Pixel, 0);
            //     _d = [LengthUnitType.Pixel, 0];
            // } else {
            //     _d = Tools.lengthData(data);
            // }
            // return _d;
        }
        /**
         * 解析 border 数据
         * @param data border
         */
        static borderColor(data) {
            return Tools.backgroundColor(data);
        }
        /**
         * 解析 border 数据
         * @param data border
         */
        static borderRadius(data) {
            // return Tools.lengthData(data)._d;
            return Tools.lengthData(data)[1];
        }
        /**
         * 解析 margin 数据
         * @param data margin
         */
        static margin(data) {
            data = this.format_space(data);
            return Tools.box(data);
        }
        /**
         * 解析 margin 数据
         * @param data margin
         */
        static marginTop(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 margin 数据
         * @param data margin
         */
        static marginRight(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 margin 数据
         * @param data margin
         */
        static marginBottom(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 margin 数据
         * @param data margin
         */
        static marginLeft(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 padding 数据
         * @param data padding
         */
        static padding(data) {
            data = this.format_space(data);
            return Tools.box(data);
        }
        /**
         * 解析 padding 数据
         * @param data padding
         */
        static paddingTop(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 padding 数据
         * @param data padding
         */
        static paddingRight(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 padding 数据
         * @param data padding
         */
        static paddingBottom(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 padding 数据
         * @param data padding
         */
        static paddingLeft(data) {
            return Tools.boxOneSide(data);
        }
        /**
         * 解析 Position 样式
         * @param data Position 样式
         */
        static position(data) {
            let _d;
            switch (data) {
                case (`absolute`): {
                    _d = enum_1.YGPositionType.YGPositionTypeAbsolute;
                    break;
                }
                case (`relative`): {
                    _d = enum_1.YGPositionType.YGPositionTypeRelative;
                    break;
                }
                default: {
                    Tools.warn(`无效 position : ${data}`);
                }
            }
            return _d;
        }
        /**
         *
         * @param data html 样式数据
         */
        static left(data) {
            return Tools.lengthData(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        static top(data) {
            return Tools.lengthData(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        static right(data) {
            return Tools.lengthData(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        static bottom(data) {
            return Tools.lengthData(data);
        }
        /**
         *
         * @param data html 样式数据
         * * translate(<percent>|<pixel>,<percent>|<pixel>) rotate(<deg>) scale(<decimal>,<decimal>)
         */
        // public static transform(data: string) {
        //     const result: Transform = new Transform();
        //     const datas = data.split(') ');
        //     datas.forEach(str => {
        //         switch (str[0]) {
        //             case ('m'): {
        //                 this._matrix(str, result);
        //                 break;
        //             }
        //             case ('t'): {
        //                 this._translate(str, result);
        //                 break;
        //             }
        //             case ('s'): {
        //                 this._scale(str, result);
        //                 break;
        //             }
        //             case ('r'): {
        //                 this._rotate(str, result);
        //                 break;
        //             }
        //             default:
        //         }
        //     });
        //     return result;
        // }
        static transform(data) {
            data = this.format_space(data);
            const result = [];
            const datas = data.split(') ');
            datas.forEach((str) => {
                switch (str[0]) {
                    case ('m'): {
                        this._matrix(str, result);
                        break;
                    }
                    case ('t'): {
                        this._translate(str, result);
                        break;
                    }
                    case ('s'): {
                        this._scale(str, result);
                        break;
                    }
                    case ('r'): {
                        this._rotate(str, result);
                        break;
                    }
                    default: {
                        Tools.warn(`无效 transform : ${data}`);
                    }
                }
            });
            return result;
        }
        static readTransform(data) {
            const newData = {
                r: 0,
                t: [[0, 0], [0, 0]],
                s: [1, 1]
            };
            data.forEach((v) => {
                newData[v.t] = v.d;
            });
            return newData;
        }
        static copyEnumTransformData(data) {
            const newData = {
                r: 0,
                t: [[0, 0], [0, 0]],
                s: [1, 1]
            };
            data.r !== undefined && (newData.r = data.r);
            data.s !== undefined && (newData.s = Vector2.cloneFromIVector2(data.s));
            data.t !== undefined && (newData.t = LengthVector2.cloneFromILengthVector2(data.t));
            return newData;
        }
        static copyLengthData(data) {
            return LengthData.cloneFromILengthData(data);
        }
        static mixEnumTransformData(comparePercent, last, next) {
            const newData = {
                r: 0,
                t: [[0, 0], [0, 0]],
                s: [1, 1]
            };
            if (last === undefined) {
                last = newData;
            }
            if (next === undefined) {
                next = newData;
            }
            newData.r = Tools.mixNumber(comparePercent, last.r, next.r);
            newData.s = Tools.mixIVector2(comparePercent, last.s, next.s);
            newData.t = Tools.mixILengthVector2(comparePercent, last.t, next.t);
            return newData;
        }
        static mixNumber(comparePercent, last, next) {
            return last + (next - last) * comparePercent;
        }
        static mixILengthData(comparePercent, last, next) {
            return LengthData.mixILengthData(comparePercent, last, next);
        }
        static mixIVector2(comparePercent, last, next) {
            return Vector2.mixIVector2(comparePercent, last, next);
        }
        static mixILengthVector2(comparePercent, last, next) {
            return LengthVector2.mixILengthVector2(comparePercent, last, next);
        }
        /**
         * 变换中心
         * @param data html
         * * <percent> | <pixel>
         */
        static transformOrigin(data) {
            data = this.format_space(data);
            // let x: LengthData, y: LengthData;
            // const value     = data.split(' ');
            // if (value[0] !== undefined) {
            //     x = this.lengthData(<any>value[0].trim());
            // }
            // if (value[1] !== undefined) {
            //     y = this.lengthData(<any>value[1].trim());
            // } else {
            //     y = this.lengthData(<any>value[0].trim());
            // }
            // return new LengthVector2(x, y);
            let x, y;
            const value = data.split(' ');
            if (value[0] !== undefined) {
                x = this.lengthData(value[0].trim());
            }
            if (value[1] !== undefined) {
                y = this.lengthData(value[1].trim());
            }
            else {
                y = this.lengthData(value[0].trim());
            }
            return [x, y];
        }
        static translate(data) {
            data = this.format_space(data);
            // let x: LengthData, y: LengthData;
            // const value     = data.split(',');
            // if (value[0] !== undefined) {
            //     x = this.translateX(<any>value[0].trim());
            // }
            // if (value[1] !== undefined) {
            //     y = this.translateY(<any>value[1].trim());
            // } else {
            //     y = this.translateY(<any>value[0].trim());
            // }
            // return new LengthVector2(x, y);
            let x, y;
            const value = data.split(',');
            if (value[0] !== undefined) {
                x = this.translateX(value[0].trim());
            }
            if (value[1] !== undefined) {
                y = this.translateY(value[1].trim());
            }
            else {
                y = this.translateY(value[0].trim());
            }
            return [x, y];
        }
        static translateX(data) {
            data = this.format_space(data);
            return this.ananly_translate(data);
        }
        static translateY(data) {
            data = this.format_space(data);
            return this.ananly_translate(data);
        }
        // public static scale(data: string) {
        //     let x: number = 0, y: number = 0;
        //     const value     = data.split(',');
        //     if (value[0] !== undefined) {
        //         x = (<any>value[0].trim()) - 0;
        //     }
        //     if (value[1] !== undefined) {
        //         y = (<any>value[0].trim()) - 0;
        //     } else {
        //         y = x;
        //     }
        //     return new Vector2(x, y);
        // }
        static scale(data) {
            data = this.format_space(data);
            let x = 0, y = 0;
            const value = data.split(',');
            if (value[0] !== undefined) {
                x = value[0].trim() - 0;
            }
            if (value[1] !== undefined) {
                y = value[0].trim() - 0;
            }
            else {
                y = x;
            }
            return [x, y];
        }
        static rotate(data) {
            data = this.format_space(data);
            return data.trim().replace('deg', '') - 0;
        }
        /**
         *
         * @param data html 样式数据
         */
        static whiteSpace(data) {
            data = this.format_space(data);
            let _d;
            switch (data) {
                case ('normal'): {
                    _d = enum_1.WhiteSpace.Normal;
                    break;
                }
                case ('nowrap'): {
                    _d = enum_1.WhiteSpace.Nowrap;
                    break;
                }
                case ('pre-wrap'): {
                    _d = enum_1.WhiteSpace.PreWrap;
                    break;
                }
                case ('pre'): {
                    _d = enum_1.WhiteSpace.Undefined;
                    Tools.warn(`white-space 不支持 'pre'.`);
                    break;
                }
                case ('pre-line'): {
                    _d = enum_1.WhiteSpace.PreLine;
                    break;
                }
                default: {
                    Tools.warn(`无效 WhiteSpace : ${data}`);
                    _d = enum_1.WhiteSpace.Undefined;
                }
            }
            return _d;
        }
        /**
         *
         * @param data html 样式数据
         */
        static wordSpacing(data) {
            // let value: number;
            // if (data !== undefined) {
            //     value = Tools.lengthData(data)._d;
            // }
            // return value;
            let value;
            if (data !== undefined) {
                value = Tools.lengthData(data)[1];
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        // public static letterSpacing(data: string): LengthData {
        //     return Tools.lengthData(data);
        // }
        static letterSpacing(data) {
            return Tools.lengthData(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        // public static lineHeight(data: string): LengthData {
        //     return Tools.lengthData(data);
        // }
        static lineHeight(data) {
            return Tools.lengthData(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        static fontFamily(data) {
            return data;
        }
        static fontSize(data) {
            // const _d: LengthData = Tools.lengthData(data);
            // let value: number;
            // if (_d !== undefined) {
            //     value = _d._d;
            // }
            // return value;
            const _d = Tools.lengthData(data);
            let value;
            if (_d !== undefined) {
                value = _d[1];
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static fontStyle(data) {
            let _d;
            switch (data) {
                case ('normal'): {
                    _d = enum_1.FontStyle.Normal;
                    break;
                }
                case ('italic'): {
                    _d = enum_1.FontStyle.Ttalic;
                    break;
                }
                case ('oblique'): {
                    _d = enum_1.FontStyle.Oblique;
                    break;
                }
                default: {
                    Tools.warn(`无效 fontStyle : ${data}`);
                    _d = enum_1.FontStyle.Undefined;
                }
            }
            return _d;
        }
        /**
         *
         * @param data html 样式数据
         * * iOS 环境 设置为数值时有问题 ()
         */
        static fontWeight(data) {
            let _d;
            switch (data) {
                case ('100'): {
                    _d = enum_1.FontWeight.One;
                    break;
                }
                case ('200'): {
                    _d = enum_1.FontWeight.Two;
                    break;
                }
                case ('300'): {
                    _d = enum_1.FontWeight.Three;
                    break;
                }
                case ('400'): {
                    _d = enum_1.FontWeight.Four;
                    break;
                }
                case ('500'): {
                    _d = enum_1.FontWeight.Five;
                    break;
                }
                case ('600'): {
                    _d = enum_1.FontWeight.Six;
                    break;
                }
                case ('700'): {
                    _d = enum_1.FontWeight.Seven;
                    break;
                }
                case ('800'): {
                    _d = enum_1.FontWeight.Eight;
                    break;
                }
                case ('900'): {
                    _d = enum_1.FontWeight.Nine;
                    break;
                }
                case ('Normal'): {
                    _d = enum_1.FontWeight.Normal;
                    break;
                }
                case ('Bold'): {
                    _d = enum_1.FontWeight.Bold;
                    break;
                }
                case ('Bolder'): {
                    _d = enum_1.FontWeight.Bolder;
                    break;
                }
                case ('Lighter'): {
                    _d = enum_1.FontWeight.Lighter;
                    break;
                }
                default: {
                    Tools.warn(`无效 FontWeight : ${data}`);
                    _d = enum_1.FontWeight.Undefined;
                }
            }
            return _d;
        }
        static fontVariant(data) {
            return 0;
        }
        /**
         *
         * @param data html 样式数据
         */
        static textContent(data) {
            return data;
        }
        /**
         *
         * @param data html 样式数据
         * * #fc0 1px 0 10px
         */
        static textShadow(data) {
            data = this.format_space(data);
            // const result: Shadow = new Shadow();
            // const values = data.split(' ');
            // if (values.length === 4) {
            //     result.color = this.backgroundColor(<any>values[0]);
            //     result.h    = this.lengthData(<any>values[1])._d;
            //     result.v    = this.lengthData(<any>values[2])._d;
            //     result.blur = this.lengthData(<any>values[3])._d;
            //     return result;
            // } else {
            //     Tools.warn(`Shadow template: color | offset-x | offset-y | blur-radius ; example: #fc0 1px 2px 10px`);
            //     return ;
            // }
            const result = [];
            const values = data.split(' ');
            if (values.length === 4) {
                result[2] = this.backgroundColor(values[0]);
                result[0] = this.lengthData(values[1])[1];
                result[1] = this.lengthData(values[2])[1];
                result[3] = this.lengthData(values[3])[1];
                return result;
            }
            else {
                Tools.warn(`Shadow 错误: color | offset-x | offset-y | blur-radius ; example: #fc0 1px 2px 10px`);
                return;
            }
        }
        static boxShadow(data) {
            data = this.format_space(data);
            const result = [];
            const values = data.split(' ');
            if (values.length === 5) {
                result[2] = this.backgroundColor(values[0]);
                result[0] = this.lengthData(values[1])[1];
                result[1] = this.lengthData(values[2])[1];
                result[3] = this.lengthData(values[3])[1];
                result[4] = this.lengthData(values[4])[1];
                return result;
            }
            else if (values.length === 4) {
                result[2] = this.backgroundColor(values[0]);
                result[0] = this.lengthData(values[1])[1];
                result[1] = this.lengthData(values[2])[1];
                result[3] = this.lengthData(values[3])[1];
                result[4] = 0;
                return result;
            }
            else {
                Tools.warn(`Shadow 错误: color | offset-x | offset-y | blur-radius ; example: #fc0 1px 2px 10px | #fc0 1px 2px 10px 0px`);
                return;
            }
            return this.textShadow(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        static textAlign(data) {
            let _d;
            switch (data) {
                case ('left'): {
                    _d = enum_1.TextAlign.Left;
                    break;
                }
                case ('right'): {
                    _d = enum_1.TextAlign.Right;
                    break;
                }
                case ('center'): {
                    _d = enum_1.TextAlign.Center;
                    break;
                }
                case ('justify'): {
                    _d = enum_1.TextAlign.Justify;
                    break;
                }
                default: {
                    _d = enum_1.TextAlign.Undefined;
                }
            }
            return _d;
        }
        /**
         *
         * @param data html 样式数据
         */
        static textDecoration(data) {
            let _d;
            switch (data) {
                case ('left'): {
                    _d = enum_1.TextDirection.Left;
                    break;
                }
                case ('right'): {
                    _d = enum_1.TextDirection.Right;
                    break;
                }
                case ('top'): {
                    _d = enum_1.TextDirection.Top;
                    break;
                }
                case ('bottom'): {
                    _d = enum_1.TextDirection.Bootom;
                    break;
                }
                default: {
                    Tools.warn(`无效 textDecoration : ${data}`);
                    _d = enum_1.TextDirection.Undefined;
                }
            }
            return _d;
        }
        /**
         *
         * @param data html 样式数据
         */
        static textIndent(data) {
            // let _d: number;
            // _d = this.lengthData(data)._d;
            // return _d;
            let _d;
            _d = this.lengthData(data)[1];
            return _d;
        }
        static textStroke(data) {
            data = this.format_space(data);
            let res;
            const cmdList = data.split(' ');
            if (cmdList.length === 2) {
                const lenData = this.lengthData(cmdList[0]);
                const rgba = this.backgroundColor(cmdList[1]);
                res = [lenData[1], rgba[0], rgba[1], rgba[2], rgba[3]];
            }
            return res;
        }
        static textGradient(data) {
            return this.background(data);
        }
        static textGradient_(data) {
            return this.background_(data);
        }
        /**
         *
         * @param data html 样式数据
         */
        static textTransform(data) {
            let _d;
            switch (data) {
                case ('left'): {
                    _d = 1;
                    break;
                }
                default: {
                    _d = 0;
                }
            }
            return _d;
        }
        static textOverflow(data) {
            return 0;
        }
        static unicodeBidi(data) {
            return 0;
        }
        /**
         *
         * @param data html 样式数据
         */
        static verticalAlign(data) {
            let _d;
            switch (data) {
                case ('bottom'): {
                    _d = enum_1.VerticalAlign.Bootom;
                    break;
                }
                case ('center'): {
                    _d = enum_1.VerticalAlign.Center;
                    break;
                }
                case ('top'): {
                    _d = enum_1.VerticalAlign.Top;
                    break;
                }
                default: {
                    _d = enum_1.VerticalAlign.Undefined;
                }
            }
            return _d;
        }
        /**
         *
         * @param data html 样式数据
         */
        static alignSelf(data) {
            let value;
            switch (data) {
                case 'space-between': {
                    value = enum_1.YGAlign.YGAlignSpaceBetween;
                    break;
                }
                case 'space-around': {
                    value = enum_1.YGAlign.YGAlignSpaceAround;
                    break;
                }
                case 'center': {
                    value = enum_1.YGAlign.YGAlignCenter;
                    break;
                }
                case 'flex-end': {
                    value = enum_1.YGAlign.YGAlignFlexEnd;
                    break;
                }
                case 'flex-start': {
                    value = enum_1.YGAlign.YGAlignFlexStart;
                    break;
                }
                case 'stretch': {
                    value = enum_1.YGAlign.YGAlignStretch;
                    break;
                }
                case 'baseline': {
                    value = enum_1.YGAlign.YGAlignBaseline;
                    break;
                }
                default: {
                    Tools.warn(`无效 alignSelf : ${data}`);
                }
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static justifyContent(data) {
            let value;
            switch (data) {
                case 'center': {
                    value = enum_1.YGJustify.YGJustifyCenter;
                    break;
                }
                case 'flex-end': {
                    value = enum_1.YGJustify.YGJustifyFlexEnd;
                    break;
                }
                case 'flex-start': {
                    value = enum_1.YGJustify.YGJustifyFlexStart;
                    break;
                }
                case 'space-evenly': {
                    value = enum_1.YGJustify.YGJustifySpaceEvenly;
                    break;
                }
                case 'space-between': {
                    value = enum_1.YGJustify.YGJustifySpaceBetween;
                    break;
                }
                case 'space-around': {
                    value = enum_1.YGJustify.YGJustifySpaceAround;
                    break;
                }
                default: {
                    Tools.warn(`无效 justifyContent : ${data}`);
                    value = enum_1.YGJustify.YGJustifyFlexStart;
                }
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static alignContent(data) {
            let value;
            switch (data) {
                case 'space-between': {
                    value = enum_1.YGAlign.YGAlignSpaceBetween;
                    break;
                }
                case 'space-around': {
                    value = enum_1.YGAlign.YGAlignSpaceAround;
                    break;
                }
                case 'center': {
                    value = enum_1.YGAlign.YGAlignCenter;
                    break;
                }
                case 'flex-end': {
                    value = enum_1.YGAlign.YGAlignFlexEnd;
                    break;
                }
                case 'flex-start': {
                    value = enum_1.YGAlign.YGAlignFlexStart;
                    break;
                }
                case 'stretch': {
                    value = enum_1.YGAlign.YGAlignStretch;
                    break;
                }
                case 'baseline': {
                    value = enum_1.YGAlign.YGAlignBaseline;
                    break;
                }
                default: {
                    Tools.warn(`无效 alignContent : ${data}`);
                }
            }
            return value;
        }
        /**
         *
         * @param data html 样式数据
         */
        static alignItems(data) {
            let value;
            switch (data) {
                // case 'auto': {
                //     value = YGAlign.YGAlignAuto;
                //     break;
                // }
                case 'baseline': {
                    value = enum_1.YGAlign.YGAlignBaseline;
                    break;
                }
                case 'center': {
                    value = enum_1.YGAlign.YGAlignCenter;
                    break;
                }
                case 'flex-end': {
                    value = enum_1.YGAlign.YGAlignFlexEnd;
                    break;
                }
                case 'flex-start': {
                    value = enum_1.YGAlign.YGAlignFlexStart;
                    break;
                }
                case 'stretch': {
                    value = enum_1.YGAlign.YGAlignStretch;
                    break;
                }
                default: {
                    Tools.warn(`无效 alignItems : ${data}`);
                    value = enum_1.YGAlign.YGAlignAuto;
                }
            }
            return value;
        }
        static overflow(data) {
            // const list = data.split(' ');
            // const overFlow = new OverFlow();
            // if (list.length === 1) {
            //    overFlow.x = list[0] === 'hidden' ? YGOverflow.YGOverflowHidden : YGOverflow.YGOverflowVisible;
            //     overFlow.y = overFlow.x;
            // } else {
            //     overFlow.x = list[0] === 'hidden' ? YGOverflow.YGOverflowHidden : YGOverflow.YGOverflowVisible;
            //     overFlow.y = list[1] === 'hidden' ? YGOverflow.YGOverflowHidden : YGOverflow.YGOverflowVisible;
            // }
            // return overFlow;
            // hidden  是 表示要裁剪，即为 true
            return data === 'hidden' ? true : false;
        }
        static oveflowWrap(data) {
            let value;
            switch (data) {
                case ('normal'): {
                    value = 1;
                    break;
                }
                case ('word-break'): {
                    value = 2;
                    break;
                }
                default:
                    value = 0;
            }
            return value;
        }
        static overflowX(data) {
            return data === 'hidden' ? enum_1.YGOverflow.YGOverflowHidden : enum_1.YGOverflow.YGOverflowVisible;
        }
        static overflowY(data) {
            return data === 'hidden' ? enum_1.YGOverflow.YGOverflowHidden : enum_1.YGOverflow.YGOverflowVisible;
        }
        static scroll(data) {
            const list = data.split(' ');
            const scrollInfo = new ScrollInfo();
            switch (list[0]) {
                case ('x'): {
                    scrollInfo.path = ScrollPaths.x;
                    break;
                }
                case ('y'): {
                    scrollInfo.path = ScrollPaths.y;
                    break;
                }
                case ('xy'): {
                    scrollInfo.path = ScrollPaths.xy;
                    break;
                }
                default:
            }
            switch (list[1]) {
                case ('none'): {
                    scrollInfo.style = ScrollTypes.none;
                    break;
                }
                default:
                    scrollInfo.style = ScrollTypes.none;
            }
            return scrollInfo;
        }
        static direction(data) {
            return data;
        }
        static outlineColor(data) {
            return this.backgroundColor(data);
        }
        static outlineWidth(data) {
            return Tools.lengthData(data);
        }
        static outlineOffset(data) {
            return Tools.lengthData(data);
        }
        static outlineStyle(data) {
            return 0;
        }
        static pointerEvents(data) {
            if (Tools.noValue(data)) {
                return enum_1.EnabledTypes.auto;
            }
            else {
                return (this.format_space(data) === 'none') ? enum_1.EnabledTypes.none : enum_1.EnabledTypes.visible;
            }
        }
        static objectFit(data) {
            data = this.format_space(data);
            switch (data) {
                case ('fill'): {
                    return enum_1.FitTypes.None;
                }
                case ('contain'): {
                    return enum_1.FitTypes.Contain;
                }
                case ('cover'): {
                    return enum_1.FitTypes.Cover;
                }
                case ('scale-down'): {
                    return enum_1.FitTypes.ScaleDown;
                }
                case ('none'):
                default: {
                    return enum_1.FitTypes.None;
                }
            }
        }
        static animation(data) {
            data = this.format_space(data);
            const cmdList = data.split(',');
            const result = [];
            cmdList.forEach((cmd) => {
                const res = this.analyAnimationCmd(cmd.trim());
                if (res) {
                    result.push(this.analyAnimationCmd(cmd.trim()));
                }
            });
            return result;
        }
        static borderImage(data) {
            data = this.format_space(data);
            let url, left, top, bottom, right, mode = enum_1.BorderImageRepeat.Space;
            const slices = [];
            let tempCmd;
            const cmdList = data.split(' ');
            const len = cmdList.length;
            for (let i = 0; i < len; i++) {
                tempCmd = cmdList[i];
                const temp = tempCmd - 0;
                if (!isNaN(temp)) {
                    slices.push(temp / 100);
                }
                else if (i === 0) {
                    url = tempCmd.replace('url(', '').replace(')', '');
                }
                else {
                    mode = this._repeatAnaly(tempCmd);
                }
            }
            top = slices[0];
            right = this.noValue(slices[1]) ? top : slices[1];
            bottom = this.noValue(slices[2]) ? top : slices[2];
            left = this.noValue(slices[3]) ? right : slices[3];
            return [url, top, right, bottom, left, mode];
        }
        static borderImageClip(data) {
            return this._clipAnaly(data);
        }
        static borderImageSource(data) {
            return data.replace('url(', '').replace(')', '');
        }
        static borderImageSlice(data) {
            return this._sliceAnaly(data);
        }
        static borderImageRepeat(data) {
            data = this.format_space(data);
            const cmdList = data.split(' ');
            const h = this._repeatAnaly(cmdList[0]);
            const v = cmdList[1] === undefined ? h : this._repeatAnaly(cmdList[1]);
            return [h, v];
        }
        static _repeatAnaly(data) {
            let mode;
            switch (data) {
                case 'stretch': {
                    mode = enum_1.BorderImageRepeat.Stretch;
                    break;
                }
                case 'round': {
                    mode = enum_1.BorderImageRepeat.Round;
                    break;
                }
                case 'repeat': {
                    mode = enum_1.BorderImageRepeat.Repeat;
                    break;
                }
                default: {
                    Tools.warn(`无效 BorderImageRepeat : ${data}`);
                    mode = enum_1.BorderImageRepeat.Space;
                }
            }
            return mode;
        }
        static imageClip(data) {
            return this._clipAnaly(data);
        }
        static _clipAnaly(data) {
            data = this.format_space(data);
            let left, top, bottom, right;
            const slices = [];
            const slicesType = [];
            let tempCmd;
            const cmdList = data.split(' ');
            const len = cmdList.length;
            for (let i = 0; i < len; i++) {
                tempCmd = cmdList[i];
                const temp = this.lengthData(tempCmd);
                if (temp[0] === 0) {
                    slicesType[i] = temp[0];
                    slices[i] = temp[1];
                }
                else if (temp[0] === 1) {
                    slicesType[i] = temp[0];
                    slices[i] = temp[1] / 100;
                }
                else {
                    slicesType[i] = temp[0];
                    slices[i] = 0;
                }
            }
            top = slices[0] ? slices[0] : 0;
            right = this.noValue(slices[1]) ? top : slices[1];
            bottom = this.noValue(slices[2]) ? top : slices[2];
            left = this.noValue(slices[3]) ? right : slices[3];
            return [top, right, bottom, left, slicesType[0]];
        }
        static _sliceAnaly(data) {
            data = this.format_space(data);
            let left, top, bottom, right, mode = 0;
            const slices = [];
            const slicesType = [];
            let tempCmd;
            const cmdList = data.split(' ');
            const len = cmdList.length;
            for (let i = 0; i < len; i++) {
                tempCmd = cmdList[i];
                const temp = this.lengthData(tempCmd);
                if (temp[0] === 0) {
                    slicesType.push(temp[0]);
                    slices.push(temp[1]);
                }
                else if (temp[0] === 1) {
                    slicesType.push(temp[0]);
                    slices.push(temp[1] / 100);
                }
                else {
                    mode = 0;
                }
                mode = tempCmd === 'fill' ? 1 : 0;
            }
            top = slices[0];
            right = this.noValue(slices[1]) ? top : slices[1];
            bottom = this.noValue(slices[2]) ? top : slices[2];
            left = this.noValue(slices[3]) ? right : slices[3];
            return [top, right, bottom, left, mode, slicesType[0]];
        }
        /**
         *
         * @param data html css
         */
        static cellId(data) {
            return data - 0;
        }
        static noValue(value) {
            return value === undefined || value === null;
        }
        static analy(key, data) {
            if (Tools[AnalyMap[key]]) {
                return Tools[AnalyMap[key]](data);
            }
            else {
                Tools.error(`无法解析：${key}`);
            }
        }
        /**
         *
         * @param data html 样式数据
         */
        static boxOneSide(data) {
            return Tools.lengthData(data);
        }
        /**
         * 解析 盒子模型相关 数据
         * @param data html 样式数据
         */
        static box(data, cType = enum_1.YGEdge.YGEdgeAll) {
            // const result: BoxData = new BoxData();
            // let list = data.split(' ');
            // if (cType === YGEdge.YGEdgeAll) {
            //     if (list.length === 1) {
            //         result.all = Tools.lengthData(list[0]);
            //     } else {
            //         if (list[0]) {
            //             result.top = Tools.lengthData(list[0]);
            //         }
            //         if (list[1]) {
            //             result.right = Tools.lengthData(list[1]);
            //         }
            //         if (list[2]) {
            //             result.bottom = Tools.lengthData(list[2]);
            //         } else {
            //             result.bottom = result.top.clone();
            //         }
            //         if (list[3]) {
            //             result.left = Tools.lengthData(list[3]);
            //         } else {
            //             result.left = result.right.clone();
            //         }
            //         list = undefined;
            //     }
            // }
            // return result;
            const result = [undefined, undefined, undefined, undefined, undefined];
            let list = data.split(' ');
            if (cType === enum_1.YGEdge.YGEdgeAll) {
                if (list.length === 1) {
                    result[exports.BoxA] = Tools.lengthData(list[0]);
                }
                else {
                    if (list[0]) {
                        result[exports.BoxT] = Tools.lengthData(list[0]);
                    }
                    if (list[1]) {
                        result[exports.BoxR] = Tools.lengthData(list[1]);
                    }
                    if (list[2]) {
                        result[exports.BoxB] = Tools.lengthData(list[2]);
                    }
                    else {
                        result[exports.BoxB] = Tools.lengthData(list[0]);
                    }
                    if (list[3]) {
                        result[exports.BoxL] = Tools.lengthData(list[3]);
                    }
                    else {
                        result[exports.BoxL] = Tools.lengthData(list[1]);
                    }
                    list = undefined;
                }
            }
            return result;
        }
        /**
         *
         * @param data html 样式数据
         * @param result 解析结果
         */
        // private static _translate(data: string, result: Transform) {
        // let x: LengthData, y: LengthData;
        // const keys      = data.split('(');
        // const value     = keys[1].split(')')[0].split(',');
        // switch (keys[0]) {
        //     case ('translate'): {
        //         if (value[0] !== undefined) {
        //             x = this.translateX(value[0].trim());
        //         }
        //         if (value[1] !== undefined) {
        //             y = this.translateY(value[1].trim());
        //         } else {
        //             y = this.translateY(value[0].trim());
        //         }
        //         if (x !== undefined && y !== undefined) {
        //             result.translate = new LengthVector2(x, y);
        //         }
        //         break;
        //     }
        //     // case ('translate3d'): {
        //     //     this.translate3d = value;
        //     //     break;
        //     // }
        //     // case ('translateX'): {
        //     //     this.translateX = value;
        //     //     break;
        //     // }
        //     // case ('translateY'): {
        //     //     this.translateY = value;
        //     //     break;
        //     // }
        //     // case ('translateZ'): {
        //     //     this.translateZ = value;
        //     //     break;
        //     // }
        //     default:
        //         result.translate = LengthVector2.Zero();
        // }
        // }
        static _translate(data, result) {
            data = this.format_space(data);
            let x = [0, 0], y = [0, 0];
            const keys = data.split('(');
            const value = keys[1].split(')')[0].split(',');
            switch (keys[0]) {
                case ('translate'): {
                    if (value[0] !== undefined) {
                        x = this.translateX(value[0].trim());
                    }
                    if (value[1] !== undefined) {
                        y = this.translateY(value[1].trim());
                    }
                    else {
                        y = this.translateY(value[0].trim());
                    }
                    if (x !== undefined && y !== undefined) {
                        result.push({ t: ITransformDataType.translate, d: [x, y] });
                    }
                    break;
                }
                // case ('translate3d'): {
                //     this.translate3d = value;
                //     break;
                // }
                case ('translateX'): {
                    x = this.translateX(value[0].trim());
                    result.push({ t: ITransformDataType.translate, d: [x, y] });
                    break;
                }
                case ('translateY'): {
                    y = this.translateX(value[0].trim());
                    result.push({ t: ITransformDataType.translate, d: [x, y] });
                    break;
                }
                // case ('translateZ'): {
                //     this.translateZ = value;
                //     break;
                // }
                default:
                    result.push({ t: ITransformDataType.translate, d: [x, y] });
            }
        }
        static ananly_translate(data) {
            // let value: LengthData;
            // value = this.lengthData(<any>data.trim());
            // return value;
            let value;
            value = this.lengthData(data.trim());
            return value;
        }
        /**
         *
         * @param data html 样式数据
         * @param result 解析结果
         */
        // private static _rotate(data: string, result: Transform) {
        //     const keys      = data.split('(');
        //     const value     = keys[1].split(')')[0];
        //     switch (keys[0]) {
        //         case ('rotate'): {
        //             result.rotate = (<any>value.trim().replace('deg', '')) - 0;
        //             break;
        //         }
        //         // case ('rotate3d'): {
        //         //     this.rotate3d = value;
        //         //     break;
        //         // }
        //         // case ('rotateX'): {
        //         //     this.rotateX = value;
        //         //     break;
        //         // }
        //         // case ('rotateY'): {
        //         //     this.rotateY = value;
        //         //     break;
        //         // }
        //         // case ('rotateZ'): {
        //         //     this.rotateZ = value;
        //         //     break;
        //         // }
        //         default:
        //             result.rotate = 0;
        //     }
        // }
        static _rotate(data, result) {
            data = this.format_space(data);
            const keys = data.split('(');
            const value = keys[1].split(')')[0];
            const rotate = value.trim().replace('deg', '') - 0;
            switch (keys[0]) {
                case ('rotate'): {
                    // result[ITransR] = (<any>value.trim().replace('deg', '')) - 0;
                    result.push({ t: ITransformDataType.rotateZ, d: rotate });
                    break;
                }
                // case ('rotate3d'): {
                //     this.rotate3d = value;
                //     break;
                // }
                // case ('rotateX'): {
                //     this.rotateX = value;
                //     break;
                // }
                // case ('rotateY'): {
                //     this.rotateY = value;
                //     break;
                // }
                case ('rotateZ'): {
                    result.push({ t: ITransformDataType.rotateZ, d: rotate });
                    break;
                }
                default:
                    result.push({ t: ITransformDataType.rotateZ, d: 0 });
            }
        }
        /**
         *
         * @param data html 样式数据
         * @param result 解析结果
         */
        // private static _scale(data: string, result: Transform) {
        //     let x: number = 0, y: number = 0;
        //     const keys      = data.split('(');
        //     const value     = keys[1].split(')')[0].split(',');
        //     switch (keys[0]) {
        //         case ('scale'): {
        //             if (value[0] !== undefined) {
        //                 x = (<any>value[0]).trim() - 0;
        //             }
        //             if (value[1] !== undefined) {
        //                 y = (<any>value[1]).trim() - 0;
        //             } else {
        //                 y = x;
        //             }
        //             if (x !== undefined && y !== undefined) {
        //                 result.scale = new Vector2(x, y);
        //             }
        //             break;
        //         }
        //         // case ('scale3d'): {
        //         //     this.scale3d = value;
        //         //     break;
        //         // }
        //         // case ('scaleX'): {
        //         //     this.scaleX = value;
        //         //     break;
        //         // }
        //         // case ('scaleY'): {
        //         //     this.scaleY = value;
        //         //     break;
        //         // }
        //         // case ('scaleZ'): {
        //         //     this.scaleZ = value;
        //         //     break;
        //         // }
        //         default:
        //             result.scale = new Vector2(x, y);
        //     }
        // }
        static _scale(data, result) {
            let x = 1, y = 1;
            const keys = data.split('(');
            const value = keys[1].split(')')[0].split(',');
            switch (keys[0]) {
                case ('scale'): {
                    if (value[0] !== undefined) {
                        x = value[0].trim() - 0;
                    }
                    if (value[1] !== undefined) {
                        y = value[1].trim() - 0;
                    }
                    else {
                        y = x;
                    }
                    if (x !== undefined && y !== undefined) {
                        // result[ITransS] = [x, y];
                        result.push({ t: ITransformDataType.scale, d: [x, y] });
                    }
                    break;
                }
                // case ('scale3d'): {
                //     this.scale3d = value;
                //     break;
                // }
                case ('scaleX'): {
                    x = value[0].trim() - 0;
                    result.push({ t: ITransformDataType.scale, d: [x, y] });
                    break;
                }
                case ('scaleY'): {
                    y = value[0].trim() - 0;
                    result.push({ t: ITransformDataType.scale, d: [x, y] });
                    break;
                }
                // case ('scaleZ'): {
                //     this.scaleZ = value;
                //     break;
                // }
                default:
                    result.push({ t: ITransformDataType.scale, d: [1, 1] });
            }
        }
        /**
         *
         * @param data html 样式数据
         * @param result 解析结果
         */
        // private static _matrix(data: string, result: Transform) {
        //     const keys      = data.split('(');
        //     const value     = keys[1].split(')')[0];
        //     switch (keys[0]) {
        //         case ('matrix'): {
        //             result.matrix = value.trim();
        //             break;
        //         }
        //         // case ('matrix3d'): {
        //         //     result.matrix3d = value;
        //         //     break;
        //         // }
        //         default:
        //     }
        // }
        static _matrix(data, result) {
            const keys = data.split('(');
            const value = keys[1].split(')')[0];
            switch (keys[0]) {
                case ('matrix'): {
                    // result.push(value.trim());
                    break;
                }
                // case ('matrix3d'): {
                //     result.matrix3d = value;
                //     break;
                // }
                default:
            }
        }
        static alignEnum(data) {
            let value;
            switch (data) {
                case 'space-between': {
                    value = enum_1.YGAlign.YGAlignSpaceBetween;
                    break;
                }
                case 'space-around': {
                    value = enum_1.YGAlign.YGAlignSpaceAround;
                    break;
                }
                case 'center': {
                    value = enum_1.YGAlign.YGAlignCenter;
                    break;
                }
                case 'flex-end': {
                    value = enum_1.YGAlign.YGAlignFlexEnd;
                    break;
                }
                case 'flex-start': {
                    value = enum_1.YGAlign.YGAlignFlexStart;
                    break;
                }
                case 'stretch': {
                    value = enum_1.YGAlign.YGAlignStretch;
                    break;
                }
                case 'baseline': {
                    value = enum_1.YGAlign.YGAlignBaseline;
                    break;
                }
                default:
            }
            return value;
        }
        /**
         *
         * @param data html css
         * @example background: linear-gradient(30deg, #eee000, #cf0800 10%, #600000 50%, #996990);
         * * 最多四个颜色
         */
        static lineGradient(data) {
            let gradientData;
            //
            const param = data.match(/\(([^)]*)\)/)[1];
            if (param) {
                const list = param.split(',');
                gradientData = new GradientData();
                gradientData._t = GradientTypes.linear;
                gradientData.direction = this.computeAngle(list[0].trim());
                gradientData.color_and_positions = this.analyColorAndPos(list);
            }
            return gradientData;
        }
        /**
         *
         * @param data html css
         * @example background: radial-gradient(circle at 50% 50%, #eee000, #cf0800 10%, #600000 50%, #996990);。
         * * 最多四个颜色
         */
        static radioGradient(data) {
            let gradientData;
            //
            const param = data.match(/\(([^)]*)\)/)[1];
            if (param) {
                const list = param.split(',');
                gradientData = new GradientData();
                gradientData._t = GradientTypes.radial;
                gradientData.color_and_positions = this.analyColorAndPos(list);
                this.analyCircle(list[0], gradientData);
            }
            return gradientData;
        }
        /**
         *
         * @param data deg
         * @example 10deg
         * * 设置值无效时默认为 0
         * * WEBGL 0 度 为 x 正方向
         * * DOM 0 度 为 y 正方向
         */
        static computeAngle(data) {
            let value = 0;
            const len = data.length;
            if (data[len - 3] === 'd'
                && data[len - 2] === 'e'
                && data[len - 1] === 'g') {
                data = data.substr(0, len - 3);
                value = data - 0;
                isNaN(value) && (value = 0);
            }
            return value - 90;
        }
        static computeRadian(data) {
            //
        }
        // private static analyColorAndPos(list: [string, string, string, string, string]) {
        //     const valueMaxCount: number = 4;
        //     const valueSize: number = 5;
        //     const valueList: number[] = [];
        //     for (let i = 0; i < valueMaxCount; i++) {
        //         if (list[i + 1] !== undefined) {
        //             const c_p       = list[i + 1].trim().split(' ');
        //             const rgba      = this.backgroundColor(c_p[0]);
        //             const offset    = i * valueSize;
        //             let lenData: LengthData;
        //             let lenValue: number;
        //             valueList[offset + 0] = rgba.r;
        //             valueList[offset + 1] = rgba.g;
        //             valueList[offset + 2] = rgba.b;
        //             valueList[offset + 3] = rgba.a;
        //             if (c_p[1] === undefined) {
        //                 lenValue = null;
        //             } else {
        //                 lenData = this.lengthData(c_p[1]);
        //                 if (lenData._t === LengthUnitType.Percent) {
        //                     lenValue = lenData._d / 100;
        //                 } else {
        //                     lenValue = null;
        //                 }
        //             }
        //             // 未设置点位时
        //             if (lenValue === null) {
        //                 valueList[offset + 4] = i === 0 ? 0 : 1;
        //                 // 为未设置值，且判定为末尾时，不再解析后续
        //                 if (i !== 0) {
        //                     break;
        //                 }
        //             } else {
        //                 valueList[offset + 4] = lenValue;
        //             }
        //         } else {
        //             break;
        //         }
        //     }
        //     if (valueList) {
        //         const typeList: Float32Array = new Float32Array(valueList.length);
        //         for (let i = valueList.length - 1; i >= 0; i--) {
        //             typeList[i] = valueList[i];
        //         }
        //         return typeList;
        //     }
        //     return ;
        // }
        static analyColorAndPos(list) {
            const valueMaxCount = 4;
            const valueSize = 5;
            const valueList = [];
            for (let i = 0; i < valueMaxCount; i++) {
                if (list[i + 1] !== undefined) {
                    const c_p = list[i + 1].trim().split(' ');
                    const rgba = this.backgroundColor(c_p[0]);
                    const offset = i * valueSize;
                    let lenData;
                    let lenValue;
                    valueList[offset + 0] = rgba[0];
                    valueList[offset + 1] = rgba[1];
                    valueList[offset + 2] = rgba[2];
                    valueList[offset + 3] = rgba[3];
                    if (c_p[1] === undefined) {
                        lenValue = null;
                    }
                    else {
                        lenData = this.lengthData(c_p[1]);
                        if (lenData[0] === enum_1.LengthUnitType.Percent) {
                            lenValue = lenData[1] / 100;
                        }
                        else {
                            lenValue = null;
                        }
                    }
                    // 未设置点位时
                    if (lenValue === null) {
                        valueList[offset + 4] = i === 0 ? 0 : 1;
                        // 为未设置值，且判定为末尾时，不再解析后续
                        if (i !== 0) {
                            break;
                        }
                    }
                    else {
                        valueList[offset + 4] = lenValue;
                    }
                }
                else {
                    break;
                }
            }
            if (valueList) {
                const typeList = new Float32Array(valueList.length);
                for (let i = valueList.length - 1; i >= 0; i--) {
                    typeList[i] = valueList[i];
                }
                return typeList;
            }
            return;
        }
        /**
         *
         * @param data css
         * @example circle at 50% 50%
         * * 设置值无效时默认节点中心 [0.5,0.5]
         */
        // private static analyCircle(data: string, gradientData: GradientData) {
        //     const list: [string, string, string, string, string] = <any>data.split(' ');
        //     const atIndex: number = list.indexOf('at');
        //     if (list[atIndex + 1] !== undefined && list[atIndex + 2] !== undefined) {
        //         gradientData.center_x = this.lengthData(list[atIndex + 1])._d / 100;
        //         gradientData.center_y = this.lengthData(list[atIndex + 2])._d / 100;
        //     } else {
        //         gradientData.center_x = 0.5;
        //         gradientData.center_y = 0.5;
        //     }
        //     gradientData.shape = this.analyRadialGradientShape(list[0]);
        //     gradientData.size = this.analyRadialGradientSize(list[atIndex - 1]);
        // }
        static analyCircle(data, gradientData) {
            const list = data.split(' ');
            const atIndex = list.indexOf('at');
            if (list[atIndex + 1] !== undefined && list[atIndex + 2] !== undefined) {
                gradientData.center_x = this.lengthData(list[atIndex + 1])[1] / 100;
                gradientData.center_y = this.lengthData(list[atIndex + 2])[1] / 100;
            }
            else {
                gradientData.center_x = 0.5;
                gradientData.center_y = 0.5;
            }
            gradientData.shape = this.analyRadialGradientShape(list[0]);
            gradientData.size = this.analyRadialGradientSize(list[atIndex - 1]);
        }
        static analyRadialGradientShape(data) {
            let value;
            switch (data) {
                case ('circle'): {
                    value = enum_1.RadialGradientShapes.circle;
                    break;
                }
                case ('ellipse'):
                default:
                    value = enum_1.RadialGradientShapes.ellipse;
            }
            return value;
        }
        static analyRadialGradientSize(data) {
            let value;
            switch (data) {
                case ('closest-side'): {
                    value = enum_1.RadialGradientSize.ClosestSide;
                    break;
                }
                case ('closest-corner'): {
                    value = enum_1.RadialGradientSize.ClosestCorner;
                    break;
                }
                case ('farthest-side'): {
                    value = enum_1.RadialGradientSize.FarthestSide;
                    break;
                }
                case ('farthest-corner'):
                default:
                    value = enum_1.RadialGradientSize.Farthestcorner;
            }
            return value;
        }
        static analyAnimationCmd(value) {
            const keylist = value.split(' ');
            const animationCmd = new AnimationCmd(keylist[0]);
            if (keylist.length !== 7) {
                Tools.error('AnimationCmd Error, 动画样式解析错误！缺少参数');
                return;
            }
            if (keylist[1].indexOf('ms') > 0) {
                animationCmd.duration = keylist[1].replace('ms', '') - 0;
            }
            else {
                animationCmd.duration = (keylist[1].replace('s', '') - 0) * 1000;
            }
            animationCmd.timingFunction = keylist[2];
            if (keylist[3].indexOf('ms') > 0) {
                animationCmd.delayTime = keylist[3].replace('ms', '') - 0;
            }
            else {
                animationCmd.delayTime = (keylist[3].replace('s', '') - 0) * 1000;
            }
            animationCmd.iteration = keylist[4] - 0;
            animationCmd.direction = keylist[5];
            animationCmd.fillMode = keylist[6];
            return animationCmd;
        }
    }
    exports.Tools = Tools;
    Tools.logFlag = true;
    Tools.warnFlag = true;
    Tools.errorFlag = false;
    /**
     * 是否为开发环境进行断点
     */
    Tools.isDev = false;
    Tools.format_space = (value) => {
        return value.replace(/\s+/g, ' ').replace(', ', ',');
    };
    const AnalyMap = {
        opacity: 'opacity',
        width: 'lengthData',
        height: 'lengthData',
        left: 'lengthData',
        top: 'lengthData',
        transform: 'transform'
    };
    exports.StyleMap = {
        alignContent: 'a',
        alignItems: 'b',
        alignSelf: 'c',
        background: 'd',
        backgroundColor: 'e',
        borderColor: 'f',
        borderImage: 'g',
        borderRadius: 'h',
        borderWidth: 'i',
        bottom: 'j',
        boxShadow: 'k',
        color: 'l',
        direction: 'm',
        display: 'n',
        flexBasis: 'o',
        flexDirection: 'p',
        flexGrow: 'q',
        flexShrink: 'r',
        flexWrap: 's',
        fontFamily: 't',
        fontSize: 'u',
        fontStyle: 'v',
        fontVariant: 'w',
        fontWeight: 'x',
        height: 'y',
        justifyContent: 'z',
        left: 'a0',
        letterSpacing: 'a1',
        lineGradient: 'a2',
        lineHeight: 'a3',
        margin: 'a4',
        marginBottom: 'a5',
        marginLeft: 'a6',
        marginRight: 'a7',
        marginTop: 'a8',
        maxHeight: 'a9',
        maxWidth: 'b0',
        minHeight: 'b1',
        minWidth: 'b2',
        opacity: 'b3',
        // outlineColor: 'b4',
        // outlineOffset: 'b5',
        // outlineStyle: 'b6',
        // outlineWidth: 'b7',
        oveflowWrap: 'b8',
        overflow: 'b9',
        padding: 'c0',
        paddingBottom: 'c1',
        paddingLeft: 'c2',
        paddingRight: 'c3',
        paddingTop: 'c4',
        position: 'c5',
        // radioGradient: 'c6',
        right: 'c7',
        rotate: 'c8',
        scale: 'c9',
        scroll: 'd0',
        textAlign: 'd1',
        textContent: 'd2',
        textDecoration: 'd3',
        textIndent: 'd4',
        // textOverflow: 'd5',
        textShadow: 'd6',
        textTransform: 'd7',
        top: 'd8',
        transform: 'd9',
        transformOrigin: 'e0',
        translate: 'e1',
        translateX: 'e2',
        translateY: 'e3',
        // unicodeBidi: 'e4',
        // verticalAlign: 'e5',
        visibility: 'e6',
        whiteSpace: 'e7',
        width: 'e8',
        wordSpacing: 'e9',
        zIndex: 'f0',
        textGradient: 'f1',
        textStroke: 'f2',
        pointerEvents: 'f3',
        objectFit: 'f4',
        animation: 'animation',
        borderImageSource: 'borderImageSource',
        borderImageClip: 'borderImageClip',
        borderImageRepeat: 'borderImageRepeat',
        borderImageSlice: 'borderImageSlice',
        imageClip: 'imageClip'
    };
    exports.StyleReflectMap = () => {
        for (const k in exports.StyleMap) {
            exports.StyleMap[exports.StyleMap[k]] = k;
        }
    };
    exports.StyleReflectMap();
});
// export enum StyleMap  {
//     alignContent = 'a',
//     alignItems = 'b',
//     alignSelf = 'c',
//     background = 'd',
//     backgroundColor = 'e',
//     borderColor = 'f',
//     borderImage = 'g',
//     borderRadius = 'h',
//     borderWidth = 'i',
//     bottom = 'j',
//     boxShadow = 'k',
//     color = 'l',
//     direction = 'm',
//     display = 'n',
//     flexBasis = 'o',
//     flexDirection = 'p',
//     flexGrow = 'q',
//     flexShrink = 'r',
//     flexWrap = 's',
//     fontFamily = 't',
//     fontSize = 'u',
//     fontStyle = 'v',
//     fontVariant = 'w',
//     fontWeight = 'x',
//     height = 'y',
//     justifyContent = 'z',
//     left = 'a0',
//     letterSpacing = 'a1',
//     lineGradient = 'a2',
//     lineHeight = 'a3',
//     margin = 'a4',
//     marginBottom = 'a5',
//     marginLeft = 'a6',
//     marginRight = 'a7',
//     marginTop = 'a8',
//     maxHeight = 'a9',
//     maxWidth = 'b0',
//     minHeight = 'b1',
//     minWidth = 'b2',
//     opacity = 'b3',
//     outlineColor = 'b4',
//     outlineOffset = 'b5',
//     outlineStyle = 'b6',
//     outlineWidth = 'b7',
//     oveflowWrap = 'b8',
//     overflow = 'b9',
//     padding = 'c0',
//     paddingBottom = 'c1',
//     paddingLeft = 'c2',
//     paddingRight = 'c3',
//     paddingTop = 'c4',
//     position = 'c5',
//     radioGradient = 'c6',
//     right = 'c7',
//     rotate = 'c8',
//     scale = 'c9',
//     scroll = 'd0',
//     textAlign = 'd1',
//     textContent = 'd2',
//     textDecoration = 'd3',
//     textIndent = 'd4',
//     textOverflow = 'd5',
//     textShadow = 'd6',
//     textTransform = 'd7',
//     top = 'd8',
//     transform = 'd9',
//     transformOrigin = 'e0',
//     translate = 'e1',
//     translateX = 'e2',
//     translateY = 'e3',
//     unicodeBidi = 'e4',
//     verticalAlign = 'e5',
//     visibility = 'e6',
//     whiteSpace = 'e7',
//     width = 'e8',
//     wordSpacing = 'e9',
//     zIndex = 'f0'
// }

_$pi.define("pi_gui/gui/gui/r_imageelement", ["require", "exports", "./gui", "./r_datastruct", "./r_element", "../combine_image/combine", "./tools", "../gui_res/res_mgr"], function (require, exports, gui_1, r_datastruct_1, r_element_1, combine_1, tools_1, res_mgr_1) {
    "use strict";
    
    /**
     * 图片节点
     */
    class RImageElement extends r_element_1.RElement {
        constructor(opt) {
            opt.uniqueID = gui_1.gui._create_image_node(opt.document.uniqueID);
            super(opt);
            this._type = r_datastruct_1.RElementTypeList.IMAGE;
            this.initDefaultStyle('img');
        }
        get src() {
            return this._imageDecs.url; // return gui._src(this.ele);
        }
        /**
         * TODO - 传入 canvas 时的处理
         */
        set src(url) {
            if (this._isDestroy)
                return;
            let imageDecs = combine_1.CombineImageMgr.getImageDecs(url);
            if (imageDecs) {
                imageDecs.srcUrl = url;
                this._imageDecs = imageDecs;
                const width = imageDecs.srcUrl ? imageDecs.srcWidth : imageDecs.width;
                const height = imageDecs.srcUrl ? imageDecs.srcHeight : imageDecs.height;
                // 样式中如果未设置宽高， 为节点设置图片的图片的宽高
                if (!this.document.readStyle(this.style, 'width')) {
                    this.defWidth(width);
                }
                if (!this.document.readStyle(this.style, 'height')) {
                    this.defHeight(height);
                }
                let result = this.setSrcFrameUv();
                if (!result) {
                    this.attributes.imageClip = [imageDecs.top, imageDecs.left + width, imageDecs.top + height, imageDecs.left, 0];
                }
                window.__jsObj = imageDecs.url;
                gui_1.gui._set_src(this.document.uniqueID, this.uniqueID);
            }
            else {
                // TODO 加载图片， 图片加载成功后， setBoxWithImage，setSrcFrameUv， setImageimageClip 创建纹理， 设置url
                window.__jsObj = url;
                res_mgr_1.preLoadImage(url, (imageDecs, _image) => {
                    this.setImage(imageDecs);
                });
            }
        }
        /**
         * ImageClip 的激活调
         *
         * css clip: (top, right, bottom, left) 为坐标
         * gui clip: (x0, y0, x1, y1) 左上-右下坐标
         */
        activeImageClip() {
            let result = false;
            // let value = this.style.imageClip || this.attributes.imageClip;
            let value = this.attributes.imageClip || this.document.readStyle(this.style, 'imageClip');
            if (typeof value === 'string') {
                value = tools_1.Tools.imageClip(value);
            }
            if (!tools_1.Tools.noValue(value)) {
                const _value = [];
                if (value[4] === 0) {
                    if (this._imageDecs) {
                        _value[0] = value[0] / this._imageDecs.height;
                        _value[1] = value[1] / this._imageDecs.width;
                        _value[2] = value[2] / this._imageDecs.height;
                        _value[3] = value[3] / this._imageDecs.width;
                        gui_1.gui._set_image_clip(this.document.uniqueID, this.uniqueID, _value[3], _value[0], _value[1], _value[2]);
                        result = true;
                    }
                }
                else {
                    _value[0] = value[0];
                    _value[1] = value[1];
                    _value[2] = value[2];
                    _value[3] = value[3];
                    gui_1.gui._set_image_clip(this.document.uniqueID, this.uniqueID, _value[3], _value[0], _value[1], _value[2]);
                    result = true;
                }
            }
            return result;
        }
        // 尝试根据帧动画中对src uv的描述和_imageDecs， 设置图片节点的imageClip; 如果节点本身没有设置帧动画属性， 返回false
        setSrcFrameUv() {
            let result = false;
            const cellWidth = this.attributes.cellWidth;
            const cellHeight = this.attributes.cellHeight;
            const cellId = this.attributes.cellId;
            const _imageDecs = this._imageDecs;
            if (cellId !== undefined && cellWidth && cellHeight && _imageDecs) {
                const width = this._imageDecs.srcUrl ? this._imageDecs.srcWidth : this._imageDecs.width;
                const col = Math.floor(width / cellWidth);
                // const row = Math.floor(this._imageDecs.combineHeight / cellHeight);
                const offx = (cellId % col) * cellWidth;
                const offy = Math.floor(cellId / col) * cellHeight;
                this.attributes.imageClip = [offy + _imageDecs.top, offx + cellWidth + _imageDecs.left, offy + cellHeight + _imageDecs.top, offx + _imageDecs.left, 0];
                result = true;
            }
            return result;
        }
        setImage(imageDecs) {
            this._imageDecs = imageDecs;
            const width = imageDecs.srcUrl ? imageDecs.srcWidth : imageDecs.width;
            const height = imageDecs.srcUrl ? imageDecs.srcHeight : imageDecs.height;
            // 样式中如果未设置宽高， 为节点设置图片的图片的宽高
            if (!this.document.readStyle(this.style, 'width')) {
                this.defWidth(width);
            }
            if (!this.document.readStyle(this.style, 'height')) {
                this.defHeight(height);
            }
            let result = this.setSrcFrameUv();
            if (!result) {
                this.attributes.imageClip = [imageDecs.top, imageDecs.left + width, imageDecs.top + height, imageDecs.left, 0];
            }
        }
    }
    exports.RImageElement = RImageElement;
});
// // (<RImageElement>el).promiseSrc = url;
// let ImageDecs: ImageDecs;
// if (!getFile(url)) { 
// 	ImageDecs = CombineImageMgr.getImageDecs(url);
// }
// if (ImageDecs) {
// 	// const _cfg: GUIImageResCfg = GUIRes.createGUIImageResCfg(ImageDecs, srcOrg, src);
//     // el.attributes.imageClip = [ImageDecs.top, ImageDecs.left + ImageDecs.width, ImageDecs.top + ImageDecs.height, ImageDecs.left, 0];
// 	ImageDecs.srcUrl = url;
//     (<RImageElement>el).src = ImageDecs as any;
// } else {
//     const callBack = (_path: string, cfg: ImageDecs) => {
// 		if (el.isDestroy) { return; }
//         (<RImageElement>el).src = cfg;
// 	};
//     loadSrcNormal(widget, src, callBack);
// }

_$pi.define("pi_gui/gui/gui/r_element", ["require", "exports", "./enum", "./gui", "./r_attribute", "./r_datastruct", "./r_event_base", "./r_style", "./tools"], function (require, exports, enum_1, gui_1, r_attribute_1, r_datastruct_1, r_event_base_1, r_style_1, tools_1) {
    "use strict";
    
    const DefaultStyleType = { div: 0, span: 1, img: 2 };
    /**
     * 基础节点结构
     */
    class RElement {
        constructor(opt) {
            /**
             * 节点在 GUI 整棵节点树中的层级
             */
            // tslint:disable-next-line:variable-name
            this._level = 0;
            // /**
            //  * 目标图片内容尺寸
            //  */
            // // tslint:disable-next-line:variable-name
            // protected _imageWidth: number;
            // /**
            //  * 目标图片内容尺寸
            //  */
            // // tslint:disable-next-line:variable-name
            // protected _imageHeight: number;
            // /**
            //  * 目标图片内容在目标图片文件中起点
            //  */
            // // tslint:disable-next-line:variable-name
            // protected _imageLeft: number;
            // /**
            //  * 目标图片内容在目标图片文件中起点
            //  */
            // // tslint:disable-next-line:variable-name
            // protected _imageTop: number;
            // /**
            //  * 源图片文件尺寸
            //  */
            // // tslint:disable-next-line:variable-name
            // protected _srcImageWidth: number;
            // /**
            //  * 源图片文件尺寸
            //  */
            // // tslint:disable-next-line:variable-name
            // protected _srcImageHeight: number;
            /**
             * 节点是否销毁
             */
            // tslint:disable-next-line:variable-name
            this._isDestroy = false;
            this._opt = opt;
            this.uniqueID = opt.uniqueID;
            this._document = opt.document;
            this._style = r_style_1.RStyle.create(this);
            this.attributes = new r_attribute_1.RAttr(this);
            this._type = 'ele';
        }
        get value() {
            return this._value;
        }
        set value(v) {
            this._value = v;
        }
        get className() {
            return this._className; // return gui._class_name(this._u32);
        }
        set className(data) {
            if (!this._isDestroy) {
                // gui._set_class_name(this.document.uniqueID, (this.uniqueID), data);
                this._className = data;
                this.document.sheet.setNodeStyleClass(this, data);
            }
        }
        get display() {
            // return this.style.display !== YGDisplay.YGDisplayNone;
            return this.document.readStyle(this.style, 'display') !== enum_1.YGDisplay.YGDisplayNone;
        }
        set display(b) {
            if (typeof b === 'string') {
                this.document.applyStyle(this.style, 'display', b);
            }
            else {
                this.document.applyStyle(this.style, 'display', b ? enum_1.YGDisplay.YGDisplayFlex : enum_1.YGDisplay.YGDisplayNone);
            }
        }
        /**
         * 在整个页面全局的显示 left
         */
        get screenX() {
            this.getScreenInfo();
            return this._screenX;
        }
        /**
         * 在整个页面全局的显示 top
         */
        get screenY() {
            this.getScreenInfo();
            return this._screenY;
        }
        /**
         * 在整个页面全局的显示 left
         */
        get screenW() {
            this.getScreenInfo();
            return this._screenW;
        }
        /**
         * 在整个页面全局的显示 top
         */
        get screenH() {
            this.getScreenInfo();
            return this._screenH;
        }
        get width() {
            this.document.layout();
            this._width = gui_1.gui._offset_width(this.document.uniqueID, this.uniqueID);
            return this._width;
        }
        get height() {
            this.document.layout();
            this._height = gui_1.gui._offset_height(this.document.uniqueID, this.uniqueID);
            return this._height;
        }
        /**
         * 节点内容宽高
         */
        get contentWidth() {
            // if (this.document.layoutDirty) {
            this.document.layout();
            // } else {
            //     // 需要确保 render 循环时置 (<any>window).__jsObj = undefined;
            //     if ((<any>window).__jsObj && (<any>window).__jsObj.width !== undefined) {
            //         return this._width;
            //     }
            // }
            this._contentWidth = 0;
            window.__jsObj = {};
            gui_1.gui._content_box(this.document.uniqueID, this.uniqueID);
            this._contentWidth = window.__jsObj.width;
            this._contentHeight = window.__jsObj.height;
            return this._contentWidth;
        }
        /**
         * 节点内容宽高
         */
        get contentHeight() {
            // if (this.document.layoutDirty) {
            this.document.layout();
            // } else {
            //     // 需要确保 render 循环时置 (<any>window).__jsObj = undefined;
            //     if ((<any>window).__jsObj && (<any>window).__jsObj.height !== undefined) {
            //         return this._height;
            //     }
            // }
            this._contentHeight = 0;
            window.__jsObj = {};
            gui_1.gui._content_box(this.document.uniqueID, this.uniqueID);
            this._contentWidth = window.__jsObj.width;
            this._contentHeight = window.__jsObj.height;
            return this._contentHeight;
        }
        /**
         * 节点在 GUI 整棵节点树中的层级
         */
        get level() {
            return this._level;
        }
        /**
         * 节点是否已销毁
         */
        get isDestroy() {
            return this._isDestroy;
        }
        get opt() {
            return this._opt;
        }
        get style() {
            return this._style;
        }
        get document() {
            return this._document;
        }
        static setDefaultStyleList(nodeType, keys) {
            // keys.forEach(key => {
            //     this.defaultStyleList[DefaultStyleType[nodeType]].push(key);
            // });
        }
        static forEachDefaultStyleList(nodeType, func) {
            // const list  = this.defaultStyleList[DefaultStyleType[nodeType]];
            // if (list) {
            //     list.forEach(key => {
            //         func(key);
            //     });
            // }
        }
        /**
         * 界面实现时未设宽高 - 让GUI层设置时调用
         * @param data 像素值
         */
        defWidth(data) {
            gui_1.gui._init_width(this.document.uniqueID, this.uniqueID, data);
        }
        /**
         * 界面实现时未设宽高 - 让GUI层设置时调用
         * @param data 像素值
         */
        defHeight(data) {
            gui_1.gui._init_height(this.document.uniqueID, this.uniqueID, data);
        }
        /**
         * 设置节点 attributes
         * @param key 键
         * @param value 值
         */
        setAttribute(key, value) {
            this.attributes[key] = value;
        }
        /**
         * 读取节点 attributes
         * @param key 键
         * @param value 值
         */
        getAttribute(key) {
            return this.attributes[key];
        }
        /**
         * 删除节点 attributes
         * @param key 键
         * @param value 值
         */
        removeAttribute(key) {
            this.attributes[key] = undefined;
        }
        /**
         * 节点相对 屏幕 (canvas) 的矩形信息
         */
        getBoundingClientRect() {
            const res = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            [res.x, res.y, res.width, res.height] = this.getScreenInfo();
            return res;
        }
        /**
         * 节点相对 root (root 节点 / body) 的矩形信息
         */
        getBoundingClientRectRelativeRoot() {
            const res = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            [res.x, res.y, res.width, res.height] = this.getScreenInfo();
            res.x -= this.document.viewOption.left;
            res.y -= this.document.viewOption.top;
            res.x -= this.document.viewOption.notchWidth;
            res.y -= this.document.viewOption.notchHeight;
            return res;
        }
        /**
         * 节点移除
         * * 0. 取消在上下文中的引用
         * * 1. 事件清空
         * * 2. 从父节点移除
         * * 3. 解除数据引用
         * * TODO - 和渲染层对接节点销毁
         */
        remove() {
            // 0. 取消在上下文中的引用
            this.document && this.document.destroyElement(this);
            // 1. 事件清空
            this.clearListener();
            // 2. 从父节点移除
            if (this.parentNode) {
                this.parentNode.removeChild(this);
                this.removeCall();
            }
            else {
                // 为根节点
                if (this.document) {
                    const index = this.document.childNodes.indexOf(this);
                    this.document.childNodes.splice(index, 1);
                    this.removeCall();
                }
            }
            // 3. 解除数据引用
            this.attributes = undefined;
            // this.virtual    = undefined;
            this.parentNode = undefined;
            this._style = undefined;
            this._opt = undefined;
            this._level = -1;
        }
        /**
         * 添加事件监听
         * @param _type 监听的事件类型
         * @param _listener 监听调用
         */
        // tslint:disable-next-line:cyclomatic-complexity
        addEventListener(_type, _listener) {
            switch (_type) {
                case (r_event_base_1.REventTypes.up): {
                    !this.upListener && (this.upListener = r_event_base_1.ListenerListMgr.create());
                    this.upListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.down): {
                    !this.downListener && (this.downListener = r_event_base_1.ListenerListMgr.create());
                    this.downListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.click): {
                    !this.clickListener && (this.clickListener = r_event_base_1.ListenerListMgr.create());
                    this.clickListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.move): {
                    !this.moveListener && (this.moveListener = r_event_base_1.ListenerListMgr.create());
                    this.moveListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.dbclick): {
                    !this.dbclickListener && (this.dbclickListener = r_event_base_1.ListenerListMgr.create());
                    this.dbclickListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.longTap): {
                    !this.longTapListener && (this.longTapListener = r_event_base_1.ListenerListMgr.create());
                    this.longTapListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.multiPointer): {
                    !this.multiListener && (this.multiListener = r_event_base_1.ListenerListMgr.create());
                    this.multiListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.scroll): {
                    !this.scrollListener && (this.scrollListener = r_event_base_1.ListenerListMgr.create());
                    this.scrollListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.blur): {
                    !this.blurListener && (this.blurListener = r_event_base_1.ListenerListMgr.create());
                    this.blurListener.add(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.focus): {
                    !this.focusListener && (this.focusListener = r_event_base_1.ListenerListMgr.create());
                    this.focusListener.add(_listener);
                    break;
                }
                default:
            }
        }
        /**
         * 移除事件监听
         * @param _type 监听的事件类型
         * @param _listener 监听调用
         */
        removeEventListener(_type, _listener) {
            switch (_type) {
                case (r_event_base_1.REventTypes.up): {
                    this.upListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.down): {
                    this.downListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.click): {
                    this.clickListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.move): {
                    this.moveListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.dbclick): {
                    this.dbclickListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.longTap): {
                    this.longTapListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.multiPointer): {
                    this.multiListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.scroll): {
                    this.scrollListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.blur): {
                    this.blurListener.remove(_listener);
                    break;
                }
                case (r_event_base_1.REventTypes.focus): {
                    this.focusListener.remove(_listener);
                    break;
                }
                default:
            }
        }
        /**
         * 清空事件监听
         */
        clearListener() {
            r_event_base_1.ListenerListMgr.recycle(this.upListener);
            r_event_base_1.ListenerListMgr.recycle(this.moveListener);
            r_event_base_1.ListenerListMgr.recycle(this.blurListener);
            r_event_base_1.ListenerListMgr.recycle(this.downListener);
            r_event_base_1.ListenerListMgr.recycle(this.clickListener);
            r_event_base_1.ListenerListMgr.recycle(this.multiListener);
            r_event_base_1.ListenerListMgr.recycle(this.scrollListener);
            r_event_base_1.ListenerListMgr.recycle(this.longTapListener);
            r_event_base_1.ListenerListMgr.recycle(this.dbclickListener);
        }
        /**
         * up 事件响应
         * @param e 事件数据
         */
        up(e) {
            tools_1.Tools.log('up', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            // e.isSendNextLayer = true;
            if (!e.isOnlyBubble) {
                try {
                    if (this.upListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.upListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                // if (!e.stopPropagation) { // up 默认冒泡，不可阻挡
                if (this.parentNode) {
                    this.parentNode.up(e);
                }
                // }
            }
        }
        /**
         * down 事件响应
         * @param e 事件数据
         */
        down(e) {
            tools_1.Tools.log('down', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.isOnlyBubble) {
                try {
                    if (this.downListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.downListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                if (!e.stopPropagation) {
                    if (this.parentNode) {
                        this.parentNode.down(e);
                    }
                }
            }
        }
        /**
         * click 事件响应
         * @param e 事件数据
         */
        click(e) {
            tools_1.Tools.log('click', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.isOnlyBubble) {
                try {
                    if (this.clickListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.clickListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                if (!e.stopPropagation) {
                    if (this.parentNode) {
                        this.parentNode.click(e);
                    }
                }
            }
        }
        /**
         * move 事件响应
         * @param e 事件数据
         */
        move(e) {
            tools_1.Tools.log('move', this._level, e.x, e.y, e.pointerID);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.isOnlyBubble) {
                try {
                    if (this.moveListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.moveListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            else {
                tools_1.Tools.log('move', 'isOnlyBubble');
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                if (!e.stopPropagation) {
                    if (this.parentNode) {
                        this.parentNode.move(e);
                    }
                }
            }
        }
        /**
         * longtap 事件响应
         * @param e 事件数据
         */
        longTap(e) {
            tools_1.Tools.log('longtap', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.isOnlyBubble) {
                try {
                    if (this.longTapListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.longTapListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                if (!e.stopPropagation) {
                    if (this.parentNode) {
                        this.parentNode.longTap(e);
                    }
                }
            }
        }
        /**
         * 双击 事件响应
         * @param e 事件数据
         */
        dbclick(e) {
            tools_1.Tools.log('dbclick', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.isOnlyBubble) {
                try {
                    if (this.dbclickListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.dbclickListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                if (!e.stopPropagation) {
                    if (this.parentNode) {
                        this.parentNode.dbclick(e);
                    }
                }
            }
        }
        /**
         * 节点内部滚动处理
         * * 优先 Y 方向滚动
         * * Y 方向 没有剩余滚动量时，X 方向滚动
         * * x 方向 没有剩余滚动量时，向上冒泡
         */
        wheel(e) {
            tools_1.Tools.log('scroll', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.stopPropagation) {
                if (this.parentNode) {
                    this.parentNode.wheel(e);
                }
            }
            else {
                try {
                    // 触发 Scroll 监听器
                    this.scroll(e);
                }
                catch (error) {
                    console.error(error);
                }
            }
        }
        /**
         * 多点操作 事件响应
         * @param e 事件数据
         */
        multipointer(e) {
            tools_1.Tools.log('multipointer', this._level);
            e.current = this;
            // e.isSendNextLayer = e.isSendNextLayer || <boolean>this.attributes.isSendNextLayer;
            if (!e.isOnlyBubble) {
                try {
                    if (this.multiListener) {
                        if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                            this.multiListener.notify(e);
                        }
                    }
                }
                catch (error) {
                    console.error(error);
                }
            }
            if (!e.isPostprocess) {
                e.path.push(this);
                if (!e.stopPropagation) {
                    if (this.parentNode) {
                        this.parentNode.multipointer(e);
                    }
                }
            }
        }
        /**
         * 节点产生有效滚动时 响应监听器
         */
        scroll(e) {
            tools_1.Tools.log('scroll', this._level);
            e.current = this;
            if (this.scrollListener) {
                if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                    this.scrollListener.notify(e);
                }
            }
        }
        /**
         * 获得焦点 事件响应
         * @param e 事件数据
         */
        focus(e) {
            if (this._isDestroy) {
                return;
            }
            // input 节点 - span 不响应 focus
            if (this._type === r_datastruct_1.RElementTypeList.SPAN) {
                this.parentNode.focus(e);
                return;
            }
            tools_1.Tools.log('focus', this._level);
            e.current = this;
            if (this.focusListener) {
                if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                    this.focusListener.notify(e);
                }
            }
        }
        /**
         * 失去焦点 事件响应
         * @param e 事件数据
         */
        blur(e) {
            if (this._isDestroy) {
                return;
            }
            // input 节点 - span 不响应 focus
            if (this._type === r_datastruct_1.RElementTypeList.SPAN) {
                this.parentNode.blur(e);
                return;
            }
            tools_1.Tools.log('blur', this._level);
            e.current = this;
            if (this.blurListener) {
                if (!this.document.askWidgetEnableCall || this.document.askWidgetEnableCall(this)) {
                    this.blurListener.notify(e);
                }
            }
        }
        debugFocus() {
            this.document.renderDebugLayer(this);
        }
        debugBlur() {
            this.document.renderDebugLayer();
        }
        /**
         * 层级信息更新
         */
        updateLevel() {
            this._level = this.parentNode._level + 1;
        }
        /**
         * 节点可操作性
         * @param b 是否可操作
         */
        enabled(b) {
            gui_1.gui._set_enable(this.document.uniqueID, this.uniqueID, b);
        }
        /**
         * 节点在 上下文中显示信息
         */
        getScreenInfo() {
            this.document.layout();
            this._screenX = 0;
            window.__jsObj = {};
            gui_1.gui._offset_document(this.document.uniqueID, this.uniqueID);
            this._screenX = window.__jsObj.left;
            this._screenY = window.__jsObj.top;
            this._screenW = window.__jsObj.width;
            this._screenH = window.__jsObj.height;
            return [this._screenX, this._screenY, this._screenW, this._screenH];
        }
        /**
         * 节点滚动处理
         * * trsnaform - translate
         * @param x X 方向
         * @param y Y 方向
         */
        doScroll(x, y) {
            if (this._isDestroy) {
                return;
            }
            if (this.document.askWidgetClosedCall && this.document.askWidgetClosedCall(this)) {
                return;
            }
            this.document.willChange(this);
            this.document.applyStyle(this.style, 'translate', [[enum_1.LengthUnitType.Pixel, x], [enum_1.LengthUnitType.Pixel, y]]);
            this.document.layoutDirty = false;
        }
        activeScroll() {
            //
        }
        initDefaultStyle(nodeType) {
            RElement.forEachDefaultStyleList(nodeType, (key) => {
                this.style[key] = r_style_1.RStyle.getDefaultStyle(key);
            });
        }
        removeCall() {
            if (this._isDestroy) {
                try {
                    throw new Error(`节点不能再次销毁`);
                }
                catch (e) {
                    console.error(e);
                }
                return;
            }
            tools_1.Tools.log('remove', this.uniqueID);
            this._isDestroy = true;
            this.document.layoutDirty = true;
            this.style.remove();
            gui_1.gui._destroy_node(this.document.uniqueID, (this.uniqueID));
        }
    }
    exports.RElement = RElement;
    /**
     * 节点创建时需要设置的默认属性列表
     */
    RElement.defaultStyleList = [[], [], []];
});

/**
 * gui 节点 attributes 数据结构
 */
_$pi.define("pi_gui/gui/gui/r_attribute", ["require", "exports", "./gui", "./tools"], function (require, exports, gui_1, tools_1) {
    "use strict";
    
    /**
     * 节点 attributes 数据结构
     */
    class RAttr {
        constructor(ele) {
            this._isSendNextLayer = false;
            this._enabled = true;
            this._placeholder = '';
            this._ele = ele;
        }
        /**
         * 节点可操作性
         */
        set enabled(value) {
            if (value === 'false' || value === false) {
                this._ele.enabled(1);
                this._enabled = false;
            }
            else {
                this._ele.enabled(0);
                this._enabled = true;
            }
        }
        get enabled() {
            return this._enabled;
        }
        /**
         * 节点 value 值
         */
        set value(value) {
            this._ele.value = value;
        }
        /**
         * 滚动属性
         */
        set scroll_path(value) {
            this._scroll_path = value;
            this._ele.activeScroll();
        }
        /**
         * 滚动属性
         */
        get scroll_path() {
            return this._scroll_path;
        }
        /**
         * 事件传递属性
         * * 渲染层级间的传递
         */
        get isSendNextLayer() {
            return this._isSendNextLayer;
        }
        /**
         * 事件传递属性
         * * 渲染层级间的传递
         */
        set isSendNextLayer(v) {
            this._isSendNextLayer = v === '1' || v === 'true';
        }
        /**
         * 颜色变换
         * * 对应 PS HSI
         */
        set hsi(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.format_space(value);
                const cmdList = value.split(',');
                this._hsi = [cmdList[0] - 0, cmdList[1] - 0, cmdList[2] - 0];
            }
            else {
                this._hsi = [value[0], value[1], value[2]];
            }
            gui_1.gui._set_filter_hsi(this._ele.document.uniqueID, this._ele.uniqueID, this._hsi[0], this._hsi[1], this._hsi[2]);
        }
        /**
         * 颜色变换
         * * 对应 PS HSI
         */
        get hsi() {
            return this._hsi ? `${this._hsi[0]},${this._hsi[1]},${this._hsi[2]}` : '';
        }
        /**
         * 图片裁剪显示
         * * UV
         * * 合并图片集中指定区域显示
         */
        set imageClip(value) {
            if (typeof value === 'string') {
                value = tools_1.Tools.imageClip(value);
            }
            if (tools_1.Tools.noValue(value)) {
                // 
            }
            else {
                this._imageClip = value;
                this._ele.activeImageClip();
            }
        }
        /**
         * 图片裁剪显示
         * * UV
         * * 合并图片集中指定区域显示
         */
        get imageClip() {
            return this._imageClip;
        }
        /**
         * 图片内容显示的单位尺寸
         * * 指定裁剪图片内容的一个矩形区域进行渲染
         */
        set cellWidth(value) {
            this._cellWidth = value - 0;
            this._ele.setSrcFrameUv();
        }
        /**
         * 图片内容显示的单位尺寸
         * * 指定裁剪图片内容的一个矩形区域进行渲染
         */
        get cellWidth() {
            return this._cellWidth;
        }
        /**
         * 图片内容显示的单位尺寸
         * * 指定裁剪图片内容的一个矩形区域进行渲染
         */
        set cellHeight(value) {
            this._cellHeight = value - 0;
            this._ele.setSrcFrameUv();
        }
        /**
         * 图片内容显示的单位尺寸
         * * 指定裁剪图片内容的一个矩形区域进行渲染
         */
        get cellHeight() {
            return this._cellHeight;
        }
        /**
         * 图片内容具有单位尺寸时，指定显示等分后第几块区域
         * * 指定裁剪图片内容的一个矩形区域进行渲染
         */
        set cellId(value) {
            this._cellId = value - 0;
            this._ele.setSrcFrameUv();
        }
        /**
         * 图片内容具有单位尺寸时，指定显示等分后第几块区域
         * * 指定裁剪图片内容的一个矩形区域进行渲染
         */
        get cellId() {
            return this._cellId;
        }
        set cellAnim(value) {
            //
        }
        get placeholder() {
            return this._placeholder;
        }
        set placeholder(value) {
            this._placeholder = `${value}`;
            this._ele.placeholder = `${value}`;
        }
    }
    exports.RAttr = RAttr;
});

// 模板
/**
 *
 */
_$pi.define("pi_gui/gui/gui_compile/gui_tpl", ["require", "exports", "../gui_compile/style", "../gui_virtual/virtaul_node_keyword", "../../../pi_sys/modules/util/hash", "../../../pi_sys/feature/log"], function (require, exports, style_1, virtaul_node_keyword_1, hash, log_1) {
    "use strict";
    
    // ============================== 导出
    exports.level = log_1.logLevel;
    exports.VARNAME = '_cfg, it, it1, it2, it3, it4, it5, it6, it7, it8';
    exports.VALUE_REG = /\{\{([\s\S]+?)\}\}/g;
    exports.es6FOR1 = 'let _values = (o) => {return o.values ? o.values() : Object.keys(o)};\n';
    exports.es6FOR2 = 'let _entries = (o) => {return o.entries ? o.entries() : Object.keys(o).map(function(x) {return [x, o[x]]})};\n';
    exports.FOR1 = 'var _values = function(o)  {return Object.keys(o)};\n';
    exports.FOR2 = 'var _entries = function(o)  {return Object.keys(o).map(function(x) {return [x, o[x]]})};\n';
    exports.stringifyName = '_stringify';
    exports.getName = '_get';
    exports.hashName = '_hash';
    exports.pathName = '_path';
    // export const convertEntityName = '_convertEntity';
    // export const calAttrHashName = '_calAttrHash';
    // export const calTextHashName = '_calTextHash';
    // export const calJsonHashName = '_calJsonHash';
    // export const addJsonName = '_addJson';
    // export const installTextName = '_installText';
    // export const addTextName = '_addText';
    // export const chFuncName = '_chFunc';
    exports.convertEntityName = '_a';
    exports.calAttrHashName = '_b';
    exports.calTextHashName = '_c';
    exports.calJsonHashName = '_d';
    exports.addJsonName = '_e';
    exports.installTextName = '_f';
    exports.addTextName = '_g';
    exports.chFuncName = '_h';
    exports.calNodeHashName = '_i';
    exports.nextHashName = '_j';
    /**
     * @description  模板编译
     * @example
     * 参数为字符串，编译成模板函数的定义字符串
     */
    exports.compile = (s, construct, regex, regexIndex, varname, comment, file, version) => {
        const parser = new construct(version);
        parser.line = 0;
        parser.setVarname(varname || exports.VARNAME);
        parser.setComment(comment);
        try {
            parse(s, regex || exports.VALUE_REG, regexIndex || 1, parser);
            return parser.funString();
        }
        catch (e) {
            // warn(level, 'tpl compile function fail, file: ', file, ', line: ', parser.line, e, s);
            return '';
        }
    };
    /**
     * @description  返回字符串
     * @example
     */
    exports.toString = (o) => {
        const t = typeof o;
        if (t === 'number' || t === 'string') {
            return o;
        }
        try {
            return JSON.stringify(o);
        }
        catch (e) {
            // warn(level, 'tpl toString fail, obj: ', o, e);
            return '';
        }
    };
    /**
     * 计算json哈希
     */
    exports.calJsonHash = (data) => {
        let jsonHash = 0;
        Object.keys(data).forEach((k) => {
            const kHash = exports.calTextHash(k);
            const vHash = exports.calTextHash(data[k]);
            const kvHash = hash.nextHash(kHash, vHash);
            if (jsonHash === 0) {
                jsonHash = kvHash;
            }
            else {
                jsonHash = hash.nextHash(jsonHash, kvHash);
            }
        });
        return jsonHash;
    };
    /**
     * @description 计算文本哈希
     * @example
     */
    exports.calTextHash = (data) => {
        // tslint:disable:prefer-template
        return hash.iterHashCode((typeof data === 'string') ? data : data + '', 0, hash.charHash);
    };
    /**
     * @description 计算节点的属性哈希（包括节点名）
     * @example
     */
    exports.calAttrHash = (node) => {
        let size = 0;
        let str = '';
        for (const key in node[virtaul_node_keyword_1.VNKeyWords.attrs]) {
            if (key === 'w-tag') {
                node[virtaul_node_keyword_1.VNKeyWords.tagName] = node[virtaul_node_keyword_1.VNKeyWords.attrs]['w-tag'];
            }
            else if (key === 'w-did') {
                node[virtaul_node_keyword_1.VNKeyWords.did] = node[virtaul_node_keyword_1.VNKeyWords.attrs]['w-did'];
                delete node[virtaul_node_keyword_1.VNKeyWords.attrs]['w-did'];
            }
            else {
                size++;
                str += key;
                str += node[virtaul_node_keyword_1.VNKeyWords.attrs][key];
            }
        }
        node[virtaul_node_keyword_1.VNKeyWords.attrSize] = size;
        return node[virtaul_node_keyword_1.VNKeyWords.tagName] ? exports.calTextHash(str) : (exports.calTextHash(str) ^ exports.calTextHash(node[virtaul_node_keyword_1.VNKeyWords.tagName]));
    };
    exports.addJson = (value, parent) => {
        if (typeof value === 'object') {
            parent[virtaul_node_keyword_1.VNKeyWords.childHash] = hash.objHashCode(value, parent[virtaul_node_keyword_1.VNKeyWords.childHash] ? parent[virtaul_node_keyword_1.VNKeyWords.childHash] : 0, new Set());
        }
        else {
            parent[virtaul_node_keyword_1.VNKeyWords.childHash] = hash.anyHash(value, parent[virtaul_node_keyword_1.VNKeyWords.childHash] ? parent[virtaul_node_keyword_1.VNKeyWords.childHash] : 0, new Set());
        }
        parent[virtaul_node_keyword_1.VNKeyWords.child] = value;
        parent[virtaul_node_keyword_1.VNKeyWords.childHas] = true;
    };
    exports.addText = (value, parent) => {
        const deep = {
            obj: null
        };
        const hashv = exports.calTextHash(value);
        if (value && typeof value === 'string') {
            if (value.indexOf('&#x') > -1) {
                value = value.replace(/&#x(\w+?);/g, (s0, s1) => {
                    return String.fromCharCode(parseInt(s1, 16));
                });
            }
            value = exports.convertEntity(value);
        }
        if (parent && parent[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span') {
            parent[virtaul_node_keyword_1.VNKeyWords.text] = parent[virtaul_node_keyword_1.VNKeyWords.text] ? parent[virtaul_node_keyword_1.VNKeyWords.text] + value : value;
            parent.textHash = parent.textHash ? hash.nextHash(parent.textHash, hashv) : hashv;
        }
        else {
            parent[virtaul_node_keyword_1.VNKeyWords.children].push({ [virtaul_node_keyword_1.VNKeyWords.text]: value, str: value, [virtaul_node_keyword_1.VNKeyWords.childHas]: hashv, hash: hashv, hasChild: undefined });
        }
    };
    exports.installText = (value, hashv, parent) => {
        const node = {
            [virtaul_node_keyword_1.VNKeyWords.text]: value,
            [virtaul_node_keyword_1.VNKeyWords.childHash]: hashv,
            hash: hashv,
            str: value,
            hasChild: undefined
        };
        if (node[virtaul_node_keyword_1.VNKeyWords.text].indexOf('&#x') > -1) {
            node[virtaul_node_keyword_1.VNKeyWords.text] = node[virtaul_node_keyword_1.VNKeyWords.text].replace(/&#x(\w+?);/g, (s0, s1) => {
                return String.fromCharCode(parseInt(s1, 16));
            });
        }
        node[virtaul_node_keyword_1.VNKeyWords.text] = exports.convertEntity(node[virtaul_node_keyword_1.VNKeyWords.text]);
        if (parent && parent[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span') {
            parent[virtaul_node_keyword_1.VNKeyWords.text] = parent[virtaul_node_keyword_1.VNKeyWords.text] + node[virtaul_node_keyword_1.VNKeyWords.text];
            parent.textHash = parent.textHash ? hash.nextHash(parent.textHash, hashv) : hashv;
        }
        return node;
    };
    /**
     * @description 转换html的转义字符串
     * @example
     */
    exports.convertEntity = (str) => {
        for (let i = 0; i < entityArr.length; i++) {
            if (str.indexOf(entityArr[i][0]) > -1) {
                str = str.replace(new RegExp(entityArr[i][0], 'ig'), String.fromCharCode(entityArr[i][1]));
            }
        }
        return str;
    };
    /**
     * 计算html标签的hash,参与计算的属性有sid，tagName，attrHash，styleHash，eventHash和textHash
     */
    exports.calNodeHash = (node) => {
        const sidAndTagHash = hash.nextHash(exports.calTextHash(node[virtaul_node_keyword_1.VNKeyWords.tagName]), node[virtaul_node_keyword_1.VNKeyWords.sid]);
        const attrsHash = hash.nextHash(node[virtaul_node_keyword_1.VNKeyWords.attrHash] || 0, hash.nextHash(node[virtaul_node_keyword_1.VNKeyWords.styleHash] || 0, node[virtaul_node_keyword_1.VNKeyWords.eventHash]));
        let nodeHash = hash.nextHash(sidAndTagHash, attrsHash);
        if (node.textHash) {
            nodeHash = hash.nextHash(nodeHash, node.textHash);
        }
        node[virtaul_node_keyword_1.VNKeyWords.nodeHash] = nodeHash;
        if (node[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span') {
            node[virtaul_node_keyword_1.VNKeyWords.childHash] = 0;
        }
    };
    exports.chFunc = (node) => {
        if (node[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span' || node[virtaul_node_keyword_1.VNKeyWords.childHash]) {
            return;
        }
        node[virtaul_node_keyword_1.VNKeyWords.childHash] = 0;
        if (node[virtaul_node_keyword_1.VNKeyWords.children] && node[virtaul_node_keyword_1.VNKeyWords.children].length > 0) {
            for (let i = 0; i < node[virtaul_node_keyword_1.VNKeyWords.children].length; i++) {
                const child = node[virtaul_node_keyword_1.VNKeyWords.children][i];
                const childNodeHash = child[virtaul_node_keyword_1.VNKeyWords.nodeHash];
                const childHash = hash.nextHash(hash.nextHash(childNodeHash, child[virtaul_node_keyword_1.VNKeyWords.childHash] || 0), i + 1);
                node[virtaul_node_keyword_1.VNKeyWords.childHash] = hash.nextHash(node[virtaul_node_keyword_1.VNKeyWords.childHash], childHash);
            }
        }
    };
    /**
     * @description 转换字符串成模板函数
     * @example
     */
    exports.toFun = (s, path) => {
        try {
            // tslint:disable-next-line:no-function-constructor-with-string-args
            return (new Function(exports.stringifyName, exports.getName, exports.hashName, exports.pathName, exports.convertEntityName, exports.calAttrHashName, exports.calTextHashName, exports.addJsonName, exports.installTextName, exports.addTextName, exports.chFuncName, exports.calJsonHashName, style_1.styleStr2JsonName, 'return' + s))(exports.toString, /*commonjs ?
                commonjs.relativeGet : null*/ null, hash, path, exports.convertEntity, exports.calAttrHash, exports.calTextHash, exports.addJson, exports.installText, exports.addText, exports.chFunc, exports.calJsonHash, style_1.styleStr2Json);
        }
        catch (e) {
            // warn(level, 'tpl toFun, path: ' + path + ', s: ', s, e);
            throw (e);
        }
    };
    exports.toFunComplete = (func, path) => {
        try {
            return func(exports.toString, /*commonjs ?commonjs.relativeGet : null*/ null, hash, path, exports.convertEntity, exports.calAttrHash, exports.calTextHash, exports.addJson, exports.installText, exports.addText, exports.chFunc, exports.calJsonHash, style_1.styleStr2Json);
        }
        catch (e) {
            // warn(level, 'tpl toFun, path: ' + path + ',' + e);
            throw (e);
        }
    };
    /**
     * @description  返回定义的函数, 用定义字符串，转成匿名函数的返回函数
     * @example
     */
    exports.toFunc = (s, path) => {
        try {
            // tslint:disable-next-line:no-function-constructor-with-string-args
            return (new Function(exports.stringifyName, exports.getName, exports.pathName, 'return ' + s))(exports.toString, /*commonjs ?commonjs.relativeGet : null*/ null, path);
        }
        catch (e) {
            // warn(level, 'tpl toFun, path: ' + path + ', s: ', s, e);
            throw (e);
        }
    };
    exports.getFunc = (path) => {
        return { exports: require(`../../${path}`) };
    };
    // ============================== 本地
    const LINE_FEED_CODE = 10;
    const entityArr = [
        ['&nbsp;', 160],
        ['&lt;', 60],
        ['&gt;', 62],
        ['&amp;', 38],
        ['&quot;', 34],
        ['&apos;', 39],
        ['&cent;', 162],
        ['&pound;', 163],
        ['&yen;', 165],
        ['&euro;', 8364],
        ['&sect;', 167],
        ['&copy;', 169],
        ['&reg;', 174],
        ['&trade;', 8482],
        ['&times;', 215],
        ['&divide;', 247]
    ];
    /**
     * @description 统计行数
     * @example
     */
    const line = (s) => {
        let i;
        let n = 0;
        for (i = s.length - 1; i >= 0; i--) {
            s.charCodeAt(i) === LINE_FEED_CODE && n++;
        }
        return n;
    };
    /**
     * @description 处理代码中的无效字符串
     * @example
     */
    const unescape = (code) => {
        return code.replace(/[\r\t\n]/g, ' ');
    };
    /**
     * @description 用第一个字符出现位置，将字符串分解成2部分
     * @example
     */
    const splitFirst = (s, c) => {
        const i = s.indexOf(c);
        return (i >= 0) ? [s.substring(0, i), s.substring(i + c.length)] : false;
    };
    /**
     * @description 表达式求值
     * @example
     */
    const evaluate = (str) => {
        // %TODO 进行检查，不允许定义临时变量
        return str.trim();
    };
    /**
     * @description 分析定义或赋值的变量
     * @example
     */
    const parseVar = (s, parser) => {
        if (s.indexOf('=') < 1) {
            throw new Error('template compile exception: ' + s);
        }
        parser.putComment(s);
        // return "let " + s + ";\n";
        return 'var ' + s + ';\n';
    };
    /**
     * @description 分析直接执行的代码
     * @example
     */
    const parseEvaluate = (s, parser) => {
        parser.putComment(s);
        return 'try{' + evaluate(s) + '}catch(e){};\n';
    };
    /**
     * @description for循环开始
     * @example
     */
    const parseFor = (s, parser) => {
        let arr;
        arr = splitFirst(s, 'of');
        if (!arr) {
            throw new Error('template compile exception: ' + s);
        }
        parser.putComment(s);
        const r = evaluate(arr[1]);
        s = arr[0].trim();
        arr = splitFirst(s, ',');
        const t = parser.getTempVar();
        if (arr) {
            parser.useFor2();
            // tslint:disable:max-line-length
            // return "try{for(let _each of _entries(" + r + ")){\nlet " + arr[0].trim() + " = _each[0], "+ arr[1].trim() +" = _each[1];\n";
            // return "try{var _entry = _entries(" + r + "); for(var _key in _entry){\nvar " + arr[0].trim() + " = _key, "+ arr[1].trim() +" = _entry[_key];\n";
            if (parser.version === 'es5') {
                return 'try{var ' + t + ' = _entries(' + r + '); for(var _key in ' + t + '){\nvar _each = ' + t + '[_key];\nvar ' + arr[0].trim() + ' = _each[0], ' + arr[1].trim() + ' = _each[1];\n';
            }
            else { // es6
                return 'try{for(let _each of _entries(' + r + ')){\nlet ' + arr[0].trim() + ' = _each[0], ' + arr[1].trim() + ' = _each[1];\n';
            }
        }
        parser.useFor1();
        // return "try{for(let " + s +" of _values(" + r + ")){\n";
        if (parser.version === 'es5') {
            return 'try{var ' + t + ' = _values(' + r + ');for(var _key  in ' + t + '){\n' + s + '= ' + t + '[_key]\n';
        }
        else { // es6
            return 'try{for(let ' + s + ' of _values(' + r + ')){\n';
        }
    };
    /**
     * @description while循环开始
     * @example
     */
    const parseWhile = (s, parser) => {
        parser.putComment(s);
        return 'try{while(' + evaluate(s) + '){\n';
    };
    /**
     * @description 分析if条件判断开始
     * @example
     */
    const parseIf = (s, parser) => {
        parser.putComment(s);
        return 'try{if(' + evaluate(s) + '){\n';
    };
    /**
     * @description 分析else if条件判断
     * @example
     */
    const parseElseif = (s, parser) => {
        parser.putComment(s);
        return '}else if(' + evaluate(s) + '){\n';
    };
    /**
     * @description 模板分析
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    const parse = (s, regex, regexIndex, parser) => {
        let m;
        let t;
        let i = 0;
        let c;
        // tslint:disable-next-line:no-conditional-assignment
        while ((m = regex.exec(s))) {
            t = s.substring(i, m.index);
            parser.putText(t);
            parser.line += line(t);
            i = m.index + m[0].length;
            t = unescape(m[regexIndex]);
            c = t.charCodeAt(0);
            if (t === 'end') {
                parser.putCode('}}catch(e){}\n');
            }
            else if (t === 'else') {
                parser.putCode('}else{\n');
            }
            else if (c === 58) {
                // : 直接执行代码
                parser.putCode(parseEvaluate(t.substring(1), parser));
            }
            else if (c === 37) {
                // % 注释，直接忽略
            }
            else if (c === 92) {
                // \ 原样输出
                parser.putText(m[0].replace(/\\/, ''));
            }
            else if (c === 105 && t.length > 2 && t.charCodeAt(1) === 102) {
                // if条件判断
                parser.putCode(parseIf(t.substring(2).trim(), parser));
            }
            else if (c === 102 && t.length > 3 && t.charCodeAt(1) === 111 && t.charCodeAt(2) === 114) {
                // for循环
                parser.putCode(parseFor(t.substring(3).trim(), parser));
            }
            else if (c === 101 && t.length > 6 && t.charCodeAt(1) === 108 && t.charCodeAt(2) === 115 && t.charCodeAt(3) === 101 && t.charCodeAt(4) === 105 && t.charCodeAt(5) === 102) {
                // elseif
                parser.putCode(parseElseif(t.substring(6).trim(), parser));
            }
            else if (c === 119 && t.length > 5 && t.charCodeAt(1) === 104 && t.charCodeAt(2) === 105 && t.charCodeAt(3) === 108 && t.charCodeAt(4) === 101) {
                // while
                parser.putCode(parseWhile(t.substring(5).trim(), parser));
            }
            else if (c === 108 && t.length > 3 && t.charCodeAt(1) === 101 && t.charCodeAt(2) === 116) {
                // let 赋值变量
                parser.putCode(parseVar(t.substring(3), parser));
            }
            else {
                parser.putComment(t);
                parser.putVar(evaluate(t));
            }
            parser.line += line(m[regexIndex]);
        }
        parser.putText(s.substring(i));
    };
});
// ============================== 立即执行的代码

_$pi.define("pi_gui/gui/gui_compile/style", ["require", "exports", "../gui/tools", "../gui_virtual/virtaul_node_keyword", "./gui_tpl", "./reform"], function (require, exports, tools_1, virtaul_node_keyword_1, gui_tpl_1, reform_1) {
    "use strict";
    
    /**
     * 将构建的style的形式由字符串改造成json对象形式
     */
    exports.styleWithJsonForm = (script, start, end) => {
        const style = script.slice(start, end).join('');
        const hasScript = style.startsWith('{');
        const v = reform_1.getValue(style, hasScript);
        const text = buildCode(v, hasScript);
        script.fill('', start, end);
        script[start] = text;
    };
    const buildCode = (validValue, hasScript) => {
        let r = '{';
        let hash;
        if (hasScript) {
            r += validValue;
            r += `attrvalue=${exports.styleStr2JsonName}(attrvalue);`;
            r += `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.style}"]=attrvalue;`;
            r += `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.styleSize}"]=Object.keys(attrvalue).length;`;
            r += `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.styleHash}"]=${gui_tpl_1.calJsonHashName}(attrvalue);`;
        }
        else {
            const obj = exports.styleStr2Json(validValue);
            const text = obj2JsonStr(obj);
            const size = Object.keys(obj).length;
            hash = gui_tpl_1.calJsonHash(obj);
            r += `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.style}"]=${text};${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.styleHash}"]=${hash};`;
            if (size > 0) {
                r += `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.styleSize}"]=${size};`;
            }
        }
        r += '}';
        return r;
    };
    // export const styleStr2JsonName = '_styleStr2Json';
    exports.styleStr2JsonName = '_s';
    /**
     * 将style字符串转换成json对象
     */
    exports.styleStr2Json = (styleValue) => {
        styleValue = styleValue.replace(/^["']/, '').replace(/["']$/, '');
        const obj = {};
        const kvPairs = styleValue.split(/\s*;\s*/);
        kvPairs.forEach((item) => {
            const [k, v] = item.split(/\s*:\s*/);
            if (k && v) {
                obj[tools_1.StyleMap[reform_1.camelcase(k)]] = `${v}`;
            }
        });
        return obj;
    };
    /**
     * 将style对象转换成文本形式
     */
    const obj2JsonStr = (obj) => {
        let r = '{';
        Object.keys(obj).forEach((k) => {
            let value = tools_1.Tools[tools_1.StyleMap[k]] ? tools_1.Tools[tools_1.StyleMap[k]](obj[k]) : obj[k];
            if (typeof value === typeof 'str') {
                value = `"${value}"`;
            }
            else {
                value = JSON.stringify(value);
            }
            r += `"${k}":${value},`;
        });
        r = r.replace(/,$/, '');
        r += '}';
        return r;
    };
});

// 模板
/**
 *
 */
_$pi.define("pi_gui/gui/gui_virtual/tpl", ["require", "exports", "../gui_compile/style", "../gui_virtual/virtaul_node_keyword", "../../../pi_sys/modules/util/hash", "../../../pi_sys/feature/log"], function (require, exports, style_1, virtaul_node_keyword_1, hash, log_1) {
    "use strict";
    
    exports.VARNAME = '_cfg, it, it1, it2, it3, it4, it5, it6, it7, it8';
    exports.VALUE_REG = /\{\{([\s\S]+?)\}\}/g;
    exports.es6FOR1 = 'let _values = (o) => {return o.values ? o.values() : Object.keys(o)};\n';
    exports.es6FOR2 = 'let _entries = (o) => {return o.entries ? o.entries() : Object.keys(o).map(function(x) {return [x, o[x]]})};\n';
    exports.FOR1 = 'var _values = function(o)  {return Object.keys(o)};\n';
    exports.FOR2 = 'var _entries = function(o)  {return Object.keys(o).map(function(x) {return [x, o[x]]})};\n';
    exports.stringifyName = '_stringify';
    exports.getName = '_get';
    exports.hashName = '_hash';
    exports.pathName = '_path';
    // export const convertEntityName = '_convertEntity';
    // export const calAttrHashName = '_calAttrHash';
    // export const calTextHashName = '_calTextHash';
    // export const calJsonHashName = '_calJsonHash';
    // export const addJsonName = '_addJson';
    // export const installTextName = '_installText';
    // export const addTextName = '_addText';
    // export const chFuncName = '_chFunc';
    exports.convertEntityName = '_a';
    exports.calAttrHashName = '_b';
    exports.calTextHashName = '_c';
    exports.calJsonHashName = '_d';
    exports.addJsonName = '_e';
    exports.installTextName = '_f';
    exports.addTextName = '_g';
    exports.chFuncName = '_h';
    exports.calNodeHashName = '_i';
    exports.nextHashName = '_j';
    /**
     * @description  模板编译
     * @example
     * 参数为字符串，编译成模板函数的定义字符串
     */
    exports.compile = (s, construct, regex, regexIndex, varname, comment, file, version) => {
        const parser = new construct(version);
        parser.line = 0;
        parser.setVarname(varname || exports.VARNAME);
        parser.setComment(comment);
        try {
            parse(s, regex || exports.VALUE_REG, regexIndex || 1, parser);
            return parser.funString();
        }
        catch (e) {
            log_1.cc.warn() && log_1.log('tpl compile function fail, file: ', file, ', line: ', parser.line, e, s);
            return '';
        }
    };
    /**
     * @description  返回字符串
     * @example
     */
    exports.toString = (o) => {
        const t = typeof o;
        if (t === 'number' || t === 'string') {
            return o;
        }
        try {
            return JSON.stringify(o);
        }
        catch (e) {
            log_1.cc.warn() && log_1.log('tpl toString fail, obj: ', o, e);
            return '';
        }
    };
    /**
     * 计算json哈希
     */
    exports.calJsonHash = (data) => {
        let jsonHash = 0;
        Object.keys(data).forEach((k) => {
            const kHash = exports.calTextHash(k);
            const vHash = exports.calTextHash(data[k]);
            const kvHash = hash.nextHash(kHash, vHash);
            if (jsonHash === 0) {
                jsonHash = kvHash;
            }
            else {
                jsonHash = hash.nextHash(jsonHash, kvHash);
            }
        });
        return jsonHash;
    };
    /**
     * @description 计算文本哈希
     * @example
     */
    exports.calTextHash = (data) => {
        // tslint:disable:prefer-template
        return hash.iterHashCode((typeof data === 'string') ? data : data + '', 0, hash.charHash);
    };
    /**
     * @description 计算节点的属性哈希（包括节点名）
     * @example
     */
    exports.calAttrHash = (node) => {
        let size = 0;
        let str = '';
        for (const key in node[virtaul_node_keyword_1.VNKeyWords.attrs]) {
            if (key === 'w-tag') {
                node[virtaul_node_keyword_1.VNKeyWords.tagName] = node[virtaul_node_keyword_1.VNKeyWords.attrs]['w-tag'];
            }
            else if (key === 'w-did') {
                node[virtaul_node_keyword_1.VNKeyWords.did] = node[virtaul_node_keyword_1.VNKeyWords.attrs]['w-did'];
                delete node[virtaul_node_keyword_1.VNKeyWords.attrs]['w-did'];
            }
            else {
                size++;
                str += key;
                str += node[virtaul_node_keyword_1.VNKeyWords.attrs][key];
            }
        }
        node[virtaul_node_keyword_1.VNKeyWords.attrSize] = size;
        return node[virtaul_node_keyword_1.VNKeyWords.tagName] ? exports.calTextHash(str) : (exports.calTextHash(str) ^ exports.calTextHash(node[virtaul_node_keyword_1.VNKeyWords.tagName]));
    };
    exports.addJson = (value, parent) => {
        if (typeof value === 'object') {
            parent[virtaul_node_keyword_1.VNKeyWords.childHash] = hash.objHashCode(value, parent[virtaul_node_keyword_1.VNKeyWords.childHash] ? parent[virtaul_node_keyword_1.VNKeyWords.childHash] : 0, new Set());
        }
        else {
            parent[virtaul_node_keyword_1.VNKeyWords.childHash] = hash.anyHash(value, parent[virtaul_node_keyword_1.VNKeyWords.childHash] ? parent[virtaul_node_keyword_1.VNKeyWords.childHash] : 0, new Set());
        }
        parent[virtaul_node_keyword_1.VNKeyWords.child] = value;
        parent[virtaul_node_keyword_1.VNKeyWords.childHas] = true;
    };
    exports.addText = (value, parent) => {
        const deep = {
            obj: null
        };
        const hashv = exports.calTextHash(value);
        if (value && typeof value === 'string') {
            if (value.indexOf('&#x') > -1) {
                value = value.replace(/&#x(\w+?);/g, (s0, s1) => {
                    return String.fromCharCode(parseInt(s1, 16));
                });
            }
            value = exports.convertEntity(value);
        }
        if (parent && parent[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span') {
            parent[virtaul_node_keyword_1.VNKeyWords.text] = parent[virtaul_node_keyword_1.VNKeyWords.text] ? parent[virtaul_node_keyword_1.VNKeyWords.text] + value : value;
            parent.textHash = parent.textHash ? hash.nextHash(parent.textHash, hashv) : hashv;
        }
        else {
            parent[virtaul_node_keyword_1.VNKeyWords.children].push({ [virtaul_node_keyword_1.VNKeyWords.text]: value, str: value, [virtaul_node_keyword_1.VNKeyWords.childHas]: hashv, hash: hashv, hasChild: undefined });
        }
    };
    exports.installText = (value, hashv, parent) => {
        const node = {
            [virtaul_node_keyword_1.VNKeyWords.text]: value,
            [virtaul_node_keyword_1.VNKeyWords.childHash]: hashv,
            hash: hashv,
            str: value,
            hasChild: undefined
        };
        if (node[virtaul_node_keyword_1.VNKeyWords.text].indexOf('&#x') > -1) {
            node[virtaul_node_keyword_1.VNKeyWords.text] = node[virtaul_node_keyword_1.VNKeyWords.text].replace(/&#x(\w+?);/g, (s0, s1) => {
                return String.fromCharCode(parseInt(s1, 16));
            });
        }
        node[virtaul_node_keyword_1.VNKeyWords.text] = exports.convertEntity(node[virtaul_node_keyword_1.VNKeyWords.text]);
        if (parent && parent[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span') {
            parent[virtaul_node_keyword_1.VNKeyWords.text] = parent[virtaul_node_keyword_1.VNKeyWords.text] + node[virtaul_node_keyword_1.VNKeyWords.text];
            parent.textHash = parent.textHash ? hash.nextHash(parent.textHash, hashv) : hashv;
        }
        return node;
    };
    /**
     * @description 转换html的转义字符串
     * @example
     */
    exports.convertEntity = (str) => {
        for (let i = 0; i < entityArr.length; i++) {
            if (str.indexOf(entityArr[i][0]) > -1) {
                str = str.replace(new RegExp(entityArr[i][0], 'ig'), String.fromCharCode(entityArr[i][1]));
            }
        }
        return str;
    };
    /**
     * 计算html标签的hash,参与计算的属性有sid，tagName，attrHash，styleHash，eventHash和textHash
     */
    exports.calNodeHash = (node) => {
        const sidAndTagHash = hash.nextHash(exports.calTextHash(node[virtaul_node_keyword_1.VNKeyWords.tagName]), node[virtaul_node_keyword_1.VNKeyWords.sid]);
        const attrsHash = hash.nextHash(node[virtaul_node_keyword_1.VNKeyWords.attrHash] || 0, hash.nextHash(node[virtaul_node_keyword_1.VNKeyWords.styleHash] || 0, node[virtaul_node_keyword_1.VNKeyWords.eventHash]));
        let nodeHash = hash.nextHash(sidAndTagHash, attrsHash);
        if (node.textHash) {
            nodeHash = hash.nextHash(nodeHash, node.textHash);
        }
        node[virtaul_node_keyword_1.VNKeyWords.nodeHash] = nodeHash;
        if (node[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span') {
            node[virtaul_node_keyword_1.VNKeyWords.childHash] = 0;
        }
    };
    exports.chFunc = (node) => {
        if (node[virtaul_node_keyword_1.VNKeyWords.tagName] === 'span' || node[virtaul_node_keyword_1.VNKeyWords.childHash]) {
            return;
        }
        node[virtaul_node_keyword_1.VNKeyWords.childHash] = 0;
        if (node[virtaul_node_keyword_1.VNKeyWords.children] && node[virtaul_node_keyword_1.VNKeyWords.children].length > 0) {
            for (let i = 0; i < node[virtaul_node_keyword_1.VNKeyWords.children].length; i++) {
                const child = node[virtaul_node_keyword_1.VNKeyWords.children][i];
                const childNodeHash = child[virtaul_node_keyword_1.VNKeyWords.nodeHash];
                const childHash = hash.nextHash(hash.nextHash(childNodeHash, child[virtaul_node_keyword_1.VNKeyWords.childHash] || 0), i + 1);
                node[virtaul_node_keyword_1.VNKeyWords.childHash] = hash.nextHash(node[virtaul_node_keyword_1.VNKeyWords.childHash], childHash);
            }
        }
    };
    /**
     * @description 转换字符串成模板函数
     * @example
     */
    exports.toFun = (s, path) => {
        try {
            // tslint:disable-next-line:no-function-constructor-with-string-args
            return (new Function(exports.stringifyName, exports.getName, exports.hashName, exports.pathName, exports.convertEntityName, exports.calAttrHashName, exports.calTextHashName, exports.addJsonName, exports.installTextName, exports.addTextName, exports.chFuncName, exports.calJsonHashName, style_1.styleStr2JsonName, 'return' + s))(exports.toString, /*commonjs ?
                commonjs.relativeGet : null*/ null, hash, path, exports.convertEntity, exports.calAttrHash, exports.calTextHash, exports.addJson, exports.installText, exports.addText, exports.chFunc, exports.calJsonHash, style_1.styleStr2Json);
        }
        catch (e) {
            log_1.cc.warn() && log_1.log('tpl toFun, path: ' + path + ', s: ', s, e);
            throw (e);
        }
    };
    exports.toFunComplete = (func, path) => {
        try {
            return func(exports.toString, /*commonjs ? commonjs.relativeGet : null*/ null, hash, path, exports.convertEntity, exports.calAttrHash, exports.calTextHash, exports.addJson, exports.installText, exports.addText, exports.chFunc, exports.calJsonHash, style_1.styleStr2Json);
        }
        catch (e) {
            log_1.cc.warn() && log_1.log('tpl toFun, path: ' + path + ',' + e);
            throw (e);
        }
    };
    /**
     * @description  返回定义的函数, 用定义字符串，转成匿名函数的返回函数
     * @example
     */
    exports.toFunc = (s, path) => {
        try {
            // tslint:disable-next-line:no-function-constructor-with-string-args
            return (new Function(exports.stringifyName, exports.getName, exports.pathName, 'return ' + s))(exports.toString, /*commonjs ? commonjs.relativeGet : null*/ null, path);
        }
        catch (e) {
            log_1.cc.warn && log_1.log('tpl toFun, path: ' + path + ', s: ', s, e);
            throw (e);
        }
    };
    exports.getFunc = (path) => {
        return { exports: new Promise((resolve_1, reject_1) => { require([path], resolve_1, reject_1); }) };
    };
    // ============================== 本地
    const LINE_FEED_CODE = 10;
    const entityArr = [
        ['&nbsp;', 160],
        ['&lt;', 60],
        ['&gt;', 62],
        ['&amp;', 38],
        ['&quot;', 34],
        ['&apos;', 39],
        ['&cent;', 162],
        ['&pound;', 163],
        ['&yen;', 165],
        ['&euro;', 8364],
        ['&sect;', 167],
        ['&copy;', 169],
        ['&reg;', 174],
        ['&trade;', 8482],
        ['&times;', 215],
        ['&divide;', 247]
    ];
    /**
     * @description 统计行数
     * @example
     */
    const line = (s) => {
        let i;
        let n = 0;
        for (i = s.length - 1; i >= 0; i--) {
            s.charCodeAt(i) === LINE_FEED_CODE && n++;
        }
        return n;
    };
    /**
     * @description 处理代码中的无效字符串
     * @example
     */
    const unescape = (code) => {
        return code.replace(/[\r\t\n]/g, ' ');
    };
    /**
     * @description 用第一个字符出现位置，将字符串分解成2部分
     * @example
     */
    const splitFirst = (s, c) => {
        const i = s.indexOf(c);
        return (i >= 0) ? [s.substring(0, i), s.substring(i + c.length)] : false;
    };
    /**
     * @description 表达式求值
     * @example
     */
    const evaluate = (str) => {
        // %TODO 进行检查，不允许定义临时变量
        return str.trim();
    };
    /**
     * @description 分析定义或赋值的变量
     * @example
     */
    const parseVar = (s, parser) => {
        if (s.indexOf('=') < 1) {
            throw new Error('template compile exception: ' + s);
        }
        parser.putComment(s);
        // return "let " + s + ";\n";
        return 'var ' + s + ';\n';
    };
    /**
     * @description 分析直接执行的代码
     * @example
     */
    const parseEvaluate = (s, parser) => {
        parser.putComment(s);
        return 'try{' + evaluate(s) + '}catch(e){};\n';
    };
    /**
     * @description for循环开始
     * @example
     */
    const parseFor = (s, parser) => {
        let arr;
        arr = splitFirst(s, 'of');
        if (!arr) {
            throw new Error('template compile exception: ' + s);
        }
        parser.putComment(s);
        const r = evaluate(arr[1]);
        s = arr[0].trim();
        arr = splitFirst(s, ',');
        const t = parser.getTempVar();
        if (arr) {
            parser.useFor2();
            // tslint:disable:max-line-length
            // return "try{for(let _each of _entries(" + r + ")){\nlet " + arr[0].trim() + " = _each[0], "+ arr[1].trim() +" = _each[1];\n";
            // return "try{var _entry = _entries(" + r + "); for(var _key in _entry){\nvar " + arr[0].trim() + " = _key, "+ arr[1].trim() +" = _entry[_key];\n";
            if (parser.version === 'es5') {
                return 'try{var ' + t + ' = _entries(' + r + '); for(var _key in ' + t + '){\nvar _each = ' + t + '[_key];\nvar ' + arr[0].trim() + ' = _each[0], ' + arr[1].trim() + ' = _each[1];\n';
            }
            else { // es6
                return 'try{for(let _each of _entries(' + r + ')){\nlet ' + arr[0].trim() + ' = _each[0], ' + arr[1].trim() + ' = _each[1];\n';
            }
        }
        parser.useFor1();
        // return "try{for(let " + s +" of _values(" + r + ")){\n";
        if (parser.version === 'es5') {
            return 'try{var ' + t + ' = _values(' + r + ');for(var _key  in ' + t + '){\n' + s + '= ' + t + '[_key]\n';
        }
        else { // es6
            return 'try{for(let ' + s + ' of _values(' + r + ')){\n';
        }
    };
    /**
     * @description while循环开始
     * @example
     */
    const parseWhile = (s, parser) => {
        parser.putComment(s);
        return 'try{while(' + evaluate(s) + '){\n';
    };
    /**
     * @description 分析if条件判断开始
     * @example
     */
    const parseIf = (s, parser) => {
        parser.putComment(s);
        return 'try{if(' + evaluate(s) + '){\n';
    };
    /**
     * @description 分析else if条件判断
     * @example
     */
    const parseElseif = (s, parser) => {
        parser.putComment(s);
        return '}else if(' + evaluate(s) + '){\n';
    };
    /**
     * @description 模板分析
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    const parse = (s, regex, regexIndex, parser) => {
        let m;
        let t;
        let i = 0;
        let c;
        // tslint:disable-next-line:no-conditional-assignment
        while ((m = regex.exec(s))) {
            t = s.substring(i, m.index);
            parser.putText(t);
            parser.line += line(t);
            i = m.index + m[0].length;
            t = unescape(m[regexIndex]);
            c = t.charCodeAt(0);
            if (t === 'end') {
                parser.putCode('}}catch(e){}\n');
            }
            else if (t === 'else') {
                parser.putCode('}else{\n');
            }
            else if (c === 58) {
                // : 直接执行代码
                parser.putCode(parseEvaluate(t.substring(1), parser));
            }
            else if (c === 37) {
                // % 注释，直接忽略
            }
            else if (c === 92) {
                // \ 原样输出
                parser.putText(m[0].replace(/\\/, ''));
            }
            else if (c === 105 && t.length > 2 && t.charCodeAt(1) === 102) {
                // if条件判断
                parser.putCode(parseIf(t.substring(2).trim(), parser));
            }
            else if (c === 102 && t.length > 3 && t.charCodeAt(1) === 111 && t.charCodeAt(2) === 114) {
                // for循环
                parser.putCode(parseFor(t.substring(3).trim(), parser));
            }
            else if (c === 101 && t.length > 6 && t.charCodeAt(1) === 108 && t.charCodeAt(2) === 115 && t.charCodeAt(3) === 101 && t.charCodeAt(4) === 105 && t.charCodeAt(5) === 102) {
                // elseif
                parser.putCode(parseElseif(t.substring(6).trim(), parser));
            }
            else if (c === 119 && t.length > 5 && t.charCodeAt(1) === 104 && t.charCodeAt(2) === 105 && t.charCodeAt(3) === 108 && t.charCodeAt(4) === 101) {
                // while
                parser.putCode(parseWhile(t.substring(5).trim(), parser));
            }
            else if (c === 108 && t.length > 3 && t.charCodeAt(1) === 101 && t.charCodeAt(2) === 116) {
                // let 赋值变量
                parser.putCode(parseVar(t.substring(3), parser));
            }
            else {
                parser.putComment(t);
                parser.putVar(evaluate(t));
            }
            parser.line += line(m[regexIndex]);
        }
        parser.putText(s.substring(i));
    };
});
// ============================== 立即执行的代码

/**
 *
 */
_$pi.define("pi_gui/gui/gui_virtual/virtaul_node_keyword", ["require", "exports"], function (require, exports) {
    "use strict";
    
    exports.VNKeyWords = {
        ['tagName']: 'tg',
        ['sid']: 'si',
        ['did']: 'di',
        ['offsetOld']: 'oO',
        ['offset']: 'o',
        ['widget']: 'w',
        ['parent']: 'p',
        ['ext']: 'ext',
        ['nodeHash']: 'nH',
        ['attrHash']: 'aH',
        ['attrSize']: 'aS',
        ['attrs']: 'a',
        ['styleHash']: 'sH',
        ['styleSize']: 'sS',
        ['style']: 's',
        ['eventHash']: 'eH',
        ['eventSize']: 'eS',
        ['event']: 'e',
        ['childHashMap']: 'cHM',
        ['childHash']: 'cH',
        ['wclass']: 'wc',
        ['link']: 'l',
        ['children']: 'cd',
        ['didMap']: 'dM',
        ['textHashMap']: 'tHM',
        ['text']: 't',
        ['child']: 'ch',
        ['childHas']: 'cs',
        ['_$temp']: '$t',
        ['_$parent']: '$p',
        ['node']: '$n'
    };
});

_$pi.define("pi_gui/gui/gui_compile/reform", ["require", "exports", "../gui_virtual/virtaul_node_keyword", "../gui_virtual/tpl", "../../../pi_sys/modules/util/hash"], function (require, exports, virtaul_node_keyword_1, tpl_1, hash_1) {
    "use strict";
    
    /**
     * 将class和w-class提取从node.attr中提取到node上
     */
    exports.reformClass = (script, start, end) => {
        const classNames = script.slice(start, end).join('');
        const hasScript = classNames.startsWith('{');
        // let k = classNames.match(/node.attrs\["(.*?)"\]/)[1];
        let k = classNames.match(/\$n\["a"\]\["(.*?)"\]/)[1];
        const v = exports.getValue(classNames, hasScript);
        if (k === 'w-class')
            k = 'wclass';
        let result = '';
        if (hasScript) {
            result = `{${v}${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords[k] || k}"]=attrvalue;}`;
        }
        else {
            result = `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords[k] || k}"]=${v};`;
        }
        script.fill('', start, end);
        script[start] = result;
    };
    /**
     * 生成代码中，对属性赋值的值
     * * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     * * 正则匹配里注意手动改属性名
     */
    exports.getValue = (script, hasScript) => {
        let str = '';
        if (hasScript) {
            // str = script.match(/\{(.*?)node\.attrs.*\}node.attrHash/)[1];
            str = script.match(/\{(.*?)\$n\["a"\].*\}\$n\["aH"\]/)[1];
        }
        else {
            str = script.match(/= (.*?);$/)[1];
        }
        // if (str.search(';node.attr') >= 0) {
        if (str.search(';\$n["a"]') >= 0) {
            // str = str.match(/(^.+?);node\.attrHash.*/)[1];
            str = str.match(/(^.+?);\$n\["aH"\].*/)[1];
        }
        return str;
    };
    const eventHash = 0;
    exports.reformEvent = (ev, start, end) => {
        const evScript = ev.slice(start, end).join('');
        const hasScript = evScript.startsWith('{');
        // let k = evScript.match(/node.attrs\["(.*?)"\]/)[1];
        let k = evScript.match(/\$n\["a"\]\["(.*?)"\]/)[1];
        const v = exports.getValue(evScript, hasScript);
        k = eventMap[k] || k;
        // console.log('event ===============', k, v, evScript);
        let result = '';
        const kHash = tpl_1.calTextHash(k);
        if (hasScript) {
            result = `{${v}${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.event}"]["${k}"]=attrvalue;
        ${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.eventHash}"]=${tpl_1.nextHashName}(${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.eventHash}"], ${tpl_1.nextHashName}(${kHash}, _calTextHash(attrvalue)));
}`;
        }
        else {
            const vHash = tpl_1.calTextHash(v);
            const kvHash = hash_1.nextHash(kHash, vHash);
            result = `${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.event}"]["${k}"]=${v};
        ${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.eventHash}"]=${tpl_1.nextHashName}(${virtaul_node_keyword_1.VNKeyWords.node}["${virtaul_node_keyword_1.VNKeyWords.eventHash}"],${kvHash});`;
        }
        ev.fill('', start, end);
        ev[start] = result;
        // console.log('event result ============', result);
    };
    const eventMap = {
        'on-up': 'pointerup',
        'on-down': 'pointerdown',
        'on-tap': 'pointerclick',
        'on-move': 'pointermove',
        'on-longtap': 'longTap',
        'on-dbltap': 'dbclick',
        'on-multipointer': 'multipointer',
        'on-change': 'change',
        'on-blur': 'blur'
    };
    exports.camelcase = (name) => {
        const arr = name.split('-');
        let str = '';
        arr.forEach((item, idx) => {
            if (idx > 0 && item) {
                item = item[0].toUpperCase() + item.slice(1);
            }
            str += item;
        });
        return str;
    };
});

_$pi.define("pi_gui/gui/gui_font/readJsonBin", ["require", "exports", "../../../pi_sys/modules/util/util"], function (require, exports, util_1) {
    "use strict";
    
    let curOffset;
    const getPages = (arrbuff) => {
        const u16v = new Uint16Array(arrbuff, 0, 1);
        const len = u16v[0];
        const buf = arrbuff.slice(0, len);
        const pages = [];
        curOffset += 2;
        while (curOffset < len) {
            const u8 = new Uint8Array(buf, curOffset, 1);
            ++curOffset;
            const nameBuf = buf.slice(curOffset, curOffset + u8[0]);
            const name = util_1.utf8Decode(nameBuf);
            curOffset += u8[0];
            pages.push(name);
        }
        return pages;
    };
    const getFontName = (arrbuff) => {
        curOffset += 12;
        const lenBuf = arrbuff.slice(curOffset, curOffset + 1);
        const lenView = new Uint8Array(lenBuf);
        ++curOffset;
        const nameEnd = curOffset + lenView[0];
        const nameBuf = arrbuff.slice(curOffset, nameEnd);
        curOffset = nameEnd;
        return util_1.utf8Decode(nameBuf);
    };
    const getLineHeight = (arrbuff) => {
        const buf = arrbuff.slice(curOffset, curOffset + 1);
        const view = new Uint8Array(buf);
        curOffset += 1;
        return view[0];
    };
    const getPictureSize = (arrbuff) => {
        const buf = arrbuff.slice(curOffset, curOffset + 4);
        const view = new Uint8Array(buf);
        const view2 = new Uint16Array(view.buffer);
        curOffset += 4;
        return [view2[0], view2[1]];
    };
    const getPadding = (arrbuff) => {
        const buf = arrbuff.slice(curOffset, curOffset + 8);
        const view = new Uint16Array(buf);
        curOffset += 8;
        return [view[0], view[1], view[2], view[3]];
    };
    const getCharsetMap = (arrbuff) => {
        const len = arrbuff.byteLength;
        const info = [];
        const charset = [];
        while (curOffset < len) {
            const infoBuf = arrbuff.slice(curOffset, curOffset + 12);
            curOffset += 12;
            const u16View = new Uint16Array(infoBuf, 0, 3);
            const s8View = new Int8Array(infoBuf, 6, 2);
            const u8View = new Uint8Array(infoBuf, 8);
            const [id, x, y] = u16View;
            const [xoffset, yoffset] = s8View;
            const [width, height, advance, page] = u8View;
            charset.push(String.fromCharCode(id));
            info.push({ id, x, y, xoffset, yoffset, width, height, advance, page });
        }
        return [info, charset];
    };
    exports.bin2Json = (arrbuff) => {
        curOffset = 0;
        // 这部分函数调用必须按照该顺序，不能打乱顺序，不然数据读取出错
        const pages = getPages(arrbuff);
        const face = getFontName(arrbuff);
        const lineHeight = getLineHeight(arrbuff);
        const [scaleW, scaleH] = getPictureSize(arrbuff);
        const padding = getPadding(arrbuff);
        const [chars, charset] = getCharsetMap(arrbuff);
        return {
            pages,
            chars,
            info: {
                face,
                padding,
                charset
            },
            common: {
                lineHeight,
                scaleW,
                scaleH
            }
        };
    };
});

_$pi.define("pi_gui/gui/gui_root/beforeInit", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 初始化项目前 - 获取一些设备-环境相关数据
     * * 平台兼容处理
     */
    // tslint:disable-next-line:no-unnecessary-class
    class BeforeInitTools {
        // tslint:disable-next-line:function-name
        static Init() {
            BeforeInitTools.doGC();
        }
        static isWeiXinMiniGame() {
            const _window = window;
            if (this._isWeiXinGame === undefined) {
                this._isWeiXinGame = !!_window.wx;
            }
            return this._isWeiXinGame;
        }
        static wxNotchBarWidth() {
            if (this._wxNotchBarSize === undefined) {
                this._wxNotchBarSize = 0;
            }
            if (this.Design_Height > this.Design_Width) {
                return 0;
            }
            return this._wxNotchBarSize;
        }
        static wxNotchBarHeight() {
            if (this._wxNotchBarSize === undefined) {
                this._wxNotchBarSize = 0;
            }
            if (this.Design_Height < this.Design_Width) {
                return 0;
            }
            return this._wxNotchBarSize;
        }
        static recordDestroy() {
            BeforeInitTools._hasDestroy = true;
        }
        /**
         * 设置 GC 调用的判定查询, 调用返回 true 说明可调用GC
         * @param f 该调用返回 true 说明可调用GC
         */
        static setGCCheck(f) {
            this._gcCheck = f;
        }
    }
    exports.BeforeInitTools = BeforeInitTools;
    BeforeInitTools.Design_Width = 960;
    BeforeInitTools.Design_Height = 540;
    /**
     * 由于项目未完全实现自适应布局，期望的显示质量提升 - 缩放目标分辨率
     */
    BeforeInitTools.Promise_Scale = 1.0;
    BeforeInitTools.GCTime = 2000;
    BeforeInitTools._hasDestroy = true;
    BeforeInitTools.doGC = () => {
        if (!BeforeInitTools._gcCheck || BeforeInitTools._gcCheck() && BeforeInitTools._hasDestroy) {
            console.warn('GC');
            const now = Date.now();
            BeforeInitTools._gcCall && BeforeInitTools._gcCall();
            console.warn(`GC : ${Date.now() - now}`);
            BeforeInitTools._hasDestroy = false;
        }
        setTimeout(BeforeInitTools.doGC, BeforeInitTools.GCTime);
    };
});

_$pi.define("pi_gui/gui/gui_root/format_canvas_display", ["require", "exports", "./beforeInit"], function (require, exports, beforeInit_1) {
    "use strict";
    
    let _CANVAS;
    const SceneCfg = {
        // 设计尺寸
        WIDTH: 1334,
        HEIGHT: 750,
        // 设备尺寸
        DEVICE_HEIGHT: 0,
        DEVICE_WIDTH: 0,
        // canvas 视口尺寸 (缩放后)
        DISPLAY_HEIGHT: 0,
        DISPLAY_WIDTH: 0,
        // canvas 尺寸 (不计算缩放)
        CURR_WIDTH: 1334,
        CURR_HEIGHT: 750,
        // canvas 缩放
        CURR_SCALE: 1,
        // canvas 缩放
        CURR_SCALE_W: 1,
        CURR_SCALE_H: 1,
        // canvas 是否旋转 (顺时针90度)
        FLAG_ROTATION: false,
        // 是否是小游戏
        IS_WEIXIN_GAME: false,
        initCurrWidth: (w) => {
            SceneCfg.CURR_WIDTH = w;
            SceneCfg.CURR_SCALE_W = SceneCfg.DISPLAY_WIDTH / SceneCfg.CURR_WIDTH;
            if (SceneCfg.IS_WEIXIN_GAME) {
                SceneCfg.CURR_SCALE_W = SceneCfg.DEVICE_WIDTH / SceneCfg.CURR_WIDTH;
            }
        },
        initCurrHeight: (h) => {
            SceneCfg.CURR_HEIGHT = h;
            SceneCfg.CURR_SCALE_H = SceneCfg.DISPLAY_HEIGHT / SceneCfg.CURR_HEIGHT;
            if (SceneCfg.IS_WEIXIN_GAME) {
                SceneCfg.CURR_SCALE_H = SceneCfg.DEVICE_HEIGHT / SceneCfg.CURR_HEIGHT;
            }
        },
        initCurrScale: (s) => {
            SceneCfg.CURR_SCALE = s;
        }
    };
    /**
     * 标准化 Canvas 的显示 的方法类
     */
    // tslint:disable-next-line:no-unnecessary-class
    class FormatCanvasDisplay {
        static addResizeListener(f) {
            if (FormatCanvasDisplay.resizeListeners.indexOf(f) < 0) {
                FormatCanvasDisplay.resizeListeners.push(f);
            }
        }
        static resizeCall() {
            FormatCanvasDisplay.resizeListeners.forEach((f) => {
                f();
            });
        }
        /**
         * 初始化设计尺寸
         * @param w V
         * @param h V
         */
        static initDesignSize(w, h) {
            SceneCfg.WIDTH = w;
            SceneCfg.HEIGHT = h;
            this.DisplayCfg.DESIGN_VIEW_WIDTH = w;
            this.DisplayCfg.DESIGN_VIEW_HEIGHT = h;
        }
        /**
         * 标准化 canvas 显示
         * @param canvas V
         * @param parent 父dom节点，暂无用
         */
        static format(canvas, isPIDemo, parent) {
            _CANVAS = canvas;
            if (isPIDemo !== true) {
                FormatCanvasDisplay.initDesignSize(beforeInit_1.BeforeInitTools.Design_Width, beforeInit_1.BeforeInitTools.Design_Height);
                FormatCanvasDisplay.keepHeight_();
            }
            else {
                SceneCfg.DEVICE_HEIGHT = canvas.height;
                SceneCfg.DEVICE_WIDTH = canvas.width;
                this.DisplayCfg.DEVICE_HEIGHT = canvas.height;
                this.DisplayCfg.DEVICE_WIDTH = canvas.width;
                SceneCfg.DISPLAY_HEIGHT = canvas.height;
                SceneCfg.DISPLAY_WIDTH = canvas.width;
                this.DisplayCfg.DESIGN_VIEW_HEIGHT = canvas.height;
                this.DisplayCfg.DESIGN_VIEW_WIDTH = canvas.width;
                SceneCfg.initCurrWidth(canvas.width);
                SceneCfg.initCurrHeight(canvas.height);
            }
            FormatCanvasDisplay.resizeCall();
        }
        static getIsWeixinGAME() {
            return this.DisplayCfg.IS_WEIXIN_GAME;
        }
        static getDeviceWidth() {
            return this.DisplayCfg.DEVICE_WIDTH;
        }
        static getDeviceHeight() {
            return this.DisplayCfg.DEVICE_HEIGHT;
        }
        static getViewWidth() {
            return this.DisplayCfg.VIEW_WIDTH;
        }
        static getViewHeight() {
            return this.DisplayCfg.VIEW_HEIGHT;
        }
        static getContentDisplayLeft() {
            return this.DisplayCfg.CONTEN_IN_VIEW_LEFT;
        }
        static getContentDisplayTop() {
            return this.DisplayCfg.CONTEN_IN_VIEW_TOP;
        }
        static getContentDisplayWidth() {
            return this.DisplayCfg.CONTEN_IN_VIEW_WIDTH;
        }
        static getContentDisplayHeight() {
            return this.DisplayCfg.CONTEN_IN_VIEW_HEIGHT;
        }
        static getContentWidth() {
            return this.DisplayCfg.CONTENT_WIDTH;
        }
        static getContentHeight() {
            return this.DisplayCfg.CONTENT_HEIGHT;
        }
        static getDeviceViewScale() {
            return this.DisplayCfg.DEVICE_VIEW_SCALE;
        }
        static getIsRotate() {
            return this.DisplayCfg.IS_ROTATE;
        }
        static getIsWXGame() {
            return this.DisplayCfg.IS_WEIXIN_GAME;
        }
        /**
         * 保持高度不变，宽度自适应
         * @param isHorizontalScreen 是否为横屏设计
         */
        // tslint:disable-next-line:max-func-body-length
        static keepHeight_() {
            if (beforeInit_1.BeforeInitTools.isWeiXinMiniGame() === true) {
                this.DisplayCfg.IS_WEIXIN_GAME = true;
            }
            let baseAttr, scaleAttr, rotationAttr, transformAttr;
            this.DisplayCfg.DEVICE_WIDTH =
                document.documentElement.clientWidth
                    || document.body.clientWidth
                    || document.documentElement.screen.availWidth; // 微信小游戏
            this.DisplayCfg.DEVICE_HEIGHT =
                document.documentElement.clientHeight
                    || document.body.clientHeight
                    || document.documentElement.screen.availHeight; // 微信小游戏
            this.DisplayCfg.IS_ROTATE = false;
            if (this.DisplayCfg.DESIGN_VIEW_WIDTH > this.DisplayCfg.DESIGN_VIEW_HEIGHT) {
                if (this.DisplayCfg.DEVICE_WIDTH < this.DisplayCfg.DEVICE_HEIGHT) {
                    this.DisplayCfg.IS_ROTATE = true;
                    [this.DisplayCfg.DEVICE_WIDTH, this.DisplayCfg.DEVICE_HEIGHT] = [this.DisplayCfg.DEVICE_HEIGHT, this.DisplayCfg.DEVICE_WIDTH];
                }
            }
            else {
                if (this.DisplayCfg.DEVICE_WIDTH > this.DisplayCfg.DEVICE_HEIGHT) {
                    this.DisplayCfg.IS_ROTATE = true;
                    [this.DisplayCfg.DEVICE_WIDTH, this.DisplayCfg.DEVICE_HEIGHT] = [this.DisplayCfg.DEVICE_HEIGHT, this.DisplayCfg.DEVICE_WIDTH];
                }
            }
            // 宽高比不满足设计时 采用 高度固定，宽度自适应
            if (this.DisplayCfg.DEVICE_WIDTH * this.DisplayCfg.DESIGN_VIEW_HEIGHT !== this.DisplayCfg.DESIGN_VIEW_WIDTH * this.DisplayCfg.DEVICE_HEIGHT) {
                // =============以高度为计算起点
                // 假设 内容高 = 视口高 = 设计高
                // 假设内容高度充满项目视口
                this.DisplayCfg.VIEW_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                this.DisplayCfg.CONTENT_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                // 假设项目视口高度充满设备 计算 设备尺寸 比 项目视口尺寸
                this.DisplayCfg.DEVICE_VIEW_SCALE = this.DisplayCfg.DEVICE_HEIGHT / this.DisplayCfg.VIEW_HEIGHT;
                // =============以宽度为假设
                // 此时需要达到 内容宽 = 设计宽
                this.DisplayCfg.CONTENT_WIDTH = this.DisplayCfg.DESIGN_VIEW_WIDTH;
                // 计算这个情况下 需要的视口宽度
                this.DisplayCfg.VIEW_WIDTH = this.DisplayCfg.CONTENT_WIDTH;
                // 此时 显示高度 为 设备高度
                // 如果 需要的项目视口宽度 超出 设备内能显示的项目视口宽度
                if (this.DisplayCfg.VIEW_WIDTH - this.DisplayCfg.DEVICE_WIDTH / this.DisplayCfg.DEVICE_VIEW_SCALE > 0) {
                    // 压缩项目视口 使 宽度完全在设备视口内显示
                    const tempScale = (this.DisplayCfg.DEVICE_WIDTH / this.DisplayCfg.DEVICE_VIEW_SCALE) / this.DisplayCfg.VIEW_WIDTH;
                    this.DisplayCfg.DEVICE_VIEW_SCALE = tempScale * this.DisplayCfg.DEVICE_VIEW_SCALE;
                    // 内容宽 = 视口宽 = 设计宽
                    this.DisplayCfg.VIEW_WIDTH = this.DisplayCfg.DESIGN_VIEW_WIDTH;
                    this.DisplayCfg.CONTENT_WIDTH = this.DisplayCfg.DESIGN_VIEW_WIDTH;
                    // 视口高 = 设备高 / 缩放 ， 内容高 = 设计高
                    this.DisplayCfg.VIEW_HEIGHT = this.DisplayCfg.DEVICE_HEIGHT / this.DisplayCfg.DEVICE_VIEW_SCALE;
                    this.DisplayCfg.CONTENT_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                }
                else {
                    const tempScale = 1;
                    this.DisplayCfg.DEVICE_VIEW_SCALE = tempScale * this.DisplayCfg.DEVICE_VIEW_SCALE;
                    // 内容宽 = 设备宽 / 缩放 ， 内容宽 = 设计宽
                    this.DisplayCfg.VIEW_WIDTH = this.DisplayCfg.DEVICE_WIDTH / this.DisplayCfg.DEVICE_VIEW_SCALE;
                    this.DisplayCfg.CONTENT_WIDTH = this.DisplayCfg.DESIGN_VIEW_WIDTH;
                    // 视口高 = 内容高 = 设计高
                    this.DisplayCfg.VIEW_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                    this.DisplayCfg.CONTENT_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                }
            }
            else {
                // 内容高 = 视口高 = 设计高
                this.DisplayCfg.VIEW_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                this.DisplayCfg.CONTENT_HEIGHT = this.DisplayCfg.DESIGN_VIEW_HEIGHT;
                this.DisplayCfg.VIEW_WIDTH = this.DisplayCfg.DESIGN_VIEW_WIDTH;
                this.DisplayCfg.CONTENT_WIDTH = this.DisplayCfg.DESIGN_VIEW_WIDTH;
                this.DisplayCfg.DEVICE_VIEW_SCALE = this.DisplayCfg.DEVICE_HEIGHT / this.DisplayCfg.VIEW_HEIGHT;
            }
            this.DisplayCfg.CONTEN_IN_VIEW_LEFT = (this.DisplayCfg.VIEW_WIDTH - this.DisplayCfg.CONTENT_WIDTH) / 2;
            this.DisplayCfg.CONTEN_IN_VIEW_TOP = (this.DisplayCfg.VIEW_HEIGHT - this.DisplayCfg.CONTENT_HEIGHT) / 2;
            this.DisplayCfg.CONTEN_IN_VIEW_WIDTH = this.DisplayCfg.CONTENT_WIDTH;
            this.DisplayCfg.CONTEN_IN_VIEW_HEIGHT = this.DisplayCfg.CONTENT_HEIGHT;
            if (this.DisplayCfg.IS_WEIXIN_GAME) {
                let tempHairSize = 0;
                const hairSize = beforeInit_1.BeforeInitTools.Weixin_Mobile_Bangs_Size / this.DisplayCfg.DEVICE_VIEW_SCALE;
                // 横屏
                if (this.DisplayCfg.DESIGN_VIEW_HEIGHT < this.DisplayCfg.DESIGN_VIEW_WIDTH) {
                    tempHairSize = hairSize - this.DisplayCfg.CONTEN_IN_VIEW_LEFT;
                    if (tempHairSize > 0) {
                        this.DisplayCfg.VIEW_WIDTH += tempHairSize;
                        this.DisplayCfg.CONTENT_WIDTH += tempHairSize;
                        this.DisplayCfg.CONTEN_IN_VIEW_LEFT += tempHairSize;
                    }
                }
                else {
                    tempHairSize = hairSize - this.DisplayCfg.CONTEN_IN_VIEW_TOP;
                    if (tempHairSize > 0) {
                        this.DisplayCfg.VIEW_HEIGHT += tempHairSize;
                        this.DisplayCfg.CONTENT_HEIGHT += tempHairSize;
                        this.DisplayCfg.CONTEN_IN_VIEW_TOP += tempHairSize;
                    }
                }
            }
            if (!this.DisplayCfg.IS_WEIXIN_GAME) {
                scaleAttr = `scale(${this.DisplayCfg.DEVICE_VIEW_SCALE},${this.DisplayCfg.DEVICE_VIEW_SCALE} )`;
                if (this.DisplayCfg.IS_ROTATE) {
                    const [left, top, width, height] = [
                        (this.DisplayCfg.DEVICE_HEIGHT - this.DisplayCfg.VIEW_WIDTH) / 2,
                        (this.DisplayCfg.DEVICE_WIDTH - this.DisplayCfg.VIEW_HEIGHT) / 2,
                        this.DisplayCfg.VIEW_WIDTH,
                        this.DisplayCfg.VIEW_HEIGHT
                    ];
                    baseAttr = `position: absolute;overflow: hidden;left:${left}px;top:${top}px;width:${width}px;height:${height}px;`;
                    rotationAttr = `rotate(90deg)`;
                }
                else {
                    const [left, top, width, height] = [
                        (this.DisplayCfg.DEVICE_WIDTH - this.DisplayCfg.VIEW_WIDTH) / 2,
                        (this.DisplayCfg.DEVICE_HEIGHT - this.DisplayCfg.VIEW_HEIGHT) / 2,
                        this.DisplayCfg.VIEW_WIDTH,
                        this.DisplayCfg.VIEW_HEIGHT
                    ];
                    baseAttr = `position: absolute;overflow: hidden;left:${left}px;top:${top}px;width:${width}px;height:${height}px;`;
                    rotationAttr = `rotate(0deg)`;
                }
                transformAttr = `-webkit-transform:${scaleAttr}${rotationAttr};-moz-transform:${scaleAttr}${rotationAttr};-ms-transform:${scaleAttr}${rotationAttr};transform:${scaleAttr}${rotationAttr};`;
                _CANVAS.parentElement && _CANVAS.parentElement.setAttribute('style', `${baseAttr}${transformAttr}`);
            }
            _CANVAS.width = this.DisplayCfg.VIEW_WIDTH;
            _CANVAS.height = this.DisplayCfg.VIEW_HEIGHT;
        }
    }
    exports.FormatCanvasDisplay = FormatCanvasDisplay;
    FormatCanvasDisplay.resizeListeners = [];
    FormatCanvasDisplay.DisplayCfg = {
        DEVICE_WIDTH: 0,
        DEVICE_HEIGHT: 0,
        VIEW_WIDTH: 0,
        VIEW_HEIGHT: 0,
        CONTEN_IN_VIEW_LEFT: 0,
        CONTEN_IN_VIEW_TOP: 0,
        CONTEN_IN_VIEW_WIDTH: 0,
        CONTEN_IN_VIEW_HEIGHT: 0,
        CONTENT_WIDTH: 0,
        CONTENT_HEIGHT: 0,
        DESIGN_VIEW_WIDTH: 0,
        DESIGN_VIEW_HEIGHT: 0,
        DEVICE_VIEW_SCALE: 0,
        IS_WEIXIN_GAME: false,
        IS_ROTATE: false
    };
});

/**
 * 项目事件预处理
 * * 主 canvas 添加事件监听
 * * 此处响应主canvas事件，并向各监听器分发
 * * 其他渲染内容的事件需在此注册监听
 */
_$pi.define("pi_gui/gui/gui_root/format_event", ["require", "exports", "./format_canvas_display"], function (require, exports, format_canvas_display_1) {
    "use strict";
    
    // tslint:disable-next-line:no-unnecessary-class
    class FormatEvent {
        static format(canvas) {
            FormatEvent.canvas = canvas;
            canvas.addEventListener(`pointermove`, FormatEvent.move);
            canvas.addEventListener(`pointerdown`, FormatEvent.down, false);
            window.addEventListener(`pointerup`, FormatEvent.up, false);
            try {
                canvas.addEventListener(`wheel`, this.wheel, false);
            }
            catch (_a) {
                //
            }
            document.body.addEventListener(`touchmove`, (event) => {
                if (event.view)
                    return;
                event.preventDefault();
            }, { passive: false });
            // 屏蔽浏览器环境菜单
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }
        static addDownListener(f) {
            if (this.downListener.indexOf(f) < 0) {
                this.downListener.push(f);
            }
        }
        static addUpListener(f) {
            if (this.upListener.indexOf(f) < 0) {
                this.upListener.push(f);
            }
        }
        static addMoveListener(f) {
            if (this.moveListener.indexOf(f) < 0) {
                this.moveListener.push(f);
            }
        }
        static addWheelListener(f) {
            if (this.wheelListener.indexOf(f) < 0) {
                this.wheelListener.push(f);
            }
        }
        static translatePoint(x, y) {
            if (format_canvas_display_1.FormatCanvasDisplay.getIsRotate()) {
                [x, y] = [y, format_canvas_display_1.FormatCanvasDisplay.getDeviceHeight() - x];
            }
            x /= format_canvas_display_1.FormatCanvasDisplay.getDeviceViewScale();
            y /= format_canvas_display_1.FormatCanvasDisplay.getDeviceViewScale();
            return [x, y];
        }
        /**
         * 修改 事件 (Tese 01)
         * @param evt 原事件
         */
        static formatTransEvent_(evt) {
            const e = {};
            [e.clientX, e.clientY] = this.translatePoint(evt.clientX, evt.clientY);
            // 握住原生事件
            FormatEvent.recordEventAttr(evt, e);
            return e;
        }
        /**
         * 复制事件信息
         * @param evt 原事件
         * @param e 新事件
         */
        static recordEventAttr(evt, e) {
            this.attrList.forEach(key => {
                e[key] = evt[key];
            });
            this.funcList.forEach(key => {
                e[key] = () => {
                    evt[key]();
                };
            });
        }
    }
    exports.FormatEvent = FormatEvent;
    FormatEvent.downListener = [];
    FormatEvent.upListener = [];
    FormatEvent.moveListener = [];
    FormatEvent.wheelListener = [];
    // canvas 事件属性列表 - ( 搜索 babylon.max.js )
    FormatEvent.attrList = ['type', 'pointerId', 'button', 'pointerType', 'target', 'srcElement', 'isPrimary',
        'movementX', 'mozMovementX', 'webkitMovementX', 'msMovementX',
        'movementY', 'mozMovementY', 'webkitMovementY', 'msMovementY',
        'keyCode', 'ctrlKey', 'deltaX', 'deltaY', 'deltaMode',
        'sourceEvent', 'gamepad', 'alpha', 'beta', 'gamma'
    ];
    // canvas 事件方法属性列表 - ( 搜索 babylon.max.js )
    FormatEvent.funcList = ['preventDefault'];
    FormatEvent.down = (ev) => {
        try {
            const evt = FormatEvent.formatTransEvent_(ev);
            // evt.pointerId = FormatEvent._totalPointersPressed;
            FormatEvent.downListener.forEach(f => {
                f(evt);
            });
        }
        catch (e) {
            // alert(e);
        }
        ev.preventDefault();
    };
    FormatEvent.up = (ev) => {
        try {
            const evt = FormatEvent.formatTransEvent_(ev);
            // 
            FormatEvent.upListener.forEach(f => {
                f(evt);
            });
        }
        catch (e) {
            // alert(e);
        }
        ev.preventDefault();
    };
    FormatEvent.move = (ev) => {
        try {
            const evt = FormatEvent.formatTransEvent_(ev);
            // 
            FormatEvent.moveListener.forEach(f => {
                f(evt);
            });
        }
        catch (e) {
            // alert(e);
        }
        ev.preventDefault();
    };
    FormatEvent.wheel = (ev) => {
        try {
            const evt = FormatEvent.formatTransEvent_(ev);
            // 
            FormatEvent.wheelListener.forEach(f => {
                f(evt);
            });
        }
        catch (e) {
            // alert(e);
        }
        ev.preventDefault();
    };
    let div;
    const log = (arg) => {
        if (!div) {
            div = document.createElement('div');
            document.body.appendChild(div);
            div.style.cssText = 'position:absolute;color:#ff0;top: 200px;z-index:-100;';
        }
        div.innerText = typeof arg === 'string' ? arg : JSON.stringify(arg);
    };
});

_$pi.define("pi_gui/gui/gui_virtual/virtual_attr", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 虚拟节点 attr属性集
     * * 虚拟节点 attr 数据 键
     */
    // TODO ra
    class VirtualAttr {
    }
    exports.VirtualAttr = VirtualAttr;
    exports.equalAttr = (owner, other) => {
        if (owner.equal && other.equal) {
            return owner.equal(other);
        }
        else {
            return owner === other;
        }
    };
});

_$pi.define("pi_gui/gui/gui_virtual/virtual_style", ["require", "exports", "../gui/enum", "../gui/tools"], function (require, exports, REnum, tools_1) {
    "use strict";
    
    /**
     * 虚拟节点样式
     * * 编译 tpl 时，虚拟节点style数据 键 的集合
     */
    class VirtualStyle {
        constructor(arr) {
            const len = arr.length / 2;
            for (let i = 0; i < len; i++) {
                this[arr[i * 2]] = arr[i * 2 + 1];
            }
        }
    }
    exports.VirtualStyle = VirtualStyle;
    /**
     * 长度数据
     * * 单位
     * * 值
     * * 两个数据相等检查
     * * 数据从 字符串 设置
     * * 读取 返回字符串
     */
    class LengthData {
        // tslint:disable-next-line:variable-name
        constructor(_type, _value) {
            this._type = _type;
            this.value = _value;
        }
        init(data) {
            // tslint:disable-next-line:variable-name
            const [_t, _d] = tools_1.Tools.lengthData(data);
            this._type = _t;
            this.value = _d;
        }
        equal(other) {
            return this.read() === other.read();
        }
        read() {
            if (this._parmas === undefined) {
                this._parmas = this._type === REnum.LengthUnitType.Pixel
                    ? `${this.value}px`
                    : `${this.value}%`;
            }
            return this._parmas;
        }
        copy() {
            const other = new LengthData();
            other.value = this.value;
            other._type = this._type;
            other._parmas = this._parmas;
        }
    }
    exports.LengthData = LengthData;
    /**
     * 2d 矩阵变换参数
     */
    class MatrixData {
        init(data) {
            this._parmas = data;
            this.value = [];
            data.split(',').forEach(v => {
                this.value.push(v - 0);
            });
        }
        equal(other) {
            return this.read() === other.read();
        }
        read() {
            if (this._parmas === undefined) {
                this._parmas = this.value.join(',');
            }
            return this._parmas;
        }
        copy() {
            const other = new MatrixData();
            other.value = this.value;
            other._parmas = this._parmas;
            other.value.length = 0;
            this.value.forEach(v => {
                other.value.push[v];
            });
        }
    }
    exports.MatrixData = MatrixData;
    /**
     * 3d 矩阵变换参数
     */
    // tslint:disable-next-line:max-classes-per-file
    class Matrix3DData extends MatrixData {
    }
    exports.Matrix3DData = Matrix3DData;
});

_$pi.define("pi_gui/gui/gui_root/root.tpl", ["require", "exports", "../../../pi_sys/modules/util/hash", "../gui_compile/style", "../gui_virtual/tpl"], function (require, exports, _hash, style_1, tpl_1) {
    "use strict";
    
    const _path = 'pi_gui/gui/gui_root/root.tpl';
    const _a = tpl_1.convertEntity;
    const _b = tpl_1.calAttrHash;
    const _c = tpl_1.calTextHash;
    const _e = tpl_1.addJson;
    const _f = tpl_1.installText;
    const _g = tpl_1.addText;
    const _h = tpl_1.chFunc;
    const _i = tpl_1.calNodeHash;
    const _d = tpl_1.calJsonHash;
    const _j = _hash.nextHash;
    const _s = style_1.styleStr2Json;
    exports.tpl = (function (_cfg, it, it1) {
        let $t, $n;
        it = it || {};
        $t = $n;
        {
            let $p = $t;
            let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 0, "cd": [], cH: 3379426035 };
            $n["aS"] = 1;
            $n["eS"] = 7;
            $n["aH"] = 3425673359;
            $n["a"]["isSendNextLayer"] = '1';
            $n["e"]["pointerdown"] = "down(e)";
            $n["eH"] = _j($n["eH"], 3508812620);
            $n["e"]["pointerup"] = "up(e)";
            $n["eH"] = _j($n["eH"], 126180397);
            $n["e"]["pointermove"] = "move(e)";
            $n["eH"] = _j($n["eH"], 2594484068);
            $n["e"]["pointerclick"] = "click(e)";
            $n["eH"] = _j($n["eH"], 1363209962);
            $n["e"]["multipointer"] = 'multipointer(e)';
            $n["eH"] = _j($n["eH"], 740533614);
            $n["e"]["longTap"] = 'longtap(e)';
            $n["eH"] = _j($n["eH"], 3448387871);
            $n["e"]["dbclick"] = 'dbclick(e)';
            $n["eH"] = _j($n["eH"], 3731611838);
            {
                $n["s"] = { "e8": [1, 100], "y": [1, 100] };
                $n["sH"] = 1263185136;
                $n["sS"] = 2;
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 1, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 2929678473;
                $n["a"]["group"] = "background";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 0 };
                    $n["sH"] = 3060056506;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 2, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 543452277;
                $n["a"]["group"] = "scene";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 1 };
                    $n["sH"] = 1722922003;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 3, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 3651540586;
                $n["a"]["group"] = "main";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 2 };
                    $n["sH"] = 3276755136;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 4, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 2094063237;
                $n["a"]["group"] = "guide_scene";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 3 };
                    $n["sH"] = 3470218024;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 5, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 805804775;
                $n["a"]["group"] = "secondary";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 4 };
                    $n["sH"] = 2763516976;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 6, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 385192588;
                $n["a"]["group"] = "top";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 6 };
                    $n["sH"] = 77223357;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 7, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 710418807;
                $n["a"]["group"] = "login";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 7 };
                    $n["sH"] = 2116958220;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 8, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 3612655069;
                $n["a"]["group"] = "cover";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 8, "e": [0, 0, 0, 0.7] };
                    $n["sH"] = 2189221361;
                    $n["sS"] = 5;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 9, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 70967002;
                $n["a"]["group"] = "cover_pop";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 10 };
                    $n["sH"] = 3782639064;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 10, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 3260678109;
                $n["a"]["group"] = "top_tip";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 11 };
                    $n["sH"] = 3841252331;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 11, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 3132725020;
                $n["a"]["group"] = "guide";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 12 };
                    $n["sH"] = 3464055425;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 12, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 1264627444;
                $n["a"]["group"] = "pop_tip";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 13, "f3": 1 };
                    $n["sH"] = 378447084;
                    $n["sS"] = 5;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 13, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 3415309588;
                $n["a"]["group"] = "screen";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 14, "f3": 1 };
                    $n["sH"] = 373045586;
                    $n["sS"] = 5;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 14, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 1995834431;
                $n["a"]["group"] = "download";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [0, 0], "f0": 16 };
                    $n["sH"] = 3164169405;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 15, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 3429696655;
                $n["a"]["group"] = "connect";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 22, "f3": 1 };
                    $n["sH"] = 2204775287;
                    $n["sS"] = 5;
                }
                _i($n);
                $p["cd"].push($n);
            }
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 16, "cd": [], cH: 2946814719 };
                $n["aS"] = 1;
                $n["aH"] = 4209236228;
                $n["a"]["group"] = "offLine";
                {
                    $n["s"] = { "c5": 1, "y": [1, 100], "e8": [1, 100], "f0": 26 };
                    $n["sH"] = 1565842935;
                    $n["sS"] = 4;
                }
                _i($n);
                $p["cd"].push($n);
            }
            _i($n);
            return $n;
        }
    });
});

_$pi.define("pi_gui/gui/gui_ui/combineImage/img.tpl", ["require", "exports", "../../../../pi_sys/modules/util/hash", "../../gui_compile/style", "../../gui_virtual/tpl"], function (require, exports, _hash, style_1, tpl_1) {
    "use strict";
    
    const _path = 'pi_gui/gui/gui_ui/combineImage/img.tpl';
    const _a = tpl_1.convertEntity;
    const _b = tpl_1.calAttrHash;
    const _c = tpl_1.calTextHash;
    const _e = tpl_1.addJson;
    const _f = tpl_1.installText;
    const _g = tpl_1.addText;
    const _h = tpl_1.chFunc;
    const _i = tpl_1.calNodeHash;
    const _d = tpl_1.calJsonHash;
    const _j = _hash.nextHash;
    const _s = style_1.styleStr2Json;
    exports.tpl = (function (_cfg, it, it1) { let $t, $n; it = it || {}; $t = $n; {
        let $p = $t;
        let $n = { "a": {}, "e": {}, "eH": 0, "tg": "img", "si": 0, "cd": [] };
        $n["aS"] = 2;
        $n["aH"] = 3938285257;
        {
            let attrvalue = "";
            attrvalue += it.src;
            attrvalue += "";
            $n["a"]["src"] = attrvalue;
        }
        $n["aH"] = _j($n["aH"], _c($n["a"]["src"]));
        {
            let attrvalue = "";
            attrvalue += it.imageClip;
            attrvalue += "";
            $n["a"]["imageClip"] = attrvalue;
        }
        $n["aH"] = _j($n["aH"], _c($n["a"]["imageClip"]));
        _i($n);
        _h($n);
        return $n;
    } });
});

_$pi.define("pi_gui/gui/gui_virtual/virtual_event", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 虚拟节点事件属性
     * * PointerEvent
     * * 封装事件: 长按，双击
     */
    class VirtualEvent {
    }
    exports.VirtualEvent = VirtualEvent;
});

/*
 * html模块
 */
_$pi.define("pi_gui/widget/html", ["require", "exports", "../../pi_sys/modules/util/hash"], function (require, exports, hash_1) {
    "use strict";
    
    // ============================== 导出
    /**
     * @description 浏览器网络类型
     * @example
     */
    exports.ConnectionType = [
        'unknown',
        'ethernet',
        'wifi',
        '2g',
        '3g',
        '4g',
        'none',
        'other'
    ];
    /**
     * @description 获取浏览器网络类型
     * @example
     */
    exports.getConnectionType = () => {
        const nav = window.navigator;
        const connection = nav.connection || nav.mozConnection || nav.webkitConnection;
        return connection ? connection.type : 7;
    };
    /**
     * @description 获得指定节点元素相对根元素的坐标
     * @param  el 指定元素
     * @param  root 根元素
     * @param  pos 位置
     * @return pos或undefined
     */
    exports.offsetPos = (el, root, pos) => {
        while (el) {
            pos.x += el.offsetLeft;
            pos.y += el.offsetTop;
            el = el.offsetParent;
            if (el === root) {
                return pos;
            }
        }
    };
    /**
     * @description 获得指定元素的样式
     * @param  el 指定元素
     */
    exports.getStyle = (el) => {
        if (window.getComputedStyle) {
            return window.getComputedStyle(el);
        }
        // if (el.currentStyle) //IE
        // return el.currentStyle[cssProp];
        // finally try and get inline style
        return el.style;
    };
    /**
     * @description 设置Cookie
     * @param name 必选项，cookie名称
     * @param value 必选项，cookie值
     * @param seconds 生存时间，可选项，单位：秒；默认时间是315360000秒（10年）。false表示生存期为浏览器关闭后
     * @param path cookie存放路径，可选项
     * @param domain cookie域，可选项
     * @param secure 安全性，指定Cookie是否只能通过https协议访问，一般的Cookie使用HTTP协议既可访问，如果设置了Secure（没有值），则只有当使用https协议连接时cookie才可以被页面访问
     * @example
     */
    exports.setCookie = (name, value, seconds, path, domain, secure) => {
        let expires;
        if (!navigator.cookieEnabled) {
            throw new Error('sorry! cookie can\'t use!');
        }
        if (seconds !== undefined) {
            expires = new Date();
            seconds = seconds || 315360000;
            expires.setTime(expires.getTime() + seconds * 1000);
        }
        // tslint:disable:prefer-template
        document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) +
            (expires ? ';expires=' + expires.toUTCString() : '') + (path ? ';path=' + path : '/') +
            (domain ? ';domain=' + domain : '') + (secure ? ';secure' : '');
    };
    /**
     * @description 清除所有Cookie
     * @example
     */
    exports.clearCookie = () => {
        let i;
        const zero = '=0;expires=Thu, 01 Jan 1970 00:00:00 GMT';
        const keys = document.cookie.match(/[^ =;]+(?=\=)/g) || [];
        for (i = keys.length - 1; i >= 0; i--) {
            document.cookie = keys[i] + zero;
        }
    };
    /**
     * @description 获取Cookie，name为cookie名称
     * @example
     */
    exports.getCookie = (name) => {
        let str;
        let start;
        let end;
        name = decodeURIComponent(name);
        str = document.cookie;
        start = str.indexOf(name);
        if (start >= 0) {
            end = str.indexOf(';', start);
            return decodeURIComponent(str.substring(start + name.length + 1, (end > start ? end : str.length)));
        }
    };
    /**
     * @description 删除或清空Cookie，name为cookie名称
     * @example
     */
    exports.delCookie = (name) => {
        document.cookie = encodeURIComponent(name) + '=0;expires=Thu, 01 Jan 1970 00:00:00 GMT';
    };
    /**
     * @description 指纹识别
     * @example
     */
    exports.fingerPrint = () => {
        const win = window;
        const nav = window.navigator;
        const keys = [];
        keys.push(nav.userAgent);
        keys.push(nav.language);
        keys.push(screen.colorDepth);
        keys.push((screen.height > screen.width) ? [screen.height + 'x' + screen.width] : [screen.width + 'x' + screen.height]);
        keys.push(new Date().getTimezoneOffset());
        // SecurityError when referencing it means it exists
        keys.push(!!win.sessionStorage);
        keys.push(!!win.localStorage);
        keys.push(!!win.indexedDB);
        keys.push(typeof (win.openDatabase));
        keys.push(nav.cpuClass);
        keys.push(nav.platform);
        keys.push(nav.doNotTrack);
        return hash_1.murmurhash3_32s(keys.join('###'), 0);
    };
    /**
     * @description canvas指纹识别
     * @example
     */
    exports.canvasFingerPrint = () => {
        const text = '0123456789_abcdefghijklmnopqrstuvwxwz';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px \'Arial\'';
        ctx.fillStyle = '#f60';
        ctx.fillRect(1, 1, 100, 20);
        ctx.fillStyle = '#069';
        ctx.fillText(text, 2, 2);
        ctx.strokeStyle = 'rgba(102, 204, 0, 0.7)';
        ctx.strokeText(text, 2, 17);
        return canvas.toDataURL().slice('data:image/png;base64,'.length);
    };
    /**
     * @description 获得浏览器的userAgent
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    exports.userAgent = (r) => {
        const ua = navigator.userAgent.toLowerCase();
        r = r || {};
        const nameVersion = (obj, name, rxp) => {
            const arr = ua.match(rxp);
            if (!arr) {
                return;
            }
            obj.version = arr[1];
            obj.name = name;
            return true;
        };
        const cfg = {
            chrome: null,
            msie: 'ie',
            firefox: null,
            opr: 'opera',
            micromessenger: null,
            mqqbrowser: null,
            ucbrowser: null
        };
        // 解析ua中的browser信息
        r.browser = { name: 'unknown', version: '0.0' };
        if (ua.indexOf('safari') > -1) {
            if (ua.indexOf('mobile') > -1) {
                if (nameVersion(r.browser, 'safari', /version\/([\d.]+)/)) {
                    r.browser.safari = r.browser.version;
                }
            }
            else {
                if (nameVersion(r.browser, 'safari', /safari\/([\d.]+)/)) {
                    r.browser.safari = r.browser.version;
                }
            }
        }
        for (const k in cfg) {
            if (!cfg.hasOwnProperty(k)) {
                continue;
            }
            const i = ua.indexOf(k);
            if (i < 0) {
                continue;
            }
            let name = cfg[k];
            name = name || k;
            if (nameVersion(r.browser, name, new RegExp(k + '\/([\\d.]+)'))) {
                r.browser[name] = r.browser.version;
            }
        }
        // 解析ua中的engine信息
        r.engine = { name: 'unknown', version: '0.0' };
        if (ua.indexOf('trident') > -1) {
            nameVersion(r.engine, 'trident', /trident\/([\d.]+)/);
        }
        else if (ua.indexOf('applewebkit') > -1) {
            nameVersion(r.engine, 'webkit', /applewebkit\/([\d.]+)/);
        }
        else if (ua.indexOf('gecko') > -1) {
            nameVersion(r.engine, 'gecko', /gecko\/([\d.]+)/);
        }
        // 解析ua中的os信息
        r.os = r.os || { name: 'unknown', version: '0.0' };
        if (ua.indexOf('windows nt') > -1) {
            nameVersion(r.os, 'windows', /windows nt ([\d.]+)/);
            if (r.os.version === '6.1') {
                r.os.version = '7';
            }
            else if (r.os.version === '6.2') {
                r.os.version = '8';
            }
        }
        else if (ua.indexOf('iphone os') > -1) {
            nameVersion(r.os, 'ios', /iphone os ([\d_]+)/);
            r.os.version = r.os.version.split('_').join('.');
        }
        else if (ua.indexOf('android') > -1) {
            nameVersion(r.os, 'android', /android ([\d.]+)/);
        }
        r.screen = { colorDepth: screen.colorDepth };
        if (screen.height > screen.width) {
            r.screen.height = screen.height;
            r.screen.width = screen.width;
        }
        else {
            r.screen.height = screen.width;
            r.screen.width = screen.height;
        }
        r.timezone_offset = new Date().getTimezoneOffset();
        r.language = navigator.language;
        r.device = { type: (ua.indexOf('mobile') > -1) ? 'mobile' : 'pc', platform: navigator.platform };
        // 标签化
        if (r.mobile === undefined) {
            r.mobile = r.device.type === 'mobile';
        }
        return r;
    };
    /**
     * @description 创建css节点
     * @example
     */
    exports.addCssNode = (str) => {
        const node = document.createElement('style');
        node.type = 'text/css';
        try {
            node.appendChild(document.createTextNode(str));
        }
        catch (ex) {
            // ie
            node.styleSheet.cssText = str;
        }
        document.head.appendChild(node);
        return node;
    };
    /**
     * @description 创建css节点
     * @example
     */
    exports.loadCssNode = (url, callback) => {
        const node = document.createElement('link');
        node.charset = 'utf8';
        node.rel = 'stylesheet';
        node.href = url;
        node.onerror = () => {
            node.onload = node.onerror = undefined;
            document.head.removeChild(node);
            callback && callback(node);
        };
        node.onload = () => {
            node.onload = node.onerror = undefined;
            callback && callback(node);
        };
        document.head.appendChild(node);
        return node;
    };
    /**
     * @description 检查webp的兼容性
     * @example
     */
    exports.checkWebpFeature = (cb) => {
        // webp特性支持
        const webpFeature = {};
        let c = 0;
        // webp测试图片
        const webpTestImages = {
            lossy: 'UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA',
            lossless: 'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==',
            alpha: 'UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==',
            // tslint:disable-next-line:max-line-length
            animation: 'UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA'
        };
        const check = (feature) => {
            const img = new Image();
            img.onload = () => {
                webpFeature[feature] = (img.width > 0) && (img.height > 0);
                if (!(--c)) {
                    cb(webpFeature);
                }
            };
            img.onerror = () => {
                webpFeature[feature] = false;
                if (!(--c)) {
                    cb(webpFeature);
                }
            };
            img.src = 'data:image/webp;base64,' + webpTestImages[feature];
            c++;
        };
        for (const k in webpTestImages) {
            if (webpTestImages.hasOwnProperty(k)) {
                check(k);
            }
        }
    };
    /**
     * @description 获得兼容支持的属性名称，返回""表示该属性名称不支持
     * @example
     * 只支持class
     */
    exports.getSupportedProperty = (property) => {
        let p = propertySupportedMap.get(property);
        if (p !== undefined) {
            return p;
        }
        p = property.replace(propertyUpperRxp, propertyUpperFunc);
        if (p in bodyStyle) {
            propertySupportedMap.set(property, p);
            return p;
        }
        const s = p;
        for (const prefix of propertyPrefixes) {
            p = prefix + s;
            if (p in bodyStyle) {
                propertySupportedMap.set(property, p);
                return p;
            }
        }
        propertySupportedMap.set(property, '');
        return '';
    };
    /**
     * @description 获得指定类名的css动画的持续时间，单位为毫秒
     * @example
     */
    exports.getAniDuration = (className) => {
        if (!aniDurationMap) {
            aniDurationMap = new Map();
            const arr = document.styleSheets;
            for (let sheet, rules, i = arr.length - 1; i >= 0; i--) {
                sheet = arr[i];
                rules = sheet && sheet.cssRules;
                if (!rules) {
                    continue;
                }
                for (let rule, r, t, j = rules.length - 1; j >= 0; j--) {
                    rule = rules[i];
                    r = durationRxp.exec(rule.cssText);
                    if (!r) {
                        continue;
                    }
                    t = parseDuration(r[1]);
                    r = classRxp.exec(rule.selectorText);
                    while (r) {
                        aniDurationMap.set(r[1], t);
                        classRxp.exec(rule.selectorText);
                    }
                }
            }
        }
        const clazz = className.split(' ');
        for (let t, i = clazz.length - 1; i >= 0; i--) {
            t = aniDurationMap.get(clazz[i]);
            if (t !== undefined) {
                return t;
            }
        }
    };
    // ============================== 本地
    // 样式兼容支持
    const propertySupportedMap = new Map();
    const bodyStyle = document.body.style;
    const propertyPrefixes = ['khtml', 'o', 'ms', 'moz', 'webkit'];
    const propertyUpperRxp = /(-)([a-z])/g;
    const propertyUpperFunc = (matchStr, match1, match2, loc, srcStr) => {
        return match2.toUpperCase();
    };
    // 动画时间表
    let aniDurationMap = null;
    const durationRxp = /\-duration\s:\s*(\d+m?)s/i;
    const classRxp = /\.([_a-zA-Z0-9\-]+)/g;
    // 分析持续时间的字符串，返回毫秒数
    const parseDuration = (s) => {
        const len = s.length - 1;
        if (s.charCodeAt(len) === 109 || s.charCodeAt(len) === 77) {
            return parseInt(s, 10) * 1000;
        }
        return (parseFloat(s) * 1000) | 0;
    };
});
// ============================== 立即执行

/**
 * 事件处理模块
 * 提供在节点的事件上直接声明简单函数调用，简单函数还可以是抛出自定义事件的$notify函数
 * 将5种手势事件（单击tap、双击dbltap、长按longtap、移动move(挥swipe)、旋转缩放rotsal(rotote scale)）代码集成进来，作为引擎提供的本地事件，检测平台，模拟缺失平台的事件
 * 挥的判断是：touchend离开时间减去最后一次touchmove移动时间小于规定的值，并且最后一次移动的速度超过规定的速度
 *
 * 事件支持直接调用widget组件上的方法，和notify方法。
 * 如果是简单字符串就认为是无参数方法。
 * @example <app-ui-btn on-tap=select>"g2"</app-ui-btn>
 * 如果是方法调用，支持参数中使用事件e, 及e的域。
 * @example <app-ui-btn on-tap="select({{v.id}}, 1, e.x, e.y)">"g2"</app-ui-btn>
 * 如果是$notify，支持直接抛出自定义的事件。
 * @example <app-ui-btn on-tap='$notify("ev-brand-btn-select", { "id":{{v.id}}, "x":e.x, "y":e.y})'>"g2"</app-ui-btn>
 */
_$pi.define("pi_gui/gui/gui_virtual/event", ["require", "exports", "../../../pi_sys/modules/util/event", "../../../pi_sys/modules/math/math", "../../../pi_sys/setup/env", "../../../pi_sys/modules/util/util", "./virtaul_node_keyword"], function (require, exports, event_1, math_1, env, util_1, virtaul_node_keyword_1) {
    "use strict";
    
    // ============================== 导出
    exports.USER_EVENT_PRE = 'ev-';
    exports.BUBBLE_EVENT_PRE = 'on-';
    exports.CAPTURE_EVENT_PRE = 'cap-';
    /**
     * @description tap事件默认的间隔时间
     */
    exports.TapInterval = 300;
    /**
     * @description tap事件默认是否停止广播
     */
    exports.TapStopPropagation = true;
    /**
     * @description 5种手势事件的移动距离限制
     */
    exports.MoveLimit = 15;
    /**
     * @description 单击的时间值，毫秒
     */
    exports.TapTime = 600;
    /**
     * @description 双击的时间值，毫秒
     */
    exports.DblTapTime = 600;
    /**
     * @description 长按的时间值，毫秒
     */
    exports.LongTapTime = 800;
    /**
     * @description 挥的速度的平方，px/秒
     */
    exports.SwipeSpeed = 300 * 300;
    /**
     * @description 挥的最后停顿时间（touchend离开时间减去最后一次touchmove移动时间），必须小于该时间才认为是挥动
     */
    exports.SwipeTime = 100;
    /**
     * @description 获得事件类型， 只能是ev- on- cap-
     * @example
     */
    exports.getEventType = (key) => {
        const c = key.charCodeAt(0);
        if (c === 101 && key.startsWith(exports.USER_EVENT_PRE)) {
            return exports.USER_EVENT_PRE;
        }
        else if (c === 111 && key.startsWith(exports.BUBBLE_EVENT_PRE)) {
            return exports.BUBBLE_EVENT_PRE;
        }
        else if (c === 99 && key.startsWith(exports.CAPTURE_EVENT_PRE)) {
            return exports.CAPTURE_EVENT_PRE;
        }
    };
    /**
     * @description 获得用户事件监听器
     * @example
     */
    // tslint:disable:no-reserved-keywords
    exports.getUserEventListener = (key, value) => {
        return getFunction(value);
    };
    /**
     * @description 获得本地事件监听器
     * @example
     */
    exports.getNativeEventListener = (key, value) => {
        return getNativeFunction(getFunction(value));
    };
    /**
     * @description 重绑定节点事件表
     * @example
     */
    exports.rebindEventMap = (oldNode, newNode) => {
        if (!oldNode.ext) {
            return;
        }
        const map = oldNode.ext.nativeEventMap;
        if (map) {
            for (const v of map.values()) {
                v.handler.vnode = newNode;
            }
        }
    };
    /**
     * @description 添加用户事件监听器，没有Handler表示删除用户事件监听器
     * @example
     */
    exports.addUserEventListener = (node, key, type, value) => {
        let map = node.ext.eventMap;
        if (!map) {
            node.ext.eventMap = map = new Map();
        }
        if (value) {
            map.set(type, exports.getUserEventListener(type, value));
        }
        else {
            map.delete(type);
        }
    };
    /**
     * @description 添加本地事件监听器，没有Handler表示删除本地事件监听器
     * @example
     */
    exports.addNativeEventListener = (node, realNode, key, type, value) => {
        const isCap = type === exports.CAPTURE_EVENT_PRE;
        let map = node.ext.nativeEventMap;
        if (!map) {
            node.ext.nativeEventMap = map = new Map();
        }
        else {
            const old = map.get(key);
            if (old) {
                if (key === 'cap-hashchange') {
                    window.removeEventListener('hashchange', old.listener, false);
                }
                else {
                    realNode.removeEventListener(old.type, old.listener, isCap);
                    const arr = old.types;
                    if (arr) {
                        for (const t of arr) {
                            realNode.removeEventListener(t.type, t.listener, isCap);
                        }
                    }
                }
            }
        }
        if (!value) {
            return;
        }
        const h = exports.getNativeEventListener(key, value);
        // 在监听器上绑定虚拟节点，这样不使用闭包来获得虚拟节点
        h.vnode = node;
        const bind = eventBind(realNode, h, getEventName(key, type));
        map.set(key, bind);
        // hashchange事件是一个只能绑定在body上的事件，要特殊处理,使得他能向下传递，其他事件都是可以向上传递的
        if (key === 'cap-hashchange') {
            window.addEventListener('hashchange', h, false);
        }
        else {
            realNode.addEventListener(bind.type, bind.listener, isCap); // { passive: true, capture: isCap } TODO
            const arr = bind.listeners;
            if (arr) {
                for (const t of arr) {
                    realNode.addEventListener(t.type, t.listener, isCap); // { passive: true, capture: isCap }
                }
            }
        }
    };
    /**
     * @description 添加本地事件监听器，没有Handler表示删除本地事件监听器
     * @example
     */
    exports.addNativeEventListener2 = (node, realNode, key, type, value) => {
        const isCap = type === exports.CAPTURE_EVENT_PRE;
        let map = node.ext.nativeEventMap;
        if (!map) {
            node.ext.nativeEventMap = map = new Map();
        }
        else {
            const old = map.get(key);
            if (old) {
                if (key === 'cap-hashchange') {
                    window.removeEventListener('hashchange', old.listener, false);
                }
                else {
                    realNode.removeEventListener(old.type, old.listener);
                    const arr = old.types;
                    if (arr) {
                        for (const t of arr) {
                            realNode.removeEventListener(t.type, t.listener);
                        }
                    }
                }
            }
        }
        if (!value) {
            return;
        }
        const h = exports.getNativeEventListener(key, value);
        // 在监听器上绑定虚拟节点，这样不使用闭包来获得虚拟节点
        h.vnode = node;
        const bind = eventBind2(realNode, h, type);
        map.set(key, bind);
        // hashchange事件是一个只能绑定在body上的事件，要特殊处理,使得他能向下传递，其他事件都是可以向上传递的
        if (key === 'cap-hashchange') {
            window.addEventListener('hashchange', h, false);
        }
        else {
            realNode.addEventListener(bind.type, bind.listener); // { passive: true, capture: isCap } TODO
            const arr = bind.listeners;
            if (arr) {
                for (const t of arr) {
                    realNode.addEventListener(t.type, t.listener); // { passive: true, capture: isCap }
                }
            }
        }
    };
    /**
     * @description 沿节点树，通知节点上的事件监听器
     * @example
     */
    exports.notify = (node, eventType, e) => {
        // tslint:disable-next-line:prefer-const
        let listener;
        // tslint:disable-next-line:prefer-const
        let r;
        let set = false;
        if (e) {
            if (typeof e === 'object' || typeof e === 'function') {
                e.type = eventType;
                // e.srcNode为初始事件源，e.native为原生事件
                e.srcNode = node;
                // e.srcWidget为初始组件源
                e.srcWidget = node[virtaul_node_keyword_1.VNKeyWords.widget];
                set = true;
            }
        }
        else {
            e = { type: eventType, srcNode: node, srcWidget: node[virtaul_node_keyword_1.VNKeyWords.widget], node: null, widget: null };
        }
        while (node) {
            if (set) {
                // e.node为当前节点源
                e.node = node;
                e.widget = node[virtaul_node_keyword_1.VNKeyWords.widget];
            }
            const listener = node.ext ? (node.ext.eventMap ? node.ext.eventMap.get(eventType) : null) : null;
            if (listener) {
                const r = listener(e, node[virtaul_node_keyword_1.VNKeyWords.widget]);
                // tslint:disable-next-line:no-empty
                if (!r) {
                }
                else if (r === event_1.HandlerResult.BREAK_OK) {
                    return;
                }
            }
            node = (node[virtaul_node_keyword_1.VNKeyWords.parent]) ? node[virtaul_node_keyword_1.VNKeyWords.parent] : node[virtaul_node_keyword_1.VNKeyWords.widget].parentNode;
        }
    };
    // 全局事件函数的缓存
    const cacheMap = new Map();
    /**
     * @description 获得简单事件函数
     * @example
     */
    const getSampleFunction = (funName, args) => {
        return (e, w) => {
            let arr;
            if (args) {
                arr = args.arr;
                if (args.index >= 0) {
                    arr[args.index] = args.fields ? util_1.getValue(e, args.fields) : e;
                }
            }
            else {
                arr = [e];
            }
            if (funName === '$notify') {
                exports.notify(w.parentNode, arr[0], arr[1]);
                return event_1.HandlerResult.BREAK_OK;
            }
            const r = w.notify(funName, arr);
            if (r) {
                return r;
            }
            const f = w.forelet;
            if (!f) {
                return;
            }
            return f.notify(funName, arr);
        };
    };
    /**
     * @description 解析参数
     * @example
     */
    const parseArgs = (arg) => {
        arg = arg.replace(/'/g, '"');
        const len = arg.length;
        let attr;
        const findElemE = (arg, start) => {
            for (let i = start; i < len; i++) {
                if (arg[i] !== ' ') {
                    return (arg[i] === 'e') ? i : -1;
                }
            }
        };
        const findAttrOfE = (arg, start) => {
            if (arg[start] !== '.') {
                return;
            }
            let i = start + 1;
            for (; i < len; i++) {
                if (arg[i] === ' ' || arg[i] === ',') {
                    break;
                }
            }
            attr = arg.slice(start + 1, i);
        };
        const findStrEnd = (arg, start, closedChar) => {
            for (let i = start; i < len; i++) {
                if (arg[i] === closedChar) {
                    return i;
                }
            }
        };
        let j = findElemE(arg, 0);
        if (j < 0) {
            for (let c, i = 0; i < len; i++) {
                c = arg[i];
                if (c === '\'') {
                    i = findStrEnd(arg, i + 1, '\'');
                }
                else if (c === '"') {
                    i = findStrEnd(arg, i + 1, '"');
                }
                else if (c === ',') {
                    j = findElemE(arg, i + 1);
                    if (j !== -1) {
                        findAttrOfE(arg, j + 1);
                        break;
                    }
                }
            }
        }
        else {
            findAttrOfE(arg, j + 1);
        }
        if (j >= 0) {
            // tslint:disable:prefer-template
            arg = arg.substring(0, j) + '"$_"' + arg.substring(attr ? j + attr.length + 2 : j + 1, arg.length);
        }
        try {
            const r = JSON.parse('[' + arg + ']'); // 匹配字符串中的",e",将其替换成",'$_'"
            return { arr: r, index: r.indexOf('$_'), fields: attr };
        }
        catch (error) {
            throw new Error('parseArgs fail, args: ' + arg);
        }
    };
    /**
     * @description 获得事件函数
     * @example
     */
    const getFunction = (str) => {
        str = str.trim();
        // 字符串中存在(,解析字符串中的方法名和参数
        const index = str.indexOf('(');
        if (index > 0) {
            const funName = str.slice(0, index);
            return getSampleFunction(funName, parseArgs(str.slice(index + 1, str.length - 1)));
        }
        return getSampleFunction(str);
    };
    /**
     * @description 获得本地事件函数，从函数身上取到绑定的虚拟节点，添加到事件上
     * @example
     */
    const getNativeFunction = (h) => {
        // tslint:disable-next-line:no-unnecessary-local-variable
        const func = (e) => {
            const node = func.vnode;
            // const node: VirtualNodeBase = (<RElement>e.current).virtual;
            if (!node) {
                return;
            }
            let ext = node[virtaul_node_keyword_1.VNKeyWords.ext];
            if (!ext) {
                ext = node[virtaul_node_keyword_1.VNKeyWords.ext] = {};
            }
            if (!ext.eventAttr) {
                ext.eventAttr = {};
                ext.eventAttr[`${e.type}`] = { interval: e.type === 'pointerclick' ? exports.TapInterval : 0, stop: exports.TapStopPropagation, nextTime: 0 };
            }
            if (ext.eventAttr) {
                const cfg = ext.eventAttr[e.type];
                if (cfg) {
                    if (cfg.stop) {
                        // e.native ? e.native.stopPropagation() : e.stopPropagation();
                        e.stopPropagation = true;
                    }
                    if (cfg.prevent) {
                        // e.native ? e.native.preventDefault() : e.preventDefault();
                        e.preventDefault = true;
                    }
                    if (cfg.interval) {
                        if (cfg.nextTime && cfg.nextTime > e.timeStamp) {
                            return;
                        }
                        cfg.nextTime = e.timeStamp + cfg.interval;
                    }
                }
            }
            e.node = node;
            e.srcNode = node;
            e.widget = node[virtaul_node_keyword_1.VNKeyWords.widget];
            e.srcWidget = node[virtaul_node_keyword_1.VNKeyWords.widget];
            return h(e, node[virtaul_node_keyword_1.VNKeyWords.widget]);
        };
        return func;
    };
    /**
     * @description 获得原始的事件类型名
     * @example
     */
    const getEventName = (str, type) => {
        return str.slice(type.length);
    };
    /**
     * @description 事件绑定
     * @example
     */
    const eventBind = (el, h, name) => {
        const func = gesture[env.get("device") ? 0 : 1][name];
        return func ? func(el, h) : { type: name, name2: null, handler: h, listener: h };
    };
    /**
     * @description 事件绑定
     * @example
     */
    const eventBind2 = (el, h, name) => {
        // const func = gesture[commonjs.flags.mobile ? 0 : 1][name];
        return { type: name, handler: h, listener: h, listeners: null };
    };
    // 触控手势
    // 移动
    const touchMove = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let xx = 0;
        let yy = 0;
        let lasttime = 0;
        let lastx = 0;
        let lasty = 0;
        let state = -1;
        const fire = (e, type) => {
            h({
                type: 'move', subType: type, native: e, x: xx, y: yy,
                timeStamp: e.timeStamp, startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty
            });
        };
        const down = (e) => {
            if (e.touches.length > 1) {
                if (state > 0) {
                    cancel(e);
                }
                else if (state === 0) {
                    state = -1;
                }
                return;
            }
            state = 0;
            time = e.timeStamp;
            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
            lasttime = time;
            lastx = x;
            lasty = y;
            xx = x;
            yy = y;
        };
        const move = (e) => {
            if (state < 0) {
                return;
            }
            if (e.touches.length > 1) {
                return cancel(e);
            }
            lasttime = e.timeStamp;
            lastx = xx;
            lasty = yy;
            xx = e.touches[0].pageX;
            yy = e.touches[0].pageY;
            if (state > 0) {
                fire(e, 'keep');
            }
            else if (Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit) {
                state = 1;
                // 修正起始位置，去除移动开始时的跳动
                x = xx;
                y = yy;
                fire(e, 'start');
            }
        };
        const up = (e) => {
            if (state > 0) {
                const t = e.timeStamp - lasttime;
                h({
                    type: 'move', subType: 'over', native: e, x: xx, y: yy, timeStamp: e.timeStamp,
                    startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty,
                    swipe: (t < exports.SwipeTime) && ((lasty - xx) * (lasty - xx) + (lasty - yy) * (lasty - yy)) > exports.SwipeSpeed * t / 1000
                });
            }
            state = -1;
        };
        const cancel = (e) => {
            if (state > 0) {
                fire(e, 'cancel');
            }
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 单击
    const touchTap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let state = -1;
        const down = (e) => {
            if (e.touches.length > 1) {
                state = -1;
                return;
            }
            state = 1;
            time = e.timeStamp;
            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
        };
        const move = (e) => {
            const xx = e.touches[0].pageX;
            const yy = e.touches[0].pageY;
            if (state > 0 && (e.touches.length > 1 || Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit)) {
                state = -1;
            }
        };
        const up = (e) => {
            if (state > 0 && e.timeStamp < time + exports.TapTime) {
                h({ type: 'tap', native: e, x: x, y: y, timeStamp: e.timeStamp });
            }
            state = -1;
        };
        const cancel = (e) => {
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 双击
    const touchDbltap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let state = -1;
        const down = (e) => {
            if (e.touches.length > 1 || state === 0 || state > 1) {
                state = -1;
                return;
            }
            const t = e.timeStamp;
            const xx = e.touches[0].pageX;
            const yy = e.touches[0].pageY;
            if (state === 1 && (t > time + exports.DblTapTime || Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit)) {
                state = -1;
                return;
            }
            state++;
            time = t;
            x = xx;
            y = yy;
        };
        const move = (e) => {
            const xx = e.touches[0].pageX;
            const yy = e.touches[0].pageY;
            if (state > 0 && (e.touches.length > 1 || Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit)) {
                state = -1;
            }
        };
        const up = (e) => {
            if (state === 0 && e.timeStamp < time + exports.TapTime) {
                state = 1;
                time = e.timeStamp;
                return;
            }
            if (state === 2 && e.timeStamp < time + exports.TapTime) {
                h({ type: 'dbltap', native: e, x: x, y: y, timeStamp: e.timeStamp });
            }
            state = -1;
        };
        const cancel = (e) => {
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 抬起
    const touchUp = (el, h) => {
        const up = (e) => {
            h({ type: 'up', native: e, timeStamp: e.timeStamp });
        };
        return { type: 'touchend', listener: up, listeners: null, handler: h };
    };
    // 按下
    const touchDown = (el, h) => {
        const down = (e) => {
            h({ type: 'down', native: e, x: e.touches[0].pageX, y: e.touches[0].pageY, timeStamp: e.timeStamp });
        };
        return { type: 'touchstart', listener: down, listeners: null, handler: h };
    };
    // 长按
    const touchLongtap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let ref = 0;
        const down = (e) => {
            if (e.touches.length > 1) {
                return up(e);
            }
            ref && clearTimeout(ref);
            time = e.timeStamp;
            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
            ref = setTimeout(() => {
                ref = 0;
                h({ type: 'longtap', native: e, x: x, y: y, timeStamp: time + exports.LongTapTime, startTime: time });
            }, exports.LongTapTime);
        };
        const move = (e) => {
            if (ref && (e.touches.length > 1 || Math.abs(x - e.touches[0].pageX) > exports.MoveLimit || Math.abs(y - e.touches[0].pageY) > exports.MoveLimit)) {
                clearTimeout(ref);
                ref = 0;
            }
        };
        const up = (e) => {
            ref && clearTimeout(ref);
            ref = 0;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: up }], handler: h
        };
    };
    // 旋转 缩放
    // tslint:disable-next-line:max-func-body-length
    const touchRotsal = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let x1 = 0;
        let y1 = 0;
        let x2 = 0;
        let y2 = 0;
        let xx = 0;
        let yy = 0;
        let xx1 = 0;
        let yy1 = 0;
        let xx2 = 0;
        let yy2 = 0;
        let dist1 = 0;
        let dist2 = 0;
        let vx1 = 0;
        let vy1 = 0;
        let vx2 = 0;
        let vy2 = 0;
        let direction = 0;
        let angle = 0;
        let state = -1;
        const fire = (e, type) => {
            h({
                type: 'rotsal', subType: type, native: e, dist: dist2, scale: dist2 / dist1,
                direction: direction, angle: angle, timeStamp: e.timeStamp, startTime: time,
                x: xx, y: yy, x1: x1, y1: y2, x2: x2, y2: y2, xx1: xx1, yy1: yy1, xx2: xx2, yy2: yy2, startDist: dist1
            });
        };
        const down = (e) => {
            if (e.touches.length === 1) {
                if (state > 0) {
                    cancel(e);
                }
                else if (state === 0) {
                    state = -1;
                }
                return;
            }
            state = 0;
            time = e.timeStamp;
            x1 = e.touches[0].pageX;
            y1 = e.touches[0].pageY;
            x2 = e.touches[1].pageX;
            y2 = e.touches[1].pageY;
            x = (x1 + x2) / 2;
            y = (y1 + y2) / 2;
            vx1 = x1 - x2;
            vy1 = y1 - y2;
            dist1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
        };
        const move = (e) => {
            if (state < 0) {
                return;
            }
            if (e.touches.length === 1) {
                return cancel(e);
            }
            xx1 = e.touches[0].pageX;
            yy1 = e.touches[0].pageY;
            xx2 = e.touches[1].pageX;
            yy2 = e.touches[1].pageY;
            xx = (xx1 + xx2) / 2;
            yy = (yy1 + yy2) / 2;
            vx2 = xx1 - xx2;
            vy2 = yy1 - yy2;
            if (state > 0) {
                dist2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);
                direction = math_1.getDirection(vx1, vy1, vx2, vy2);
                angle = math_1.getAngle(vx1, vy1, vx2, vy2);
                fire(e, 'keep');
            }
            else {
                const dx1 = Math.abs(x1 - xx1);
                const dy1 = Math.abs(y1 - yy1);
                const dx2 = Math.abs(x2 - xx2);
                const dy2 = Math.abs(y2 - yy2);
                if (dx1 + dy1 + dx2 + dy2 > exports.MoveLimit) {
                    state = 1;
                    dist2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);
                    direction = math_1.getDirection(vx1, vy1, vx2, vy2);
                    angle = math_1.getAngle(vx1, vy1, vx2, vy2);
                    fire(e, 'start');
                }
            }
        };
        const up = (e) => {
            if (state > 0) {
                fire(e, 'over');
            }
            state = -1;
        };
        const cancel = (e) => {
            if (state > 0) {
                fire(e, 'cancel');
            }
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 鼠标手势
    // 移动
    const mouseMove = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let lasttime = 0;
        let lastx = 0;
        let lasty = 0;
        let state = -1;
        const fire = (e, type) => {
            h({
                type: 'move', subType: type, native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp,
                startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty
            });
        };
        const down = (e) => {
            state = 0;
            time = e.timeStamp;
            x = e.pageX;
            y = e.pageY;
            lasttime = time;
            lastx = x;
            lasty = y;
        };
        const move = (e) => {
            if (state > 0) {
                fire(e, 'keep');
                // tslint:disable-next-line:no-empty
            }
            else if (state < 0) {
            }
            else if (Math.abs(x - e.pageX) > exports.MoveLimit || Math.abs(y - e.pageY) > exports.MoveLimit) {
                state = 1;
                lasttime = e.timeStamp;
                lastx = e.pageX;
                lasty = e.pageY;
                // 修正起始位置，去除移动开始时的跳动
                x = lastx;
                y = lasty;
                fire(e, 'start');
            }
        };
        const up = (e) => {
            if (state > 0) {
                const t = e.timeStamp - lasttime;
                h({
                    type: 'move', subType: 'over', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp,
                    startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty,
                    swipe: (t < exports.SwipeTime)
                        && ((lasty - e.pageX) * (lasty - e.pageX) + (lasty - e.pageY) * (lasty - e.pageY)) > exports.SwipeSpeed * t / 1000
                });
            }
            state = -1;
        };
        return {
            type: 'mousedown', listener: down, listeners: [{ type: 'mousemove', listener: move },
                { type: 'mouseup', listener: up }], handler: h
        };
    };
    // 单击
    const mouseTap = (el, h) => {
        const hh = (e) => {
            h({ type: 'tap', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'click', listener: hh, listeners: null, handler: h };
    };
    // 双击
    const mouseDbltap = (el, h) => {
        const hh = (e) => {
            h({ type: 'dbltap', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'dblclick', listener: hh, listeners: null, handler: h };
    };
    // 长按
    const mouseLongtap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let ref = 0;
        const down = (e) => {
            ref && clearTimeout(ref);
            time = e.timeStamp;
            x = e.pageX;
            y = e.pageY;
            ref = setTimeout(() => {
                ref = 0;
                h({ type: 'longtap', native: e, x: x, y: y, timeStamp: time + exports.LongTapTime, startTime: time });
            }, exports.LongTapTime);
        };
        const move = (e) => {
            if (ref && (Math.abs(x - e.pageX) > exports.MoveLimit || Math.abs(y - e.pageY) > exports.MoveLimit)) {
                clearTimeout(ref);
                ref = 0;
            }
        };
        const up = (e) => {
            ref && clearTimeout(ref);
            ref = 0;
        };
        return {
            type: 'mousedown', listener: down, listeners: [{ type: 'mousemove', listener: move }, { type: 'mouseup', listener: up }],
            handler: h
        };
    };
    // 抬起
    const mouseUp = (el, h) => {
        const up = (e) => {
            h({ type: 'up', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'mouseup', listener: up, listeners: null, handler: h };
    };
    // 按下
    const mouseDown = (el, h) => {
        const down = (e) => {
            h({ type: 'down', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'mousedown', listener: down, listeners: null, handler: h };
    };
    // ============================== 立即执行
    // 设置当前的手势函数表
    const gesture = [{
            move: touchMove,
            tap: touchTap,
            dbltap: touchDbltap,
            longtap: touchLongtap,
            rotsal: touchRotsal,
            up: touchUp,
            down: touchDown
        }, {
            move: mouseMove,
            tap: mouseTap,
            dbltap: mouseDbltap,
            longtap: mouseLongtap,
            up: mouseUp,
            down: mouseDown
        }
    ];
    // 事件分类，参考用
    const HTML_DEFAULT_EVENTS = {
        WINDOW_EVENT: {
            AFTER_PRINT: 'afterprint',
            BEFORE_PRINT: 'beforeprint',
            BEFORE_UNLOAD: 'beforeunload',
            ERROR: 'error',
            HASH_CHANGE: 'hashchange',
            LOAD: 'load',
            MESSAGE: 'message',
            OFFLINE: 'offline',
            LINE: 'line',
            PAGE_HIDE: 'pagehide',
            PAGE_SHOW: 'pageshow',
            POP_STATE: 'popstate',
            REDO: 'redo',
            RESIZE: 'resize',
            STORAGE: 'storage',
            UNDO: 'undo',
            UNLOAD: 'unload'
        },
        KEYBOARD_EVENT: {
            KEY_DOWN: 'keydown',
            KEY_PRESS: 'keypress',
            KEY_UP: 'keyup'
        },
        MOBILE_EVENT: {
            TOUCH_START: 'touchstart',
            TOUCH_END: 'touchend',
            TOUCH_MOVE: 'touchmove',
            TOUCH_CANCEL: 'touchcancel'
        },
        MOUSE_EVENT: {
            CLICK: 'click',
            DBL_CLICK: 'dblclick',
            DRAG: 'drag',
            DRAG_END: 'dragend',
            DRAG_ENTER: 'dragenter',
            DRAG_LEAVE: 'dragleave',
            DRAG_OVER: 'dragover',
            DRAG_START: 'dragstart',
            DROP: 'drop',
            MOUSE_DOWN: 'mousedown',
            MOUSE_MOVE: 'mousemove',
            MOUSE_OUT: 'mouseout',
            MOUSE_OVER: 'mouseover',
            MOUSE_UP: 'mouseup',
            MOUSE_WHEEL: 'mousewheel',
            SCROLL: 'scroll'
        },
        FORM_EVENT: {
            BLUR: 'blur',
            CHANGE: 'change',
            CTEXT_MENU: 'ctextmenu',
            FOCUS: 'focus',
            FORM_CHANGE: 'formchange',
            FORM_INPUT: 'forminput',
            INPUT: 'input',
            INVALID: 'invalid',
            RESET: 'reset',
            SELECT: 'select',
            SUBMIT: 'submit'
        },
        MEDIA_EVENT: {
            ABOUT: 'abort',
            CAN_PLAY: 'canplay',
            CAN_PLAY_THROUGH: 'canplaythrough',
            DURATI_CHANGE: 'duratichange',
            EMPTIED: 'emptied',
            ENDED: 'ended',
            ERROR: 'error',
            LOADED_DATA: 'loadeddata',
            LOADED_META_DATA: 'loadedmetadata',
            LOAD_START: 'loadstart',
            PAUSE: 'pause',
            PLAY: 'play',
            PLAYING: 'playing',
            PROGRESS: 'progress',
            RATE_CHANGE: 'ratechange',
            READY_STATE_CHANGE: 'readystatechange',
            SEEKED: 'seeked',
            SEEKING: 'seeking',
            STALLED: 'stalled',
            SUSPEND: 'suspend',
            TIME_UPDATE: 'timeupdate',
            VOLUME_CHANGE: 'volumechange',
            WATING: 'waiting'
        }
    };
});

_$pi.define("pi_gui/gui/gui_virtual/virtual_node", ["require", "exports", "../gui/r_datastruct", "../../../pi_sys/feature/log", "./painter", "./virtaul_node_keyword", "./virtual_attr", "./virtual_event", "./virtual_style", "../../../pi_sys/modules/util/hash"], function (require, exports, r_datastruct_1, log_1, painter, virtaul_node_keyword_1, virtual_attr_1, virtual_event_1, virtual_style_1, hash_1) {
    "use strict";
    
    // ============================== 导出
    /**
     * tagName - tg
     * offsetOld - oO
     * offset - o
     * nodeHash - nH
     * attrHash - aH
     * attrSize - aS
     * attrs - a
     * styleHash - sH
     * styleSize - sS
     * style - s
     * eventHash - eH
     * eventSize - eS
     * event - e
     * childHashMap - cHM
     * childHash - cH
     *
     */
    /**
     * @description 普通节点
     * @example
     */
    class VirtualNodeBase {
        constructor(tagName, sid, did) {
            this.tg = tagName;
            this.si = sid;
            this.di = did;
            this.s = new virtual_style_1.VirtualStyle([]);
            this.e = new virtual_event_1.VirtualEvent();
            this.a = new virtual_attr_1.VirtualAttr();
            this.ext = new VNodeExt();
        }
        get widget() {
            return this.w;
        }
        get link() {
            return this.l;
        }
        get parent() {
            return this.p;
        }
        get attrs() {
            return this.a;
        }
    }
    exports.VirtualNodeBase = VirtualNodeBase;
    /**
     * 对应 div 节点
     */
    class VirtualContainerNode extends VirtualNodeBase {
        constructor(tagName, sid, did) {
            super(tagName, sid, did);
            this.cHM = new Map();
            this.cd = [];
            this.dM = new Map();
            this.tHM = new Map();
        }
        get children() {
            return this.cd;
        }
    }
    exports.VirtualContainerNode = VirtualContainerNode;
    /**
     * 对应 widget 节点
     */
    class VirtualWidgetNode extends VirtualNodeBase {
        constructor(tagName, sid, did) {
            super(tagName, sid, did);
        }
    }
    exports.VirtualWidgetNode = VirtualWidgetNode;
    /**
     * 对应 span 节点
     */
    // tslint:disable-next-line:max-classes-per-file
    class VirtualTextNode extends VirtualNodeBase {
        constructor(tagName, sid, did) {
            super(tagName, sid, did);
        }
    }
    exports.VirtualTextNode = VirtualTextNode;
    /**
     * 对应 img 节点
     */
    // tslint:disable-next-line:max-classes-per-file
    class VirtualImageNode extends VirtualNodeBase {
        constructor(tagName, sid, did) {
            super(tagName, sid, did);
        }
    }
    exports.VirtualImageNode = VirtualImageNode;
    /**
     * Ext
     */
    // tslint:disable-next-line:max-classes-per-file
    class VNodeExt {
    }
    exports.VNodeExt = VNodeExt;
    /**
     * @description 转换类型获得VirtualNode
     * @return <VirtualContainerNode> | undefined
     */
    exports.asVirtualContainerNode = (node) => {
        if (node.tg === r_datastruct_1.RElementTypeList.DIV || node.tg === r_datastruct_1.RElementTypeList.input) {
            return node;
        }
    };
    /**
     * @description 转换类型获得 VirtualWidgetNode
     * @return <VirtualWidgetNode> | undefined
     */
    exports.asVirtualWidgetNode = (node) => {
        // if ((<VirtualWidgetNode>node)[VNKeyWords.childHas] !== undefined || (<VirtualWidgetNode>node)[VNKeyWords.child] !== undefined) {
        //     return <VirtualWidgetNode>node;
        // }
        if (r_datastruct_1.RElementTypeList.LIST.indexOf(node.tg) < 0) {
            return node;
        }
    };
    /**
     * @description 转换类型获得 VirtualTextNode
     * @return <VirtualTextNode> | undefined
     */
    exports.asVirtualTextNode = (node) => {
        if (node.tg === r_datastruct_1.RElementTypeList.SPAN) {
            return node;
        }
    };
    /**
     * @description 转换类型获得 VirtualImageNode
     * @return <VirtualTextNode> | undefined
     */
    exports.asVirtualImageNode = (node) => {
        if (node.tg === r_datastruct_1.RElementTypeList.IMAGE) {
            return node;
        }
    };
    /**
     * @description 获得指定属性的值
     * @example
     */
    exports.getAttribute = (attr, name) => {
        return attr[name];
    };
    /**
     * @description 寻找满足指定属性的第一个节点，递归调用，遍历vdom树。value为undefined，有属性就可以
     * @example
     */
    exports.findNodeByAttr = (node, key, value) => {
        const arr = node.cd;
        for (const n of arr) {
            let transNode;
            transNode = exports.asVirtualContainerNode(n);
            if (transNode) {
                const value0 = exports.getAttribute(transNode.a, key);
                if (value !== undefined) {
                    if (value === value0) {
                        return transNode;
                    }
                }
                else if (value0 !== undefined) {
                    return transNode;
                }
                transNode = exports.findNodeByAttr(transNode, key, value);
                if (transNode) {
                    return transNode;
                }
            }
            else if (exports.asVirtualWidgetNode(n)) {
                transNode = exports.asVirtualWidgetNode(n);
                if (transNode) {
                    const value0 = exports.getAttribute(transNode.a, key);
                    if (value !== undefined) {
                        if (value === value0) {
                            return transNode;
                        }
                    }
                    else if (value0 !== undefined) {
                        return transNode;
                    }
                }
            }
            else {
                const value0 = exports.getAttribute(n.a, key);
                if (value !== undefined) {
                    if (value === value0) {
                        return n;
                    }
                }
                else if (value0 !== undefined) {
                    return n;
                }
            }
        }
    };
    /**
     * @description 寻找满足指定Tag的第一个节点，递归调用，遍历vdom树
     * @example
     */
    exports.findNodeByTag = (node, tag) => {
        const arr = node.cd;
        for (let n of arr) {
            if (exports.asVirtualContainerNode(n)) {
                if (n.tg === tag) {
                    return n;
                }
                n = exports.findNodeByTag(n, tag);
                if (n) {
                    return n;
                }
            }
            else if (exports.asVirtualWidgetNode(n)) {
                if (n.tg === tag) {
                    return n;
                }
            }
        }
    };
    /**
     * @description 用新节点创建
     * @example
     */
    exports.create = (n) => {
        if (exports.asVirtualWidgetNode(n)) {
            painter.createWidget(n);
        }
        else {
            createNode(n);
        }
    };
    /**
     * @description 用新节点替换旧节点
     * replace的前提是，已经判断这是同一个节点了，替换后对旧节点做标记，
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    exports.replace = (oldNode, newNode) => {
        let bool;
        // if (asVirtualTextNode(oldNode) && asVirtualTextNode(newNode)) {
        //     if ((<VirtualTextNode>oldNode).text !== undefined 
        //          && (<VirtualTextNode>oldNode).text !== null 
        //          && (<VirtualTextNode>newNode).text !== undefined 
        //          && (<VirtualTextNode>newNode).text !== null
        //      ) {
        //         return replaceAsTextNode(oldNode, newNode);
        //     }
        // // } else if (asVirtualImageNode(oldNode) && asVirtualImageNode(newNode)) {
        // //     if ((<VirtualImageNode>oldNode).src !== undefined 
        // //         && (<VirtualImageNode>oldNode).src !== null 
        // //         && (<VirtualImageNode>newNode).src !== undefined 
        // //         && (<VirtualImageNode>newNode).src !== null
        // //     ) {
        // //         return replaceAsImageNode(oldNode, newNode);
        // //     }
        // } else {
        //     oldNode = <VirtualContainerNode | VirtualWidgetNode>oldNode;
        //     newNode = <VirtualContainerNode | VirtualWidgetNode>newNode;
        //     painter.replaceNode(<VWNode>oldNode, <VWNode>newNode);
        //     newNode.oO = oldNode.o;
        //     oldNode.o = -1;
        //     bool = replaceAttr(<VWNode>oldNode, <VWNode>newNode);
        //     if (oldNode.cH !== newNode.cH || painter.forceReplace) {
        //         if (asVirtualContainerNode(<VWNode>oldNode) && asVirtualContainerNode(<VWNode>newNode)) {
        //             replaceChilds(<VirtualContainerNode>oldNode, <VirtualContainerNode>newNode);
        //         } else if (asVirtualWidgetNode(<VWNode>oldNode) && asVirtualWidgetNode(<VWNode>newNode)) {
        //             painter.modifyWidget(<VirtualWidgetNode>oldNode, (<VirtualWidgetNode>newNode).child, (<VirtualWidgetNode>oldNode).child);
        //         }
        //         bool = true;
        //     } else if (asVirtualContainerNode(<VWNode>oldNode) && asVirtualContainerNode(<VWNode>newNode)) {
        //         // 将oldNode上的子节点及索引移动到新节点上
        //         (<VirtualContainerNode>newNode).didMap = (<VirtualContainerNode>oldNode).didMap;
        //         (<VirtualContainerNode>newNode).children = (<VirtualContainerNode>oldNode).children;
        //         (<VirtualContainerNode>newNode).textHashMap = (<VirtualContainerNode>oldNode).textHashMap;
        //         (<VirtualContainerNode>newNode).cHM = (<VirtualContainerNode>oldNode).cHM;
        //         for (const n of (<VirtualContainerNode>newNode).children) {
        //             n.parent = (<VirtualContainerNode>newNode);
        //         }
        //     }
        //     return bool;
        // }
        if (exports.asVirtualTextNode(oldNode) && exports.asVirtualTextNode(newNode)) {
            if (oldNode.t !== undefined
                && oldNode.t !== null
                && newNode.t !== undefined
                && newNode.t !== null) {
                replaceAsTextNode(oldNode, newNode);
            }
        }
        else {
            oldNode = oldNode;
            newNode = newNode;
            painter.replaceNode(oldNode, newNode);
        }
        newNode.oO = oldNode.o;
        oldNode.o = -1;
        bool = replaceAttr(oldNode, newNode);
        if (oldNode.cH !== newNode.cH || painter.forceReplace) {
            if (exports.asVirtualContainerNode(oldNode) && exports.asVirtualContainerNode(newNode)) {
                replaceChilds(oldNode, newNode);
            }
            else if (exports.asVirtualWidgetNode(oldNode) && exports.asVirtualWidgetNode(newNode)) {
                painter.modifyWidget(oldNode, newNode[virtaul_node_keyword_1.VNKeyWords.child], oldNode[virtaul_node_keyword_1.VNKeyWords.child]);
            }
            bool = true;
        }
        else if (exports.asVirtualContainerNode(oldNode) && exports.asVirtualContainerNode(newNode)) {
            // 将oldNode上的子节点及索引移动到新节点上
            newNode.dM = oldNode.dM;
            newNode.cd = oldNode.cd;
            newNode.tHM = oldNode.tHM;
            newNode.cHM = oldNode.cHM;
            for (const n of newNode.cd) {
                n.p = newNode;
            }
        }
        return bool;
    };
    const replaceAsTextNode = (oldNode, newNode) => {
        newNode.l = oldNode.l;
        newNode.ext = oldNode.ext;
        if (oldNode.t === newNode.t) {
            return false;
        }
        painter.modifyText(newNode, newNode.t, oldNode.t);
        return true;
    };
    // ============================== 本地
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const replaceAttr = (oldNode, newNode) => {
        const sameAttr = oldNode.aH === newNode.aH;
        const sameStyle = oldNode.sH === newNode.sH;
        const sameEvent = oldNode.eH === newNode.eH;
        if (sameAttr
            && sameStyle
            && sameEvent
            && !painter.forceReplace) {
            return false;
        }
        if (newNode.aS && !newNode.ext) {
            newNode.ext = {};
        }
        !sameAttr && exports.objDiff(newNode.a, newNode.aS, oldNode.a, oldNode.aS, attrDiff, newNode);
        !sameEvent && exports.objDiff(newNode.e, newNode.eS, oldNode.e, oldNode.eS, eventDiff, newNode);
        if (!sameStyle) {
            exports.objDiff(newNode.s, newNode.sS, oldNode.s, oldNode.sS, styleDiff, newNode);
            painter.setDiffStyle(newNode, false);
        }
        return true;
    };
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const attrDiff = (newNode, key, v1, v2) => {
        if (v1 === undefined) {
            return painter.delAttr(newNode, key);
        }
        if (v2 === undefined) {
            return painter.addAttr(newNode, key, v1);
        }
        painter.modifyAttr(newNode, key, v1, v2);
    };
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const styleDiff = (newNode, key, v1, v2) => {
        if (v1 === undefined) {
            return painter.delStyle(newNode, key);
        }
        if (v2 === undefined) {
            return painter.addStyle(newNode, key, v1);
        }
        painter.modifyStyle(newNode, key, v1, v2);
    };
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const eventDiff = (newNode, key, v1, v2) => {
        if (v1 === undefined) {
            return painter.delEvent(newNode, key);
        }
        if (v2 === undefined) {
            return painter.addEvent(newNode, key, v1);
        }
        painter.modifyEvent(newNode, key, v1, v2);
    };
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const otherDiff = (newNode, key, v1, v2) => {
        if (v1 === undefined) {
            return painter.delAttr(newNode, key);
        }
        if (v2 === undefined) {
            return painter.addAttr(newNode, key, v1);
        }
        painter.modifyAttr(newNode, key, v1, v2);
    };
    /**
     * @description 在数组中寻找相同节点
     * @example
     */
    const findSameHashNode = (arr, node) => {
        if (!arr) {
            return;
        }
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (n.o >= 0 && n.tg === node.tg && n.si === node.si && n.aH === node.aH) {
                return n;
            }
        }
    };
    /**
     * @description 在数组中寻找相似节点
     * @example
     */
    const findLikeHashNode = (arr, node) => {
        if (!arr) {
            return;
        }
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (n.o >= 0 && n.tg === node.tg && n.si === node.si) {
                return n;
            }
        }
    };
    /**
     * @description 寻找相同节点的函数
     * VirtualNode根据 did attrHash childHash 寻找相同节点，如果没有找到，则返回undefined
     * @example
     */
    const findSameVirtualNode = (oldParent, newParent, child) => {
        let n;
        if (child.di && oldParent.dM) {
            n = oldParent.dM.get(child.di);
            if (n && n.o >= 0 && n.tg === child.tg && n.si === child.si) {
                return n;
            }
        }
        else if (oldParent.cHM) {
            return findSameHashNode(oldParent.cHM.get(child.cH), child);
        }
    };
    /**
     * @description 寻找相似节点的函数
     * VirtualNode根据 childHash attrHash offset 依次寻找相似节点，如果没有找到，则返回undefined
     * @example
     */
    const findLikeVirtualNode = (oldParent, newParent, child, offset) => {
        if (!oldParent.cHM) {
            return;
        }
        let n;
        const arr = oldParent.cHM.get(child.cH);
        n = findLikeHashNode(arr, child);
        if (n) {
            return n;
        }
        n = oldParent.cd[offset];
        if (n && n.cH !== undefined && n.o >= 0 && child.tg === n.tg && child.si === n.si) {
            return n;
        }
    };
    /**
     * @description 寻找相同文本节点的函数
     * VirtualNode根据 textHash依次寻找相同节点，如果没有找到，则返回undefined
     * @example
     */
    const findSameVirtualTextNode = (oldParent, newParent, child) => {
        return findSameVirtualNode(oldParent, newParent, child);
        // const arr = oldParent.cHM && oldParent.cHM.get(child.cH);
        // if (arr && arr.length > 0) {
        //     return arr.shift();
        // }
    };
    /**
     * @description 寻找相似文本节点的函数
     * VirtualNode根据 offset 寻找相似节点，如果没有找到，则返回undefined
     * @example
     */
    // tslint:disable:max-line-length
    const findLikeVirtualTextNode = (oldParent, newParent, child, offset) => {
        return findLikeVirtualNode(oldParent, newParent, child, offset);
        const n = oldParent.cd[offset];
        if (n && n.t && n.o >= 0) {
            return n;
        }
    };
    /**
     * @description 初始化子节点，并在父节点上添加索引
     * @example
     */
    const initAndMakeIndex = (n, i, parent) => {
        let map;
        let nodes;
        n.p = parent;
        n.o = i;
        n.w = parent.w;
        if (n.di) {
            if (!parent.dM) {
                parent.dM = new Map();
            }
            parent.dM.set(n.di, n);
        }
        else {
            map = parent.cHM;
            if (!map) {
                parent.cHM = map = new Map();
            }
            nodes = map.get(n[virtaul_node_keyword_1.VNKeyWords.childHas]) || [];
            nodes.push(n);
            map.set(n[virtaul_node_keyword_1.VNKeyWords.childHas], nodes);
            nodes = map.get(n.nH) || [];
            nodes.push(n);
            map.set(n.nH, nodes);
        }
    };
    /**
     * @description 文本索引
     * @example
     */
    const makeTextIndex = (n, i, parent) => {
        initAndMakeIndex(n, i, parent);
        return;
        n.p = parent;
        n.o = i;
        n.w = parent.w;
        let map = parent.tHM;
        if (!map) {
            parent.tHM = map = new Map();
        }
        const nodes = map.get(n.cH) || [];
        nodes.push(n);
        map.set(n.cH, nodes);
    };
    /**
     * @description 用新节点创建
     * @example
     */
    const createNode = (node) => {
        const arr = node.cd;
        painter.createNode(node);
        const parent = node.l;
        if (!arr)
            return;
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            switch (n.tg) {
                case (r_datastruct_1.RElementTypeList.DIV):
                case (r_datastruct_1.RElementTypeList.input):
                case (r_datastruct_1.RElementTypeList.textarea):
                case (r_datastruct_1.RElementTypeList.IMAGE):
                case (r_datastruct_1.RElementTypeList.SPAN): {
                    initAndMakeIndex(n, i, node);
                    createNode(n);
                    break;
                }
                default: {
                    if (node.cH !== undefined || node[virtaul_node_keyword_1.VNKeyWords.child] !== undefined) {
                        initAndMakeIndex(n, i, node);
                        painter.createWidget(n);
                    }
                    else {
                        log_1.cc.warn && log_1.log(`节点类型 ${n.tg} 不支持`);
                    }
                }
            }
            // if (asVirtualWidgetNode(n)) {
            //     initAndMakeIndex(n, i, node);
            //     painter.createWidget(n);
            // } else if (n.tg === RElementTypeList.DIV || n.tg === RElementTypeList.input || n.tg === RElementTypeList.textarea) {
            //     initAndMakeIndex(n, i, node);
            //     createNode(n);
            // } else if (n.tg === RElementTypeList.BG) {
            //     initAndMakeIndex(n, i, node);
            //     createNode(n);
            // } else if (n.tg === RElementTypeList.IMAGE) {
            //     initAndMakeIndex(n, i, node);
            //     createNode(n);
            // } else if (n.tg === RElementTypeList.SPAN)  {
            //     makeTextIndex(n, i, node);
            //     createNode(n);
            //     // painter.createTextNode(n);
            // } else {
            //     warn(100, `节点类型 ${n.tg} 不支持`);
            // }
            painter.addNode(parent, n, true);
        }
    };
    /**
     * @description 子节点替换方法，不应该使用编辑距离算法
     * 依次处理所有删除的和一般修改的节点。最后处理位置变动和新增的，如果位置变动超过1个，则清空重新添加节点
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    const replaceChilds = (oldNode, newNode) => {
        let n;
        let same;
        let arr = newNode.cd;
        const len = arr.length;
        let next = false;
        let insert = false;
        let move = 0;
        for (let i = 0, offset = 0; i < len; i++) {
            n = arr[i];
            if (n.tg !== r_datastruct_1.RElementTypeList.SPAN) {
                initAndMakeIndex(n, i, newNode);
                // 在旧节点寻找相同节点
                same = findSameVirtualNode(oldNode, newNode, n);
            }
            else {
                makeTextIndex(n, i, newNode);
                // 在旧节点寻找相同节点
                same = findSameVirtualTextNode(oldNode, newNode, n);
            }
            if (!same) {
                offset++;
                // 猜测用最新的位置差能够找到变动的节点
                n.oO = -offset;
                next = true;
                continue;
            }
            // 记录最新相同节点的位置差
            offset = same.o + 1;
            exports.replace(same, n);
            // 计算有无次序变动
            if (move >= 0) {
                move = (move <= offset) ? offset : -1;
            }
        }
        if (next) {
            move = 0;
            // 寻找相似节点
            for (let i = 0; i < len; i++) {
                n = arr[i];
                if (n.oO >= 0) {
                    // 计算有无次序变动
                    if (move >= 0) {
                        move = (move <= n.oO) ? n.oO : -1;
                    }
                    continue;
                }
                if (n.tg !== r_datastruct_1.RElementTypeList.SPAN) {
                    same = findLikeVirtualNode(oldNode, newNode, n, -n.oO - 1);
                }
                else {
                    same = findLikeVirtualTextNode(oldNode, newNode, n, -n.oO - 1);
                }
                if (!same) {
                    exports.create(n);
                    insert = true;
                    continue;
                }
                exports.replace(same, n);
                // 计算有无次序变动
                if (move >= 0) {
                    move = (move <= n.oO) ? n.oO : -1;
                }
            }
        }
        // 删除没有使用的元素
        arr = oldNode.cd;
        for (let i = arr.length - 1; i >= 0; i--) {
            if (arr[i].o >= 0) {
                painter.delNode(arr[i]);
            }
        }
        arr = newNode.cd;
        const parent = newNode.l;
        // 如果有节点次序变动，则直接在新节点上加入新子节点数组，代码更简单，性能更好
        if (move < 0) {
            // painter.paintCmd3(parent, "innerHTML", ""); //不需要清空，重新加一次，一样保证次序
            for (let i = 0; i < len; i++) {
                painter.addNode(parent, arr[i], true);
            }
        }
        else if (insert) {
            // 如果没有节点次序变动，则插入节点
            for (let i = 0; i < len; i++) {
                n = arr[i];
                if (n.oO < 0) {
                    painter.insertNode(parent, n, n.o);
                }
            }
        }
    };
    // tslint:disable-next-line:cyclomatic-complexity
    exports.objDiff = (obj1, objSize1, obj2, objSize2, cb, args) => {
        let c = 0;
        if (objSize1 < objSize2) {
            for (const k in obj2) {
                if (k.charCodeAt(0) === 95 && k.charCodeAt(0) === 36) {
                    continue;
                }
                const v1 = obj1[k];
                if (v1 !== undefined) {
                    c++;
                    const v2 = obj2[k];
                    if (!virtual_attr_1.equalAttr(v1, v2)) {
                        cb(args, k, v1, v2);
                    }
                }
                else {
                    cb(args, k, v1, obj2[k]);
                }
            }
            if (c < objSize1) {
                for (const k in obj1) {
                    if (k.charCodeAt(0) === 95 && k.charCodeAt(0) === 36) {
                        continue;
                    }
                    const v2 = obj2[k];
                    if (v2 === undefined) {
                        cb(args, k, obj1[k], v2);
                    }
                }
            }
        }
        else {
            for (const k in obj1) {
                if (k.charCodeAt(0) === 95 && k.charCodeAt(0) === 36) {
                    continue;
                }
                const v2 = obj2[k];
                if (v2 !== undefined) {
                    c++;
                    const v1 = obj1[k];
                    if (!virtual_attr_1.equalAttr(v1, v2)) {
                        cb(args, k, v1, v2);
                    }
                }
                else {
                    cb(args, k, obj1[k], v2);
                }
            }
            if (c < objSize2) {
                for (const k in obj2) {
                    if (k.charCodeAt(0) === 95 && k.charCodeAt(0) === 36) {
                        continue;
                    }
                    const v1 = obj1[k];
                    if (v1 === undefined) {
                        cb(args, k, v1, obj2[k]);
                    }
                }
            }
        }
        return c;
    };
    /**
     * 没有通过 tpl 修改了真实节点样式
     * @param virtualNode 目标虚拟节点
     * @param key 目标样式键 - 简写模式
     * @param value 目标样式值
     */
    exports.changeVirtualNodeStyle = (virtualNode, key, value) => {
        if (!virtualNode.s) {
            return;
        }
        virtualNode.s[key] = value;
        virtualNode.sH = hash_1.anyHash(virtualNode.s, 0, new Set);
    };
});
// ============================== 立即执行

/*
 * 样式模块，提供组件内包含子组件范围内基于clazz的样式匹配，clazz使用内联样式作用到实际节点上。
 * 而内联样式则不支持伪类( :hover)、伪对象( :first-child)和关键帧动画( animation keyframes)。
 * 因此，不能支持伪类和关键帧动画。可以使用全局class来处理。
 * 样式沿组件树上溯，寻找到后就注入，这样优先使用外部定义，如果没有则使用默认。
 */
_$pi.define("pi_gui/gui/gui_virtual/style", ["require", "exports", "../../../pi_sys/modules/util/hash", "../../../pi_sys/setup/depend", "../../widget/html", "../../../pi_sys/modules/util/util", "./virtaul_node_keyword"], function (require, exports, hash_1, depend_1, html_1, util_1, virtaul_node_keyword_1) {
    "use strict";
    
    /**
     * @description 解析字符串，返回样式表
     * @example
     * 只支持class
     */
    exports.parse = (str, path) => {
        let r = styleRxp.exec(str);
        if (!r) {
            return null;
        }
        const sheet = new Map();
        while (r) {
            const s = r[1];
            const effect = exports.parseEffect(r[2], path);
            r = styleRxp.exec(str);
            if (!effect) {
                continue;
            }
            let rr = classRxp.exec(s);
            while (rr) {
                sheet.set(rr[1], effect);
                rr = classRxp.exec(s);
            }
        }
        return sheet.size > 0 ? sheet : null;
    };
    /**
     * @description 分析样式效果，可用于内联样式和外部样式的分析
     * @example
     */
    exports.parseEffect = (str, path) => {
        const arr = str.split(';');
        const effect = { map: new Map(), url: null };
        const map = effect.map;
        let n = 0;
        for (const s of arr) {
            const i = s.indexOf(':');
            if (i < 0) {
                continue;
            }
            n++;
            const k = html_1.getSupportedProperty(s.slice(0, i).trim());
            const v = s.slice(i + 1);
            const url = getURL(k, v, path);
            if (!url) {
                map.set(k, v);
            }
            else {
                effect.url = url;
            }
        }
        return n > 0 ? effect : null;
    };
    /**
     * @description 分析样式效果，可用于内联样式和外部样式的分析
     * @example
     */
    exports.parseEffect2 = (key, value, effect) => {
        effect = effect || { map: new Map(), url: null };
        const map = effect.map;
        map.set(key, value);
        return effect;
    };
    /**
     * @description 计算clazz的样式特效，沿组件树上溯查找定义的clazz
     * @example
     */
    exports.calcClazz = (widget, clazz, clazzStr, result) => {
        // 先从本地缓存中寻找 - 现 wcss 实现为 js 导出对象，组件加载时便有
        if (!result) {
            result = new Map();
        }
        else {
            result.clear();
        }
        clazz.forEach((v, k) => {
            const effect = exports.readClazz(widget, v);
            if (effect) {
                for (const k in effect) {
                    result.set(k, effect[k]);
                }
            }
        });
        return result;
    };
    exports.readClazz = (widget, clazz) => {
        let result;
        if (widget.r_sheet) {
            result = widget.r_sheet.value[clazz];
        }
        if (!result) {
            if (widget.parentNode[virtaul_node_keyword_1.VNKeyWords.widget]) {
                result = exports.readClazz(widget.parentNode[virtaul_node_keyword_1.VNKeyWords.widget], clazz);
            }
        }
        return result;
    };
    /**
     * @description 合并内联样式和clazz样式
     * @example
     */
    exports.mergeStyle = (innerStyle, clazzStyle) => {
        const style = new Map();
        // 合并 - inner 覆盖 clazz
        clazzStyle.forEach((value, key) => {
            style.set(key, value);
        });
        innerStyle.forEach((value, key) => {
            style.set(key, value);
        });
        return style;
    };
    /**
     * @description 计算新旧样式的差异部分
     * @example
     */
    exports.difference = (oldStyle, newStyle) => {
        if (!oldStyle) {
            return newStyle;
        }
        const diff = { map: new Map(), url: null };
        const om = oldStyle.map;
        const dm = diff.map;
        if (!newStyle) {
            for (const k of om.keys()) {
                dm.set(k, '');
            }
            return diff;
        }
        util_1.mapDiff(newStyle.map, om, diffMap, dm);
        if (oldStyle.url) {
            if (newStyle.url) {
                if (oldStyle.url.key !== newStyle.url.key || !util_1.arrayEqual(oldStyle.url.arr, newStyle.url.arr)) {
                    diff.url = newStyle.url;
                }
            }
        }
        else if (newStyle.url) {
            diff.url = newStyle.url;
        }
        return diff;
    };
    exports.differenceStyle = (oldStyle, newStyle) => {
        if (!oldStyle) {
            return newStyle;
        }
        const diff = new Map();
        // 没有新属性, 旧属性全清空
        if (!newStyle) {
            oldStyle.forEach((value, key) => {
                diff.set(key, undefined);
            });
            return diff;
        }
        oldStyle.forEach((value, key) => {
            // if (newStyle.get(key) !== value) {
            if (hash_1.allHash(newStyle.get(key), null) !== hash_1.allHash(value, null)) {
                diff.set(key, newStyle.get(key));
            }
        });
        newStyle.forEach((value, key) => {
            // if (oldStyle.get(key) !== value) {
            if (hash_1.allHash(oldStyle.get(key), null) !== hash_1.allHash(value, null)) {
                diff.set(key, newStyle.get(key));
            }
        });
        return diff;
    };
    /**
     * @description 在高优先级的样式中过滤指定新样式
     * @example
     */
    exports.filter = (highStyle, style) => {
        if (!highStyle) {
            return;
        }
        const map2 = style.map;
        const map1 = highStyle.map;
        for (const k of map2.keys()) {
            if (!map1.has(k)) {
                continue;
            }
            map2.delete(k);
            if (style.url && style.url.key === k) {
                style.url = null;
            }
        }
    };
    exports.filterStyle = (highStyle, style) => {
        if (!highStyle) {
            return;
        }
        const map2 = style;
        const map1 = highStyle;
        for (const k of map2.keys()) {
            if (!map1.has(k)) {
                continue;
            }
            map2.delete(k);
            // if (style.url && style.url.key === k) {
            //     style.url = null;
            // }
        }
    };
    // ============================== 本地
    // 匹配样式
    const styleRxp = /\s*([^{]*)\s*{\s*([^}]*)}/g;
    // 匹配类选择器
    const classRxp = /\s*\.([-_\w]+)\s*,?/g;
    // 匹配CSS的effect中的url，不匹配含有:的字符串，所以如果是http:或https:，则不替换
    const effectURL = /url\(([^\)"':]*)\)/g;
    // 获得路径的url
    const getURL = (k, v, path) => {
        // 替换url为全路径
        let rr = effectURL.exec(v);
        if (!rr) {
            return;
        }
        const info = { key: k, arr: [] };
        let suffix = 0;
        const arr = info.arr;
        do {
            // tslint:disable:prefer-template
            arr.push(v.slice(suffix, rr.index) + 'url(');
            arr.push(depend_1.relativePath(rr[1], path));
            suffix = rr.index + rr[0].length - 1;
            rr = effectURL.exec(v);
        } while (rr);
        arr.push(v.slice(suffix));
        return info;
    };
    // 写入diffMap
    const diffMap = (dm, key, newv, oldv) => {
        dm.set(key, newv || '');
    };
});

/**
 * vdom和组件的渲染器，提供全局的命令列表，将真实dom操作延迟到帧渲染时调用
 * 新建DOM节点及子节点时，不发送渲染命令，直接调用方法
 * 注意：如果父组件修改子组件属性，并且子组件也更改根节点的属性，则以最后修改的为准
 * 注意：如果父组件定义了子组件w-class样式，并且子组件也定义了根节点的w-class样式，则以子组件的优先
 */
_$pi.define("pi_gui/gui/gui_virtual/painter", ["require", "exports", "../gui/r_datastruct", "../gui/r_document", "../gui/r_element", "../gui/tools", "../../../pi_sys/setup/depend", "../../../pi_sys/feature/log", "../../../pi_sys/modules/util/res_mgr", "../../../pi_sys/modules/util/util", "./event", "../../../pi_sys/modules/util/frame_mgr", "./style", "./virtual_node", "./widget", "../gui/math_tools", "../gui_res/res_mgr", "../../../pi_sys/modules/util/hash"], function (require, exports, r_datastruct_1, r_document_1, r_element_1, tools_1, depend_1, log_1, res_mgr_1, util_1, event, frame_mgr_1, style_1, virtual_node_1, widget_1, math_tools_1, res_mgr_2, hash_1) {
    "use strict";
    
    // ============================== 导出
    // export class Painter {
    //     public static level: any = commonjs.debug ? logLevel : LogLevel.info;
    //     public static vdocument: RDocument = null;
    //     public static frameMgr: any;
    //     /**
    //      * 是否忽略hash相同，强制比较和替换
    //      */
    //     public static forceReplace: boolean = false;
    //     /**
    //      * 是否显示w-前缀的属性
    //      */
    //     private static showWAttr: boolean = false;
    //     /**
    //      * 创建节点后的处理函数，一般给扩展方调用
    //      */
    //     private static createHandler: Function = null;
    //     public static init() {
    //         this.vdocument = new RDocument(document.getElementsByTagName('canvas')[0]);
    //         // vdocument = new RDocument(document.body);
    //         (<any>window).vdocument = Painter.vdocument;
    //         this.frameMgr = getGlobal();
    //         this.frameMgr.setPermanent(this.vdocument.render);
    //     }
    //     /**
    //      * 是否显示w-前缀的属性
    //      */
    //     public static setShowWAttr = (value: boolean) => {
    //         Painter.showWAttr = value;
    //     }
    //     /**
    //      * 创建节点后的处理函数
    //      */
    //     public static setCreateHandler = (value: Function) => {
    //         Painter.createHandler = value;
    //     }
    //     /**
    //      * 获得真实的dom节点
    //      */
    //     public static getRealNode = (node: VirtualNodeBase): RElement => {
    //         let n: VirtualWidgetNode;
    //         while (node) {
    //             n = asVirtualWidgetNode(node);
    //             if (!n) {
    //                 return (<any>node).link;
    //             }
    //             node = n.link.tree;
    //         }
    //     }
    //     /**
    //      * 替换节点，只替换了当前节点的link ext, 其他属性和子节点均没有替换
    //      */
    //     public static replaceNode = (oldNode: VWNode, newNode: VWNode): void => {
    //         newNode.link = oldNode.link;
    //         const n = asVirtualWidgetNode(newNode);
    //         if (n) {
    //             n.link.parentNode = n;
    //         }
    //         newNode.ext = oldNode.ext;
    //         event.rebindEventMap(oldNode, newNode);
    //     }
    //     public static addAttr = (node: VWNode, key: string, value: string): void => {
    //         setAttr(node, key, value);
    //     }
    //     public static modifyAttr = (node: VWNode, key: string, newValue: string, oldValue: string): void => {
    //         setAttr(node, key, newValue);
    //     }
    //     public static delAttr = (node: VWNode, key: string): void => {
    //         setAttr(node, key);
    //     }
    //     public static addStyle = (node: VWNode, key: string, value: string): void => {
    //         setAttrStyle(node, key, value);
    //     }
    // }
    exports.vdocument = null;
    /**
     * @description 是否忽略hash相同，强制比较和替换
     * @example
     */
    exports.forceReplace = false;
    /**
     * @description 是否显示w-前缀的属性
     * @example
     */
    exports.showWAttr = false;
    /**
     * @description 创建节点后的处理函数，一般给扩展方调用
     * @example
     */
    exports.createHandler = null;
    /**
     * @description 是否显示w-前缀的属性
     * @example
     */
    exports.setShowWAttr = (value) => {
        exports.showWAttr = value;
    };
    /**
     * @description 是否显示w-前缀的属性
     * @example
     */
    exports.setCreateHandler = (func) => {
        exports.createHandler = func;
    };
    /**
     * @description 获得真实的dom节点
     * @example
     */
    exports.getRealNode = (node) => {
        let n;
        while (node) {
            n = virtual_node_1.asVirtualWidgetNode(node);
            if (!n) {
                return node.l;
            }
            node = n.l.tree;
        }
    };
    /**
     * @description 替换节点，只替换了当前节点的link ext, 其他属性和子节点均没有替换
     * @example
     */
    exports.replaceNode = (oldNode, newNode) => {
        newNode.l = oldNode.l;
        const n = virtual_node_1.asVirtualWidgetNode(newNode);
        if (n) {
            n.l.parentNode = n;
        }
        newNode.ext = oldNode.ext;
        event.rebindEventMap(oldNode, newNode);
    };
    /**
     * @description 添加节点的属性，并没有真正的添加，只是传了一个命令
     * @example
     */
    exports.addAttr = (node, key, value) => {
        exports.setAttr(node, key, value);
    };
    /**
     * @description 修改节点的属性
     * @example
     */
    exports.modifyAttr = (node, key, newValue, oldValue) => {
        exports.setAttr(node, key, newValue);
    };
    /**
     * @description 删除节点的属性
     * @example
     */
    exports.delAttr = (node, key) => {
        exports.setAttr(node, key);
    };
    /**
     * @description 添加节点的 样式 属性，并没有真正的添加，只是传了一个命令
     * @example
     */
    exports.addStyle = (node, key, value) => {
        setAttrStyle(node, key, value);
    };
    /**
     * @description 修改节点的 样式 属性
     * @example
     */
    exports.modifyStyle = (node, key, newValue, oldValue) => {
        setAttrStyle(node, key, newValue);
    };
    /**
     * @description 删除节点的 样式 属性
     * @example
     */
    exports.delStyle = (node, key, value) => {
        setAttrStyle(node, key, value);
    };
    /**
     * @description 添加节点的 事件 属性，并没有真正的添加，只是传了一个命令
     * @example
     */
    exports.addEvent = (node, key, value) => {
        setAttrEventListener(node, key, value);
    };
    /**
     * @description 修改节点的 事件 属性
     * @example
     */
    exports.modifyEvent = (node, key, newValue, oldValue) => {
        setAttrEventListener(node, key, newValue);
    };
    /**
     * @description 删除节点的 事件 属性
     * @example
     */
    exports.delEvent = (node, key, value) => {
        setAttrEventListener(node, key, value);
    };
    /**
     * @description 添加节点的属性，并没有真正的添加，只是传了一个命令
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    exports.setAttr = (node, key, value, immediately = true) => {
        if (key === 'class') {
            cmdSet(exports.getRealNode(node), 'className', value, immediately);
            return;
        }
        if (key === 'anim') {
            exports.analyAttrAnim(node, value);
            return;
        }
        // if (key === 'style') {
        //     return setAttrStyle(node, key, value, immediately);
        // }
        // if (setAttrEventListener(node, key, value) && !showWAttr) {
        //     return;
        // }
        if (key.charCodeAt(0) === 119 && key.charCodeAt(1) === 95 || key.charCodeAt(1) === 45) {
            // key.replace('-', '_');
            // if (key === 'w_class') {
            //     setAttrClazz(node, key, value, immediately);
            // } else
            if (key === 'w-plugin') {
                setAttrPlugin(node, value ? JSON.parse(value) : undefined);
            }
            else if (key === 'w-props') {
                if (virtual_node_1.asVirtualWidgetNode(node)) {
                    node.ext.propsUpdate = (value === 'update');
                }
            }
            else if (key.charCodeAt(2) === 101 && key.charCodeAt(3) === 118 && key.charCodeAt(4) === 45) {
                // "w-ev-***"
                let attr = node.ext.eventAttr;
                if (!attr) {
                    node.ext.eventAttr = attr = {};
                }
                attr[key.slice(5)] = value ? JSON.parse(value) : undefined;
            }
            if (!exports.showWAttr) {
                return;
            }
        }
        const el = exports.getRealNode(node);
        // 匹配img src
        if (key === 'src' && virtual_node_1.asVirtualImageNode(node)) {
            exports.setAttrSrc(node, value);
        }
        else if (key === 'value' && (node.tg === 'INPUT' || node.tg === 'TEXTAREA')) {
            cmdSet(el, 'value', value, immediately);
        }
        else if (value !== undefined) {
            cmdObjCall(el, 'setAttribute', key, value, immediately);
        }
        else {
            cmdObjCall(el, 'removeAttribute', key, '', immediately);
        }
    };
    exports.analyAttrAnim = (node, value) => {
        const cmdList = value.split(',');
        cmdList.forEach((v) => {
            const parmList = v.split('-');
            const animName = parmList[0];
            const evtType = parmList[1];
            const funcName = parmList[2];
            node.l.style.addAnimListener(animName, evtType, node.w[funcName]);
        });
    };
    exports.setAttrSrc = (node, value, immediately = true) => {
        const el = exports.getRealNode(node);
        // src 设置一定延时 - 底层
        immediately = false;
        if (value) {
            if (value.indexOf(':') < 0) {
                value = depend_1.relativePath(value, node.w.tpl.path);
                loadSrc(el, node.w, value, immediately);
            }
            else {
                // cmdSet(el, 'src', value, immediately);
                loadSrc(el, node.w, value, immediately);
            }
        }
        else {
            // cmdSet(el, 'src', '', immediately);
            loadSrc(el, node.w, '', immediately);
        }
    };
    exports.setAttrText = (node, value, immediately = true) => {
        exports.modifyText(node, value, undefined);
    };
    /**
     * @description 创建组件
     * @example
     */
    exports.createWidget = (node) => {
        // 处理相对tpl路径的组件
        let s = node.w.tpl.wpath;
        if (!s) {
            node.w.tpl.wpath = s = node.w.tpl.path.replace(/\//g, '-');
        }
        const w = widget_1.factory(widget_1.relative(node.tg, s));
        if (!w) {
            throw new Error(`widget not found, name: ${node.tg}`);
        }
        node.l = w;
        node.w.children.push(w);
        w.parentNode = node;
        if (node.cs || node.ch) {
            if (virtual_node_1.getAttribute(node.a, 'w_props')) {
                w.updateProps(node.ch);
            }
            else {
                w.setProps(node.ch);
            }
        }
        w.paint();
        if (node.w.inDomTree) {
            attachList.push([w]);
        }
        // if (node.aize) {
        node.ext = {};
        // }
        if (node.wc) {
            setAttrClazz(node, node.wc, node.wc, true);
        }
        const obj = node.a;
        for (const k in obj) {
            exports.setAttr(node, k, obj[k], true);
        }
        const event = node.e;
        for (const k in event) {
            setAttrEventListener(node, k, event[k]);
        }
        const style = node.s;
        for (const k in style) {
            setAttrStyle(node, k, style[k], true);
        }
        exports.setDiffStyle(node);
        // cmdCall(setDiffStyle, node, undefined, false);
        // cmdCall(setStyle, node.link.tree.link, mergeStyle(node.ext.r_innerStyle, node.ext.r_clazzStyle), false);
        exports.createHandler && exports.createHandler(node);
    };
    /**
     * @description 创建真实节点
     * @example
     */
    // tslint:disable-next-line:max-func-body-length
    exports.createNode = (node) => {
        const rnode = exports.vdocument.createElement(node.tg);
        node.l = rnode;
        node.l.virtual = node;
        if (virtual_node_1.asVirtualTextNode(node)) {
            exports.setAttrText(node, node.t);
            // } else if (asVirtualImageNode(node)) {
            //     setAttrSrc(<VirtualImageNode>node, (<VirtualImageNode>node).a.src);
        } // else {
        //}
        // if (node.aize) {
        node.ext = {};
        // }
        if (node.wc) {
            setAttrClazz(node, node.wc, node.wc, true);
        }
        const event = node.e;
        for (const k in event) {
            setAttrEventListener(node, k, event[k]);
        }
        const style = node.s;
        for (const k in style) {
            setAttrStyle(node, k, style[k], true);
        }
        exports.setDiffStyle(node);
        const obj = node.a;
        for (const k in obj) {
            exports.setAttr(node, k, obj[k], true);
        }
        exports.createHandler && exports.createHandler(node);
        if (rnode.hookAfterCreate) {
            rnode.hookAfterCreate();
        }
    };
    /**
     * @description 创建文本节点
     * @example
     */
    // export const createTextNode = (node: VirtualTextNode): void => {
    //     node.link = <RTextElement>vdocument.createTextNode(node.text);
    //     node.link.host = node;
    // };
    /**
     * @description 插入节点
     * @example
     */
    exports.insertNode = (parent, node, offset) => {
        // cmdList.push([insertBefore, [parent, getRealNode(node), offset]]);
        insertBefore(parent, exports.getRealNode(node), offset);
    };
    /**
     * @description 添加节点
     *
     * @example
     */
    exports.addNode = (parent, node, immediately = true) => {
        immediately = true;
        if (immediately) {
            parent.appendChild(exports.getRealNode(node));
        }
        else {
            cmdList.push([parent, 'appendChild', [exports.getRealNode(node)]]);
        }
    };
    /**
     * @description 删除节点，不仅要删除节点还要删除其下widget
     * @example
     */
    exports.delNode = (node) => {
        let r = node.l;
        if (virtual_node_1.asVirtualContainerNode(node)) {
            delChilds(node);
        }
        else if (virtual_node_1.asVirtualWidgetNode(node)) {
            util_1.arrDrop(node.w.children, r);
            const w = r;
            exports.delWidget(w);
            r = exports.getRealNode(w.tree);
        }
        r.remove();
        // cmdList.push([r, 'remove', []]);
    };
    /**
     * @description 修改组件节点的数据
     * @example
     */
    exports.modifyWidget = (node, newValue, oldValue) => {
        const w = node.l;
        if (node.ext && node.ext.propsUpdate) {
            w.updateProps(newValue, oldValue);
        }
        else {
            w.setProps(newValue, oldValue);
        }
        w.paint();
    };
    /**
     * @description 修改文本节点的文本
     * @example
     */
    exports.modifyText = (node, newValue, oldValue) => {
        // cmdList.push([node.l, 'nodeValue', newValue]);
        if (node.l) {
            node.l.nodeValue = newValue;
        }
        else {
            tools_1.Tools.warn(`node.l.nodeValue error`);
        }
    };
    /**
     * @description 修改Image节点的src
     * @example
     */
    exports.modifySrc = (node, newValue, oldValue) => {
        exports.setAttrSrc(node, newValue);
    };
    /**
     * @description 删除widget及其子widgets
     * @example
     */
    exports.delWidget = (w) => {
        if (!w.destroy()) {
            return;
        }
        if (w.inDomTree) {
            detachList.push([w]);
        }
        w.children && delWidgetChildren(w.children);
    };
    /**
     * @description 获得显示在真实的dom节点的组件名称
     * @example
     */
    exports.getShowWidgetName = (node, name) => {
        const n = virtual_node_1.asVirtualWidgetNode(node);
        // tslint:disable:prefer-template
        return (n) ? exports.getShowWidgetName(n.l.tree, name + ' ' + n.l.name) : name;
    };
    /**
     * @description 渲染Widget方法，如果当前正在渲染，则缓冲，渲染完成后会继续渲染该数据
     * @example
     */
    exports.paintWidget = (w, reset) => {
        const tpl = w.tpl;
        if (!tpl) {
            return;
        }
        const frameMgr = frame_mgr_1.getGlobal();
        if (cmdList.length === 0) {
            frameMgr.setBefore(paint1);
        }
        const tree = tpl.value(w.getConfig() || empty, w.getProps(), w.getState(), w);
        let old = w.tree;
        tree.w = w;
        if (old) {
            if (reset) {
                try {
                    w.beforeUpdate();
                    const arr = w.children;
                    for (const w of arr) {
                        exports.delWidget(w);
                    }
                    w.children = [];
                    virtual_node_1.create(tree);
                    const node = exports.getRealNode(tree);
                    node.setAttribute('w_tag', exports.getShowWidgetName(tree, w.name));
                    cmdList.push([replaceTree, [node, exports.getRealNode(old)]]);
                    cmdList.push([w, 'afterUpdate', []]);
                    w.tree = tree;
                }
                catch (e) {
                    log_1.cc.warn() && log_1.log('paint reset fail, ', w, e);
                }
            }
            else {
                const b = old.sH !== tree.sH
                    || old.aH !== tree.aH
                    || old.cH !== tree.cH
                    || old.eH !== tree.eH
                    || old.textHash !== tree.textHash
                    || exports.forceReplace;
                if (b) {
                    try {
                        w.beforeUpdate();
                        old = w.tree;
                        virtual_node_1.replace(old, tree);
                        cmdList.push([w, 'afterUpdate', []]);
                        w.tree = tree;
                    }
                    catch (e) {
                        log_1.cc.warn() && log_1.log('paint replace fail, ', w, e);
                        if (old.o < 0) {
                            fixOld(virtual_node_1.asVirtualContainerNode(old));
                        }
                    }
                }
            }
        }
        else {
            try {
                virtual_node_1.create(tree);
                exports.getRealNode(tree).setAttribute('w_tag', exports.getShowWidgetName(tree, w.name));
                w.tree = tree;
                w.firstPaint();
            }
            catch (e) {
                log_1.cc.warn() && log_1.log('paint create fail, ', w, e);
            }
        }
    };
    /**
     * @description 渲染命令2方法
     * @example
     */
    exports.paintCmd = (func, args) => {
        const frameMgr = frame_mgr_1.getGlobal();
        if (cmdList.length === 0) {
            frameMgr.setBefore(paint1);
        }
        cmdList.push([func, args]);
    };
    /**
     * @description 渲染命令3方法
     * @example
     */
    exports.paintCmd3 = (obj, funcOrAttr, args) => {
        const frameMgr = frame_mgr_1.getGlobal();
        if (cmdList.length === 0) {
            frameMgr.setBefore(paint1);
        }
        cmdList.push([obj, funcOrAttr, args]);
    };
    /**
     * @description 绘制时，添加组件，调用组件及子组件的attach方法
     * @example
     */
    exports.paintAttach = (w, notReal) => {
        attachList.push([w, notReal]);
    };
    /**
     * @description 绘制时，删除组件，调用组件及子组件的detach方法
     * @example
     */
    exports.paintDetach = (w, notReal) => {
        detachList.push([w, notReal]);
    };
    // ============================== 本地
    // 空配置
    const empty = {}; // 每个painter的指令都被放入其中
    let cmdList = [];
    // 每个被添加的widget
    let attachList = [];
    // 每个被删除的widget
    let detachList = [];
    // 临时变量
    let cmdList1 = [];
    let attachList1 = [];
    let detachList1 = [];
    /**
     * @description 最终的渲染方法，渲染循环时调用，负责实际改变dom
     * @example
     */
    const paint1 = () => {
        let arr = detachList;
        detachList = detachList1;
        detachList1 = arr;
        arr = cmdList;
        cmdList = cmdList1;
        cmdList1 = arr;
        arr = attachList;
        attachList = attachList1;
        attachList1 = arr;
        // 先调用所有要删除的widget的detach方法
        arr = detachList1;
        for (const w of arr) {
            paintDetach1(w[0], w[1]);
        }
        arr.length = 0;
        arr = cmdList1;
        for (const cmd of arr) {
            if (cmd.length === 3) {
                const args = cmd[2];
                if (Array.isArray(args)) {
                    util_1.objCall(cmd[0], cmd[1], args);
                }
                else {
                    cmd[0][cmd[1]] = args;
                }
            }
            else if (cmd.length === 2) {
                util_1.call(cmd[0], cmd[1]);
            }
        }
        // arr.length > 3 && level <= LogLevel.debug && debug(level, "painter cmd: ", arr.concat([]));
        arr.length = 0;
        // 调用所有本次添加上的widget的attach方法
        arr = attachList1;
        for (const w of arr) {
            paintAttach1(w[0], w[1]);
        }
        arr.length = 0;
    };
    /**
     * @description 删除子组件
     * @example
     */
    const delWidgetChildren = (arr) => {
        for (const w of arr) {
            if (w.destroy()) {
                delWidgetChildren(w.children);
            }
        }
    };
    /**
     * @description 绘制时，添加组件，调用组件及子组件的attach方法
     * @example
     */
    const paintAttach1 = (w, notReal) => {
        if (w.inDomTree) {
            return;
        }
        w.inDomTree = true;
        w.attach(notReal);
        for (const c of w.children) {
            paintAttach1(c, notReal);
        }
    };
    /**
     * @description 绘制时，删除组件，调用组件及子组件的detach方法
     * @example
     */
    const paintDetach1 = (w, notReal) => {
        if (!w.inDomTree) {
            return;
        }
        w.inDomTree = false;
        for (const c of w.children) {
            paintDetach1(c, notReal);
        }
        w.detach(notReal);
    };
    /**
     * @description 设置节点的style
     * @example
     */
    const setAttrStyle = (node, key, value, immediately) => {
        // node.ext.innerStyle = value ? parseEffect(value, node.widget.tpl.path) : null;
        // setDiffStyle(node, immediately);
        // node.ext.innerStyle = parseEffect2(key, value, node.ext.innerStyle);
        node.ext.r_innerStyle = node.ext.r_innerStyle || new Map();
        if (key === "borderImageSource") {
            value = analySrcPath(value, node.w); // 如果是相对路径， 转换为绝对路径
        }
        node.ext.r_innerStyle.set(key, value);
    };
    /**
     * @description 设置节点的clazz
     * @example
     */
    // const setAttrClazz = (node: VWNode, key: string, value: string, immediately?: boolean): void => {
    //     if (value) {
    //         const clazz = value.trim().split(/\s+/);
    //         if (clazz[0].length > 0) {
    //             node.ext.clazzStyle = calc(node.widget, clazz, clazz.join(' '), { map: new Map(), url: null });
    //         }
    //     } else {
    //         node.ext.clazzStyle = null;
    //     }
    //     setDiffStyle(node, immediately);
    // };
    const setAttrClazz = (node, key, value, immediately) => {
        // if (value) {
        //     const clazz = value.trim().split(/\s+/);
        //     if (clazz[0].length > 0) {
        //         node.ext.r_clazzStyle = calcClazz(node.w, clazz, clazz.join(' '), new Map());
        //     }
        // } else {
        //     node.ext.r_clazzStyle = null;
        // }
        // // setDiffStyle(node, immediately);
        const widgetInfo = widget_1.lookup(node.w.name);
        if (widgetInfo) {
            let wPath = widgetInfo.wPath;
            let wcsspath = widgetInfo.widcfg.css;
            if (wcsspath) {
                wcsspath = depend_1.relativePath(wcsspath, wPath).replace(/\//g, '-');
                const classID = hash_1.murmurhash3_32s(`${wcsspath}|.${value}`, 0);
                if (node.l instanceof widget_1.Widget) {
                    let rnode = node.l.tree.l;
                    let count = 0;
                    // tslint:disable-next-line:no-constant-condition
                    while (true) {
                        count++;
                        if (rnode instanceof r_element_1.RElement) {
                            break;
                        }
                        else {
                            rnode = rnode.tree.l;
                        }
                        if (count === 5) {
                            console.warn(`组件套用层次太深，请调整组件设计`);
                            break;
                        }
                    }
                    const defClassIDs = rnode.className;
                    if (!defClassIDs) {
                        rnode.className = [classID];
                    }
                    else {
                        rnode.className = [classID, ...defClassIDs];
                    }
                }
                else if (node.l instanceof r_element_1.RElement) {
                    node.l.className = [classID];
                }
            }
        }
    };
    /**
     * @description 设置节点的插件
     * @example
     */
    const setAttrPlugin = (node, cfg) => {
        let mod;
        const w = node.w;
        const old = node.ext.plugin;
        node.ext.plugin = cfg;
        new Promise((resolve_1, reject_1) => { require([depend_1.relativePath(cfg ? cfg.mod : old.mod, w.tpl.path)], resolve_1, reject_1); }).then((mod) => {
            mod.pluginBind && mod.pluginBind(w, node, cfg, old);
        });
    };
    /**
     * @description 设置节点的style
     * @example
     */
    exports.setDiffStyle = (node, immediately = true) => {
        // const ext   = node.ext;
        // const style = mergeStyle(ext.innerStyle, ext.clazzStyle);
        // const diff  = difference(ext.s, style);
        const ext = node.ext;
        // const style = mergeStyle(ext.r_innerStyle, ext.r_clazzStyle);
        // const diff  = differenceStyle(ext.r_style, style);
        // ext.r_style   = style;
        // 已经不需要r_clazzStyle了
        const diff = style_1.differenceStyle(ext.r_style, ext.r_innerStyle);
        ext.r_style = ext.r_innerStyle;
        if (!diff) {
            return;
        }
        const el = getFilterStyleRealNode(node, diff);
        if (!el) {
            return;
        }
        // loadURL(el, node.widget, diff);
        cmdCall(exports.setStyle, el, diff, immediately);
    };
    /**
     * @description 获得过滤样式后的真实的dom节点,如果过滤的样式不存在，则不向下获取dom节点
     * @example
     */
    // const getFilterStyleRealNode = (node: VWNode, diff: URLEffect): RElement => {
    const getFilterStyleRealNode = (node, diff) => {
        let n;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            n = virtual_node_1.asVirtualWidgetNode(node);
            if (!n) {
                return node.l;
            }
            node = n.l.tree;
            if (!node) {
                return null;
            }
            if (!node.ext) {
                continue;
            }
            // filter(node.ext.clazzStyle, diff);
            // filter(node.ext.innerStyle, diff);
            // filterStyle(node.ext.r_clazzStyle, diff);
            style_1.filterStyle(node.ext.r_innerStyle, diff);
            if (diff.size === 0) {
                return null;
            }
        }
    };
    /**
     * @description 设置节点的事件，因为并不影响显示，所以立即处理，而不是延迟到渲染时。因为vnode已经被改变，如果延迟，也是会有事件不一致的问题
     * @example
     */
    const setAttrEventListener = (node, key, value) => {
        // tslint:disable:no-reserved-keywords
        // const type = event.getEventType(key);
        const type = key;
        if (type.startsWith(event.USER_EVENT_PRE)) {
            event.addUserEventListener(node, key, type, value);
            return true;
        }
        if (type) {
            // event.addNativeEventListener(node, getRealNode(node), key, type, value);
            event.addNativeEventListener2(node, exports.getRealNode(node), key, type, value);
            return true;
        }
        return false;
    };
    /**
     * @description 命令属性设置
     * @example
     */
    const cmdSet = (obj, key, value, immediately = true) => {
        if (immediately) {
            obj[key] = value;
        }
        else {
            cmdList.push([obj, key, value]);
        }
    };
    /**
     * @description 命令方法调用
     * @example
     */
    const cmdCall = (func, arg1, arg2, immediately = true) => {
        if (immediately) {
            func(arg1, arg2);
        }
        else {
            cmdList.push([func, [arg1, arg2]]);
        }
    };
    /**
     * @description 命令方法调用
     * @example
     */
    const cmdObjCall = (obj, func, arg1, arg2, immediately = true) => {
        if (immediately) {
            obj[func](arg1, arg2);
        }
        else {
            cmdList.push([obj, func, [arg1, arg2]]);
        }
    };
    /**
     * @description 删除节点的子节点，不仅要删除节点还要删除其下widget
     * @example
     */
    const delChilds = (node) => {
        const arr = node.cd;
        for (const n of arr) {
            if (virtual_node_1.asVirtualContainerNode(n)) {
                delChilds(n);
            }
            else if (virtual_node_1.asVirtualWidgetNode(n)) {
                exports.delWidget(n.l);
            }
        }
    };
    // DOM 版本代码
    // /**
    //  * @description 设置元素的样式，跳过指定样式
    //  * @example
    //  */
    // export const setStyle = (el: RElement, style: URLEffect): void => {
    //     const s = el.s;
    //     const map = style.map;
    //     for (const [k, v] of map) {
    //         s[k] = v;
    //     }
    // };
    exports.setStyle = (el, style) => {
        if (el.isDestroy) {
            console.warn('节点已销毁！');
            return;
        }
        const s = el.style;
        const map = style;
        // Tools.log('setStyle', el.uniqueID);
        map.forEach((value, key) => {
            if (value === undefined) {
                key = tools_1.StyleMap[key];
                // Tools.log('setStyle', key, value);
                el.document.applyStyle(s, key, value);
            }
        });
        map.forEach((value, key) => {
            if (value !== undefined) {
                key = tools_1.StyleMap[key];
                // Tools.log('setStyle', key, value);
                // 如果是设置borderImageSource
                // if (key === "borderImageSource") {
                // 	value = Tools.borderImageSource(value);
                // }
                el.document.applyStyle(s, key, value);
            }
        });
    };
    exports.setOneStyle = (el, key, value) => {
        const s = el.style;
        // Tools.log('setStyle', el.uniqueID);
        // Tools.log('setStyle', key, value);
        el.document.applyStyle(s, key, value);
    };
    // RElement.loadImageCall = (src: string, cb: (cfg: ImageDecs) => void) => {
    // 	src = analySrcPath(src, node.w);
    // 	const srcOrg    = src;
    // 	let ImageDecs: ImageDecs;
    // 	// 如果depend中不存在该图片， 则图片可能被合并了， 从合并图片集中取出图片的描述信息
    // 	if (!getFile(src)) { 
    // 		ImageDecs = CombineImageMgr.getImageDecs(src);
    // 	}
    // 	if (ImageDecs) {
    // 		// tslint:disable-next-line:variable-name
    // 		// const _cfg: GUIImageResCfg = GUIRes.createGUIImageResCfg(ImageDecs, src, ImageDecs.combineUrl);
    // 		if (!rnode.isDestroy) {
    // 			if (ImageDecs && rnode._type === 'div') {
    // 				if (rnode.document.readStyle(rnode.style, 'borderImageClip')) {
    // 					Tools.warn(`不能为使用合并图片集的DIV设置 borderImageClip`);
    // 				} else {
    // 					rnode.document.applyStyle(
    // 						rnode.style,
    // 						'borderImageClip',
    // 						[ImageDecs.top, ImageDecs.left + ImageDecs.width, ImageDecs.top + ImageDecs.height, ImageDecs.left, 0]
    // 					);
    // 				}
    // 			}
    // 			cb(ImageDecs as any);
    // 		}
    // 	} else {
    // 		const callBack = (path: string, cfg: GUIImageRes) => {
    // 			if (rnode.isDestroy) { return; }
    // 			// tslint:disable-next-line:variable-name
    // 			const _cfg: ImageDecs = <any>{};
    // 			_cfg.path               = srcOrg;
    // 			_cfg.url                = cfg.url;
    // 			_cfg.image              = cfg.image;
    // 			_cfg.width              = cfg.width;
    // 			_cfg.height             = cfg.height;
    // 			_cfg.textureID          = cfg.textureID;
    // 			_cfg.combineSrcWidth    = cfg.combineSrcWidth;
    // 			_cfg.combineSrcHeight   = cfg.combineSrcHeight;
    // 			if (!rnode.isDestroy) {
    // 				if (ImageDecs && rnode._type === 'div') {
    // 					_cfg.width               = ImageDecs.width;
    // 					_cfg.height              = ImageDecs.height;
    // 					_cfg.isCombine           = true;
    // 					_cfg.combineWidth        = ImageDecs.width;
    // 					_cfg.combineHeight       = ImageDecs.height;
    // 					_cfg.combineLeft         = ImageDecs.left;
    // 					_cfg.combineTop          = ImageDecs.top;
    // 					if (rnode.document.readStyle(rnode.style, 'borderImageClip')) {
    // 						Tools.warn(`不能为使用合并图片集的DIV设置 borderImageClip`);
    // 					} else {
    // 						rnode.document.applyStyle(
    // 							rnode.style,
    // 							'borderImageClip',
    // 							[ImageDecs.top, ImageDecs.left + ImageDecs.width, ImageDecs.top + ImageDecs.height, ImageDecs.left, 0]
    // 						);
    // 					}
    // 				}
    // 				cb(_cfg);
    // 			}
    // 		};
    // 		loadSrcNormal(node.w, src, callBack);
    // 	}
    // };
    /**
     * @description 插入节点
     * @example
     */
    const insertBefore = (parent, el, offset) => {
        parent.insertBefore(el, parent.childNodes[offset]);
    };
    /**
     * @description 删除树节点
     * @example
     */
    const replaceTree = (newEl, oldEl) => {
        const parent = oldEl.parentNode;
        parent && parent.replaceChild(newEl, oldEl);
    };
    /**
     * 计算目标路径的项目路径
     * @param src tpl 中的路径
     * @param widget 所属 Widget
     */
    const analySrcPath = (src, widget) => {
        if (src.indexOf(':') < 0) {
            src = depend_1.relativePath(src, widget.tpl.path);
        }
        return src;
    };
    // /**
    //  * @description 替换图像的src
    //  * @example
    //  */
    // const loadSrc = (el: RElement, widget: Widget, src: string, immediately: boolean = true): void => {
    //     const url = analySrcPath(src, widget);
    //     // (<RImageElement>el).promiseSrc = url;
    //     let ImageDecs: ImageDecs;
    // 	if (!getFile(url)) { 
    // 		ImageDecs = CombineImageMgr.getImageDecs(url);
    // 	}
    // 	if (ImageDecs) {
    // 		// const _cfg: GUIImageResCfg = GUIRes.createGUIImageResCfg(ImageDecs, srcOrg, src);
    //         // el.attributes.imageClip = [ImageDecs.top, ImageDecs.left + ImageDecs.width, ImageDecs.top + ImageDecs.height, ImageDecs.left, 0];
    // 		ImageDecs.srcUrl = url;
    //         (<RImageElement>el).src = ImageDecs as any;
    // 	} else {
    //         const callBack = (_path: string, cfg: ImageDecs) => {
    // 			if (el.isDestroy) { return; }
    //             (<RImageElement>el).src = cfg;
    // 		};
    //         loadSrcNormal(widget, src, callBack);
    //     }
    // };
    /**
     * @description 替换图像的src
     * @example
     */
    const loadSrc = (el, widget, src, immediately = true) => {
        const url = analySrcPath(src, widget);
        el.src = url;
        // // (<RImageElement>el).promiseSrc = url;
        // let ImageDecs: ImageDecs;
        // if (!getFile(url)) { 
        // 	ImageDecs = CombineImageMgr.getImageDecs(url);
        // }
        // if (ImageDecs) {
        // 	// const _cfg: GUIImageResCfg = GUIRes.createGUIImageResCfg(ImageDecs, srcOrg, src);
        //     // el.attributes.imageClip = [ImageDecs.top, ImageDecs.left + ImageDecs.width, ImageDecs.top + ImageDecs.height, ImageDecs.left, 0];
        // 	ImageDecs.srcUrl = url;
        //     (<RImageElement>el).src = ImageDecs as any;
        // } else {
        //     const callBack = (_path: string, cfg: ImageDecs) => {
        // 		if (el.isDestroy) { return; }
        //         (<RImageElement>el).src = cfg;
        // 	};
        //     loadSrcNormal(widget, src, callBack);
        // }
    };
    /**
     * 节点加载图片资源
     * @param widget ：
     * @param src ：
     * @param cb ：
     */
    const loadSrcNormal = (widget, src, cb) => {
        let tab = widget.resTab;
        if (!tab) {
            widget.resTab = tab = new res_mgr_1.ResTab();
        }
        const name = res_mgr_2.GUI_IMAGE_TYPE + ':' + src;
        const res = tab.get(name, false);
        if (res) {
            // paintCmd(cb, [src, res.link]);
            cb(src, res.link);
            // res.unuse(10,0);
            // cmdList.push([cb, [res.link]]);
        }
        else {
            tab.load(res_mgr_2.GUI_IMAGE_TYPE, src, []).then((res) => {
                cb(src, res.link);
            });
        }
        // let url = getTransWebpName(src);
        // url = getFile(url).path;
        // url = `${depend.httpDomains[0]}${depend.rootDomains()}${depend.rootPath()}${url}`;
        // RDocument.createImageSrc()
    };
    // DOM 版本代码
    // /**
    //  * @description 替换含URL的样式或图像的src
    //  * @example
    //  */
    // const loadURL = (el: RElement, widget: Widget, style: URLEffect): void => {
    //     let tab = widget.resTab;
    //     const url = style.url;
    //     if (!url) {
    //         return;
    //     }
    //     if (!tab) {
    //         widget.resTab = tab = new ResTab();
    //     }
    //     const arr = url.arr.concat();
    //     let count = (arr.length / 2) | 0;
    //     for (let i = arr.length - 2; i > 0; i -= 2) {
    //         const file = arr[i];
    //         const name = RES_TYPE_BLOB + ':' + file;
    //         const res = tab.get(name);
    //         if (res) {
    //             arr[i] = res.link;
    //             count--;
    //             if (count <= 0) {
    //                 style.map.set(url.key, arr.join(''));
    //             }
    //         } else {
    //             tab.load(name, RES_TYPE_BLOB, file, undefined, urlLoad(arr, i, () => {
    //                 count--;
    //                 if (count <= 0) {
    //                     paintCmd3(el.style, url.key, arr.join(''));
    //                 }
    //             }));
    //         }
    //     }
    // };
    // DOM 版本代码
    // /**
    //  * @description 替换含URL的样式或图像的src
    //  * @example
    //  */
    // const urlLoad = (arr: string[], i: number, callback: Function): Function => {
    //     return (res) => {
    //         arr[i] = res.link;
    //         callback();
    //     };
    // };
    /**
     * @description 尽量修复旧节点，已经重绑定的事件和发出的渲染指令还是会生效
     * @example
     */
    const fixOld = (old) => {
        if (!old) {
            return;
        }
        const arr = old.cd;
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (n.o >= 0) {
                continue;
            }
            n.o = i;
            fixOld(virtual_node_1.asVirtualContainerNode(n));
        }
    };
    exports.initGUI = (canvas, fbo, opt, renderFlag = r_datastruct_1.GUIRenderFlags.BIND) => {
        exports.vdocument = new r_document_1.RDocument(canvas, fbo, opt, renderFlag);
        window.vdocument = exports.vdocument;
        // const frame = getGlobal();
        // frame.setPermanent(vdocument.render);
        res_mgr_2.GUIRes.Init(exports.vdocument.uniqueID);
        // 设置 widget enabled 查询接口
        exports.vdocument.askWidgetClosedCall = (ele) => {
            let result = false;
            if (ele.virtual) {
                let w = ele.virtual.w;
                // tslint:disable-next-line:no-constant-condition
                while (true) {
                    // 不存在 组件
                    if (!w) {
                        break;
                    }
                    // 组件 enable === false
                    if (w.isClosed()) {
                        result = true;
                        break;
                    }
                    if (!w.parentNode) {
                        break;
                    }
                    w = w.parentNode.w;
                }
            }
            return result;
        };
        // 设置 widget enabled 查询接口
        exports.vdocument.askWidgetEnableCall = (ele) => {
            let result = true;
            if (ele.virtual) {
                let w = ele.virtual.w;
                // tslint:disable-next-line:no-constant-condition
                while (true) {
                    // 不存在 组件
                    if (!w) {
                        break;
                    }
                    // 组件 enable === false
                    if (!w.widgetEnabled()) {
                        result = false;
                        break;
                    }
                    if (!w.parentNode) {
                        break;
                    }
                    w = w.parentNode.w;
                }
            }
            return result;
        };
        math_tools_1.MathTools.Init();
        return exports.vdocument;
    };
});

/**
 * GUI 根上管理层级和界面显示与隐藏
 * * 实现性能优化
 * * 实现与 3D 场景的同屏显示
 */
_$pi.define("pi_gui/gui/gui_root/root_manager", ["require", "exports", "../gui_virtual/painter", "../gui_virtual/widget", "../../util/event", "../gui_virtual/virtaul_node_keyword", "../gui/tools", "./beforeInit"], function (require, exports, painter_1, widget_1, event_1, virtaul_node_keyword_1, tools_1, beforeInit_1) {
    "use strict";
    
    exports.PageOpenDebug = {
        tempTime: 0,
        active: false,
        BeforePageOpen: (name) => {
            exports.PageOpenDebug.tempTime = Date.now();
            tools_1.Tools.warn(`${name} Open Start: ${exports.PageOpenDebug.tempTime}`);
        },
        AfterPageOpen: (name) => {
            const now = Date.now();
            tools_1.Tools.warn(`${name} Open Start: ${now}`);
            tools_1.Tools.warn(`${name} Open Use: ${now - exports.PageOpenDebug.tempTime}`);
        }
    };
    // 层级配置
    exports.GroupsList = [
        { name: 'background' },
        { name: 'scene' },
        { name: 'main' },
        { name: 'guide_scene' },
        { name: 'secondary' },
        { name: 'top' },
        { name: 'login' },
        // 半透明界面---暂停场景更新
        { name: 'cover' },
        { name: 'cover_pop' },
        // 半透明提示
        { name: 'top_tip' },
        { name: 'guide' },
        { name: 'pop_tip' },
        { name: 'screen' },
        { name: 'download' },
        { name: 'connect' },
        { name: 'offLine' }
    ];
    // tslint:disable-next-line:no-unnecessary-class
    class RootManager {
        /**
         * 更改指定组的可视性
         */
        static visibleGroup(name, b) {
            const group = RootManager.findGroup(name);
            if (group !== undefined) {
                if (b === false) {
                    group.disVisibleCall();
                }
                else {
                    group.visibleCall();
                }
            }
        }
        /**
         * 添加组配置
         * @param name 组名称
         * @param container 组根节点
         */
        static addGroup(name, container) {
            const group = RootManager.findGroup(name);
            if (group) {
                group.container = container;
                group.el = container;
                group.name = name;
                group.widgets = [];
                group.arr = group.widgets;
                group.visible = 0;
                group.disVisibleHandler = undefined;
                group.visibleCall = () => {
                    group.visible = 1;
                    painter_1.setOneStyle(container, 'display', 'flex');
                };
                group.disVisibleCall = () => {
                    group.visible = 0;
                    painter_1.setOneStyle(container, 'display', 'none');
                };
                group.visibleCall();
                RootManager.groupMap.set(name, group);
            }
            else {
                console.error(`不存在层级配置: ${name}`);
            }
        }
        static findGroupIndex(groupName) {
            let index = -1;
            for (let i = 0, len = exports.GroupsList.length - 1; i <= len; i++) {
                if (exports.GroupsList[i].name === groupName) {
                    index = i;
                    break;
                }
            }
            return index;
        }
        static findGroup(groupName) {
            let res;
            for (let i = 0, len = exports.GroupsList.length - 1; i <= len; i++) {
                if (exports.GroupsList[i].name === groupName) {
                    res = exports.GroupsList[i];
                    break;
                }
            }
            return res;
        }
        // tslint:disable-next-line:max-func-body-length
        static updateGroupVisible(isBasFrameAdd) {
            let tempContainer, isVisible, isGetNoAlphaUI, hasAlpha_Top_Cover, childContainer, groupCfg;
            const startAlphaIndex = RootManager.findGroupIndex(RootManager.lastNoAlphaGroup);
            const startAlphaTipIndex = startAlphaIndex;
            isVisible = false;
            isGetNoAlphaUI = false;
            hasAlpha_Top_Cover = false;
            // 半透明 - tip
            for (let index = exports.GroupsList.length - 1; index >= startAlphaTipIndex; index--) {
                groupCfg = exports.GroupsList[index];
                tempContainer = groupCfg.container;
                isVisible = RootManager.hasVisibleChild(tempContainer);
                RootManager.visibleGroup(groupCfg.name, isVisible);
            }
            // // 半透明 - 界面 打开时，停止场景动画
            // for (let index = startAlphaTipIndex - 1; index >= startAlphaIndex; index--) {
            //     groupCfg        = GroupsList[index];
            //     tempContainer   = groupCfg.container;
            //     isVisible       = tempContainer.childNodes.length > 0;
            //     if (hasAlpha_Top_Cover === false) {
            //         hasAlpha_Top_Cover = isVisible;
            //         if (hasAlpha_Top_Cover) {
            //             // RootManager.beforeTipPop();
            //         }
            //     }
            //     RootManager.visibleGroup(groupCfg.name, isVisible);
            // }
            if (hasAlpha_Top_Cover === false) {
                // RootManager.afterTipHide();
            }
            // 不透明界面
            for (let index = startAlphaIndex; index >= 0; index--) {
                groupCfg = exports.GroupsList[index];
                tempContainer = groupCfg.container;
                if (!isGetNoAlphaUI) {
                    let enableCounter = 0;
                    let disenableCounter = 0;
                    tempContainer.childNodes.forEach((control) => {
                        if (
                        // tempContainer.attributes.asBG ||
                        !tempContainer.document.askWidgetEnableCall ||
                            tempContainer.document.askWidgetEnableCall(control)) {
                            if (!tempContainer.document.askWidgetClosedCall || !tempContainer.document.askWidgetClosedCall(control)) {
                                enableCounter++;
                            }
                        }
                        else {
                            if (!tempContainer.document.askWidgetClosedCall || tempContainer.document.askWidgetClosedCall(control)) {
                                disenableCounter++;
                            }
                        }
                    });
                    if (enableCounter > 0) {
                        isGetNoAlphaUI = true;
                        isVisible = true;
                    }
                    else {
                        isVisible = disenableCounter !== 0;
                    }
                    RootManager.visibleGroup(groupCfg.name, isVisible);
                    // 层内部显示优化
                    if (isVisible === true) {
                        let enableCounter = 0;
                        for (let len = tempContainer.childNodes.length - 1; len >= 0; len--) {
                            childContainer = (tempContainer.childNodes[len]);
                            if (childContainer) {
                                if (
                                // tempContainer.attributes.asBG ||
                                false) {
                                    painter_1.setOneStyle(childContainer, 'display', 'flex');
                                }
                                else {
                                    if (!tempContainer.document.askWidgetClosedCall || !tempContainer.document.askWidgetClosedCall(childContainer)) {
                                        if (!tempContainer.document.askWidgetEnableCall || tempContainer.document.askWidgetEnableCall(childContainer)) {
                                            enableCounter++;
                                        }
                                        painter_1.setOneStyle(childContainer, 'display', enableCounter <= 1 ? 'flex' : 'none');
                                    }
                                    else {
                                        painter_1.setOneStyle(childContainer, 'display', 'none');
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    isVisible = false;
                    RootManager.visibleGroup(groupCfg.name, isVisible);
                }
            }
            // 不透明 - 场景/背景
        }
        /**
         * 打开一个界面 - 只有唯一实例的界面
         * @param wname 组件名称
         * @param props 组件数据
         * @param ok ok 回调
         * @param cancel cancel 回调
         * @param process ？
         * @param back back 回调
         */
        static open(wname, props, ok, cancel, process, back) {
            if (RootManager.openMap.get(wname)) {
                return;
            }
            else {
                exports.PageOpenDebug.BeforePageOpen && exports.PageOpenDebug.BeforePageOpen(wname);
                let w = RootManager.closeMap.get(wname);
                if (w) {
                    RootManager.closeMap.delete(wname);
                    if (props !== undefined) {
                        w.updateProps(props);
                    }
                    w.paint();
                    // tslint:disable-next-line:no-object-literal-type-assertion
                    const node = {
                        [virtaul_node_keyword_1.VNKeyWords.attrs]: {},
                        [virtaul_node_keyword_1.VNKeyWords.attrSize]: 0,
                        [virtaul_node_keyword_1.VNKeyWords.attrHash]: 0,
                        [virtaul_node_keyword_1.VNKeyWords.link]: w,
                        [virtaul_node_keyword_1.VNKeyWords.widget]: RootManager.rootWidget,
                        [virtaul_node_keyword_1.VNKeyWords.childHash]: 0xffffffff,
                        [virtaul_node_keyword_1.VNKeyWords.child]: null
                    };
                    w.parentNode = node;
                    w.openHook();
                    const cfg = w.getConfig();
                    const name = cfg && cfg.group;
                    const group = RootManager.findGroup(name || 'main');
                    RootManager.listenerList({ type: 'add', widget: w, group: group });
                }
                else {
                    w = RootManager.create(wname, props);
                    RootManager.add(w);
                }
                if (widget_1.Widget.UseBackgroundList.indexOf(wname) >= 0) {
                    RootManager.openMap.set(wname, w);
                }
                exports.PageOpenDebug.AfterPageOpen && exports.PageOpenDebug.AfterPageOpen(wname);
                return w;
            }
        }
        /**
         * 打开一个界面 - 只有唯一实例的界面
         * @param wname 组件名称
         * @param props 组件数据
         * @param ok ok 回调
         * @param cancel cancel 回调
         * @param process ？
         * @param back back 回调
         */
        static popNew(wname, props, ok, cancel, process, back) {
            if (RootManager.openMap.get(wname)) {
                return;
            }
            else {
                exports.PageOpenDebug.BeforePageOpen && exports.PageOpenDebug.BeforePageOpen(wname);
                let w = RootManager.closeMap.get(wname);
                if (w) {
                    RootManager.closeMap.delete(wname);
                    if (props !== undefined) {
                        w.updateProps(props);
                    }
                    w.paint();
                    // tslint:disable-next-line:no-object-literal-type-assertion
                    const node = {
                        [virtaul_node_keyword_1.VNKeyWords.attrs]: {},
                        [virtaul_node_keyword_1.VNKeyWords.attrSize]: 0,
                        [virtaul_node_keyword_1.VNKeyWords.attrHash]: 0,
                        [virtaul_node_keyword_1.VNKeyWords.link]: w,
                        [virtaul_node_keyword_1.VNKeyWords.widget]: RootManager.rootWidget,
                        [virtaul_node_keyword_1.VNKeyWords.childHash]: 0xffffffff,
                        [virtaul_node_keyword_1.VNKeyWords.child]: null
                    };
                    w.parentNode = node;
                    w.openHook();
                    const cfg = w.getConfig();
                    const name = cfg && cfg.group;
                    const group = RootManager.findGroup(name || 'main');
                    RootManager.listenerList({ type: 'add', widget: w, group: group });
                }
                else {
                    w = RootManager.create(wname, props);
                    RootManager.add(w);
                }
                const close = RootManager.pop(w, ok, cancel, process, back, props);
                const c = close.callback;
                close.callback = (w) => {
                    // popNew创建的，关闭需要销毁
                    RootManager.backClose(w);
                    RootManager.destory(w);
                };
                if (widget_1.Widget.UseBackgroundList.indexOf(wname) >= 0) {
                    RootManager.openMap.set(wname, w);
                }
                exports.PageOpenDebug.AfterPageOpen && exports.PageOpenDebug.AfterPageOpen(wname);
                return close;
            }
        }
        /**
         * 打开一个弹窗/提示/界面 - 具有复数个实例
         * @param name 组件名称
         * @param props 组件数据
         * @param ok ok 回调
         * @param cancel cancel 回调
         * @param process ？
         * @param back back 回调
         */
        static openTip(name, props, ok, cancel, process, back) {
            exports.PageOpenDebug.BeforePageOpen && exports.PageOpenDebug.BeforePageOpen(name);
            const w = RootManager.create(name, props);
            RootManager.add(w);
            const close = RootManager.pop(w, ok, cancel, process, back, props);
            const c = close.callback;
            close.callback = (w) => {
                // popNew创建的，关闭需要销毁
                RootManager.backClose(w);
                RootManager.destory(w);
            };
            exports.PageOpenDebug.AfterPageOpen && exports.PageOpenDebug.AfterPageOpen(name);
            return close;
        }
        static create(wname, props) {
            const w = widget_1.factory(wname);
            if (!w) {
                return;
            }
            if (props !== undefined) {
                w.setProps(props);
            }
            w.paint();
            return w;
        }
        static pop(w, ok, cancel, process, back, originProps) {
            const b = { widget: w, callback: null };
            const close = { widget: w, callback: RootManager.backClose };
            if (back === undefined || back === 'cancel') {
                b.callback = () => {
                    close.callback(close.widget);
                    cancel && cancel('back');
                };
            }
            else if (back === 'next') {
                b.callback = () => {
                    close.callback(close.widget);
                    cancel && cancel('back');
                    RootManager.backCall();
                };
            }
            else if (back !== 'force') {
                b.callback = back;
            }
            RootManager.backList.push(b);
            let r;
            let propsSensitive = false;
            for (let i = 0; i < RootManager.routerList.length; i++) {
                const props = RootManager.routerList[i].props;
                if (props && props.pi_norouter) {
                    propsSensitive = true;
                    break;
                }
            }
            if ((w && w.props && w.props.pi_norouter) || propsSensitive) {
                r = { name: b.widget.name, props: { pi_norouter: true } };
            }
            else {
                r = { name: b.widget.name, props: originProps };
            }
            RootManager.routerList.push(r);
            RootManager.routerListSerialize();
            // 设置回调
            w.ok = w.$ok = (arg) => {
                close.callback(close.widget);
                ok && ok(arg);
            };
            w.cancel = w.$cancel = (arg) => {
                close.callback(close.widget);
                cancel && cancel(arg);
            };
            w.process = w.$process = process;
            return close;
        }
        static remove(w) {
            if (RootManager.openMap.get(w.name)) {
                if (!w.parentNode) {
                    return;
                }
                const cfg = w.getConfig();
                const name = cfg && cfg.group;
                const group = RootManager.findGroup(name || 'main');
                painter_1.paintDetach(w, true);
                w.parentNode = null;
                RootManager.listenerList({ type: 'remove', widget: w, group: group });
            }
            else {
                if (!w.parentNode) {
                    return;
                }
                w.parentNode = null;
                // paintCmd3(getRealNode(w.tree), 'remove', []);
                painter_1.getRealNode(w.tree).remove();
                painter_1.paintDetach(w);
                const cfg = w.getConfig();
                const name = cfg && cfg.group;
                const group = RootManager.findGroup(name || 'main');
                if (!group) {
                    return;
                }
                const i = group.arr.indexOf(w);
                if (i < 0) {
                    return;
                }
                group.arr.splice(i, 1);
                RootManager.updateGroupVisible();
                RootManager.listenerList({ type: 'remove', widget: w, group: group });
            }
        }
        static hasVisibleChild(node) {
            let res = false;
            if (node.childNodes && node.childNodes.length > 0) {
                for (let i = node.childNodes.length - 1; i >= 0; i--) {
                    if (node.childNodes[i].display === true) {
                        res = true;
                        break;
                    }
                }
            }
            return res;
        }
        static hasEnableChild(node) {
            let res = false;
            if (node.childNodes && node.childNodes.length > 0) {
                for (let i = node.childNodes.length - 1; i >= 0; i--) {
                    if (node.childNodes[i].display === true) {
                        res = true;
                        break;
                    }
                }
            }
            return res;
        }
    }
    exports.RootManager = RootManager;
    // 根组件
    RootManager.rootWidget = null;
    RootManager.root = null;
    // 是否记录页面路由信息
    RootManager.routerRecord = true;
    RootManager.openMap = new Map();
    RootManager.closeMap = new Map();
    RootManager.lastNoAlphaGroup = 'cover';
    RootManager.groupMap = new Map();
    /**
     * @description 导出的监听器列表
     * @example
     */
    RootManager.listenerList = event_1.createHandlerList();
    // 返回记录
    RootManager.backList = [];
    // 路由记录
    RootManager.routerList = [];
    // 禁止返回
    RootManager.forbidBack = false;
    // 禁止默认滚动
    RootManager.preventScroll = false;
    RootManager.setRootWidget = (w) => {
        RootManager.rootWidget = w;
    };
    RootManager.setRoot = (el) => {
        RootManager.root = el;
    };
    /**
     * @description 显示或隐藏组
     * @example
     */
    RootManager.show = (groupName, b) => {
        const group = RootManager.findGroup(groupName || 'main');
        if (!group) {
            return;
        }
        RootManager.visibleGroup(group, b);
    };
    /**
     * @description 将指定的组件移除并销毁
     * @example
     */
    RootManager.destory = (w) => {
        tools_1.Tools.warn(`destroy : ${w.name}`);
        // 清除回调
        w.ok = w.$ok = undefined;
        w.cancel = w.$cancel = undefined;
        w.process = w.$process = undefined;
        if (RootManager.openMap.get(w.name)) {
            RootManager.openMap.delete(w.name);
            w.closeHook();
            const cfg = w.getConfig();
            const name = cfg && cfg.group;
            const group = RootManager.findGroup(name || 'main');
            RootManager.listenerList({ type: 'remove', widget: w, group: group });
            RootManager.closeMap.set(w.name, w);
        }
        else {
            RootManager.remove(w);
            painter_1.delWidget(w);
        }
        beforeInit_1.BeforeInitTools.recordDestroy();
    };
    /**
     * @description 返回调用，返回弹出界面的数量
     * @example
     */
    RootManager.backCall = () => {
        const h = RootManager.backList[RootManager.backList.length - 1];
        h.callback && h.callback(h.widget);
        RootManager.routerList.pop();
        RootManager.routerListSerialize();
        return RootManager.backList.length;
    };
    /**
     * @description 返回关闭
     * @example
     */
    RootManager.backClose = (w) => {
        RootManager.remove(w);
        w.ok = w.$ok = null;
        w.cancel = w.$cancel = null;
        w.process = w.$process = null;
        RootManager.backList.pop();
        RootManager.routerList.pop();
        RootManager.routerListSerialize();
    };
    /**
     * @description 将指定的组件，根据组件上的配置，将组件加入到指定的组上，会延迟到帧调用时添加
     * @example
     */
    RootManager.add = (w, props) => {
        // root.appendChild(getRealNode(w.tree));
        // paintCmd3(root, 'appendChild', [getRealNode(w.tree)]);
        // return;
        const cfg = w.getConfig();
        const name = cfg && cfg.group;
        const group = RootManager.findGroup(name || 'main');
        if (!group) {
            return;
        }
        if (w.parentNode) {
            return;
        }
        group.arr.push(w);
        if (props !== undefined) {
            w.setProps(props);
            w.paint();
        }
        // tslint:disable-next-line:no-object-literal-type-assertion
        const node = {
            [virtaul_node_keyword_1.VNKeyWords.attrs]: {},
            [virtaul_node_keyword_1.VNKeyWords.attrSize]: 0,
            [virtaul_node_keyword_1.VNKeyWords.attrHash]: 0,
            [virtaul_node_keyword_1.VNKeyWords.link]: w,
            [virtaul_node_keyword_1.VNKeyWords.widget]: RootManager.rootWidget,
            [virtaul_node_keyword_1.VNKeyWords.childHash]: 0xffffffff,
            [virtaul_node_keyword_1.VNKeyWords.child]: null
        };
        w.parentNode = node;
        // TODO 计算进场动画时间和是否透明
        // paintCmd3(group.el, 'appendChild', [getRealNode(w.tree)]);
        group.el.appendChild(painter_1.getRealNode(w.tree));
        painter_1.paintAttach(w);
        RootManager.updateGroupVisible();
        RootManager.listenerList({ type: 'add', widget: w, group: group });
    };
    // 序列化routerList
    RootManager.routerListSerialize = () => {
        if (RootManager.routerRecord) {
            localStorage.setItem('pi_router_list', JSON.stringify(RootManager.routerList));
        }
    };
});

/*
负责进行业务逻辑处理，是数据库和显示组件间的桥梁， 输入->逻辑计算->输出
输入：
1、用户事件
2、数据库中数据被修改的事件
3、网络事件

输出：
1、操作数据库（同步）
2、网络通信（异步）
3、生成显示数据，调用paint，显示到界面上（可选同步或异步）

为了平滑显示，复杂的处理逻辑应该使用任务管理器进行调度处理
*/
_$pi.define("pi_gui/gui/gui_virtual/forelet", ["require", "exports", "../../../pi_sys/modules/util/event", "../../../pi_sys/modules/util/task_mgr"], function (require, exports, event_1, task_mgr_1) {
    "use strict";
    
    // ============================== 导出
    /**
     * 前端部件
     */
    class Forelet extends event_1.HandlerTable {
        constructor() {
            super(...arguments);
            // 必须要赋初值，不然new出来的实例里面是没有这些属性的
            this.widgets = []; // 关联的组件
            this.listener = null; // 监听器
            // tslint:disable:variable-name
            this._data = null; // 延迟渲染的数据
            this._dataState = DataState.init; // 延迟渲染的状态
            this._args = [this];
        }
        /**
         * @description 添加widget，自动在widget创建时调用
         * @example
         */
        addWidget(w) {
            this.listener && this.listener('add', w);
            w.setState(this._data);
            this.widgets.push(w);
        }
        /**
         * @description widget事件
         * @example
         */
        // tslint:disable:no-reserved-keywords
        eventWidget(w, type) {
            this.listener && this.listener(type, w);
        }
        /**
         * @description widget被移除，自动在widget销毁时调用
         * @example
         */
        removeWidget(w) {
            const arr = this.widgets;
            const i = arr.indexOf(w);
            if (i < 0) {
                return;
            }
            if (i < arr.length - 1) {
                arr[i] = arr[arr.length - 1];
            }
            arr.length--;
            this.listener && this.listener('remove', w);
        }
        /**
         * @description 获取指定名称的widget
         * @example
         */
        getWidget(name) {
            const arr = this.widgets;
            for (const w of arr) {
                if (w.name === name) {
                    return w;
                }
            }
        }
        /**
         * @description 绘制方法，
         * @parms reset表示新旧数据差异很大，不做差异计算，直接生成dom
         * @parms immediately，表示同步计算dom，不延迟到系统空闲时
         * @example
         */
        paint(data, reset, immediately) {
            const s = this._dataState;
            // tslint:disable:no-constant-condition
            this._dataState = (reset || s === DataState.reset_true) ? DataState.reset_true : DataState.reset_false;
            this._data = data;
            if (immediately) {
                return paint1(this);
            }
            if (s === DataState.init) {
                if (this.widgets.length > 0) {
                    task_mgr_1.set(paint1, this._args, 900000, 1);
                }
                else {
                    this._dataState = DataState.init;
                }
            }
        }
    }
    exports.Forelet = Forelet;
    // ============================== 本地
    /**
     * @description 处理器返回值
     */
    var DataState;
    (function (DataState) {
        DataState[DataState["init"] = 0] = "init";
        DataState[DataState["reset_false"] = 1] = "reset_false";
        DataState[DataState["reset_true"] = 2] = "reset_true";
    })(DataState || (DataState = {}));
    /**
     * @description 绘制方法，
     * @example
     */
    const paint1 = (f) => {
        const data = f._data;
        const r = f._dataState === DataState.reset_true;
        f._dataState = DataState.init;
        for (const w of f.widgets) {
            w.setState(data);
            w.paint(r);
        }
    };
});
// ============================== 立即执行

// 模块描述
/*
负责显示逻辑，是数据和原始dom间的桥梁
组件支持嵌套，并且tpl中的自定义元素支持相对路径。
组件名的规则：可以使用英文小写字母加'_'和''。 '-'表示路径分隔，'$'只能在最后，1个'$'表示本目录开始查找，N个'$'表示上溯N-1个父目录开始查找。如果没有'$'表示从根目录下开始查找
举例：
<role_show$ style=""></role_show$>表示本目录下的role_show组件，
<role_show$$ style=""> </role_show$$>表示父目录下的role_show组件，
<role_show-zb_show$$ style=""></role_show-zb_show$$>表示父目录下role_show目录下的zb_show组件
<app-base-btn style=""></app-base-btn>表示根目录开始，app/base目录下的btn组件
*/
_$pi.define("pi_gui/gui/gui_virtual/widget", ["require", "exports", "../gui/animation_tools", "../gui_root/root_manager", "../../../pi_sys/modules/util/event", "../../../pi_sys/feature/log", "../../../pi_sys/modules/util/util", "./painter", "../../../pi_sys/modules/util/frame_mgr", "../../../pi_sys/modules/util/task_mgr"], function (require, exports, animation_tools_1, root_manager_1, event_1, log_1, util_1, painter_1, frame_mgr_1, task_mgr_1) {
    "use strict";
    
    /**
     * 组件，包含样式和模板的js类,
     * 注意区分 widget实例和widget节点
     * widget节点的link属性指向了widget实例
     */
    class Widget extends event_1.HandlerTable {
        constructor() {
            super(...arguments);
            // 必须要赋初值，不然new出来的实例里面是没有这些属性的
            this.name = null; // 组件的名称
            this.tpl = null; // 组件的模板
            this.sheet = null; // 组件的样式
            this.config = null; // 所对应的配置
            this.forelet = null; // 所对应的forelet
            this.props = {}; // 由父组件设置的组件属性
            this.state = {}; // 由forelet设置的组件状态
            this.tree = null; // 组件所对应的节点树
            this.parentNode = null; // 父节点，parentNode.link的对象就是widget
            this.children = []; // 所有的子组件
            this.inDomTree = false; // 是否在dom树中
            this.resTab = null; // 资源表
            this.resTimeout = Widget.DefaultResTimeout; // 资源缓冲时间，默认3秒
            this.styleCache = new Map(); // 样式查询缓存
            this.r_styleCache = new Map(); // 样式查询缓存
            this.r_sheet = null; // 组件的样式
            this._enabled = true;
            this._enableListener = [];
            this._closed = false;
            /**
             * 界面执行打开动画时的通知
             * * 启动动画后调用
             */
            this.doOpenAnimHook = (aname) => {
                this.disenable();
                const rnode = this.tree.l;
                !rnode.isDestroy && (rnode.style.addAnimListenerHook(aname, 'end', this.enable));
            };
            /**
             * 界面执行关闭动画时的通知
             * * 启动动画后调用
             */
            this.doCloseAnimHook = (aname) => {
                this.disenable();
                // const rnode = (<RContainerElement>this.tree.l);
                // !rnode.isDestroy && (rnode.style.addAnimListenerHook(aname, 'end', this.enable));
            };
            /**
             * 具体widget中重载，不继承
             * * 若在实现中自己处理动画设置则返回 undefined
             * * 不做任何处理，仅返回 配置，将由底层自动设置
             */
            this.openAnim = () => {
                return undefined;
            };
            /**
             * 具体widget中重载，不继承
             * * 若在实现中自己处理动画设置则返回 undefined
             * * 不做任何处理，仅返回 配置，将由底层自动设置
             */
            this.closeAnim = () => {
                return undefined;
            };
            /**
             * 添加界面激活时的监听
             */
            this.addEnableListener = (f) => {
                this._enableListener.push(f);
            };
            /**
             * 移除界面激活时的监听
             */
            this.delEnableListener = (f) => {
                const index = this._enableListener.indexOf(f);
                if (index >= 0) {
                    this._enableListener.splice(index, 1);
                }
            };
            /**
             * 执行界面激活时的监听
             */
            this.enableListenActive = () => {
                this._enableListener.forEach((f) => {
                    f && f();
                });
            };
            this.enable = () => {
                const rnode = this.tree.l;
                if (!rnode.isDestroy) {
                    this._enabled = true;
                    root_manager_1.RootManager.updateGroupVisible();
                    this.enableListenActive();
                }
            };
            this.disenable = () => {
                const rnode = this.tree.l;
                if (!rnode.isDestroy) {
                    this._enabled = false;
                    root_manager_1.RootManager.updateGroupVisible();
                }
            };
        }
        /**
         * 创建后调用，一般在渲染循环外调用
         */
        create() {
            this.forelet && this.forelet.addWidget(this);
        }
        /**
         * 组件二次打开后的调用
         */
        openHook() {
            this._closed = false;
            const rnode = this.tree.l;
            if (!rnode.isDestroy) {
                // rnode.display   = true;
                rnode.parentNode.appendChild2(rnode);
                root_manager_1.RootManager.updateGroupVisible();
                this.firstPaint();
            }
        }
        /**
         * 组件(非销毁的关闭操作)后的调用
         */
        closeHook() {
            this._closed = true;
            const rnode = this.tree.l;
            if (!rnode.isDestroy) {
                // rnode.display   = false;
                rnode.parentNode.removeChild2(rnode);
                root_manager_1.RootManager.updateGroupVisible();
            }
        }
        /**
         * 组件打开/关闭状态
         */
        isClosed() {
            return this._closed;
        }
        /**
         * 第一次计算后调用，此时创建了真实的dom，但并没有加入到dom树上，一般在渲染循环外调用
         */
        firstPaint() {
            this.forelet && this.forelet.eventWidget(this, 'firstPaint');
            if (Widget.UseBackgroundList && Widget.UseBackgroundList.indexOf(this.name) >= 0) {
                frame_mgr_1.getGlobal().setAfter(() => {
                    task_mgr_1.set(() => {
                        const pre = Date.now();
                        this.updateProps({ UseBackgroundOK: true });
                        this.paint();
                        console.warn(`firstPaint ${this.name} - ${Date.now() - pre}`);
                    }, undefined, 99999999, 1);
                });
            }
            else {
                let cfg;
                if (this.openAnim) {
                    cfg = this.openAnim();
                    if (cfg && cfg.cmd && cfg.frames) {
                        const root = this.tree.l;
                        // 创建新 运行时动画
                        const runtimeAnimation = animation_tools_1.AnimeTools.initRuntimeAnimation(cfg.cmd, cfg.frames);
                        // 动画状态监听
                        cfg.startCall && root.style.addAnimListener(cfg.cmd.name, 'start', cfg.startCall);
                        cfg.iterCall && root.style.addAnimListener(cfg.cmd.name, 'loop', cfg.iterCall);
                        cfg.endCall && root.style.addAnimListener(cfg.cmd.name, 'end', cfg.endCall);
                        // 启动动画
                        root.style.addAnimation(runtimeAnimation);
                        this.doOpenAnimHook(cfg.cmd.name);
                    }
                }
            }
            if (this._enabled) {
                this.enableListenActive();
            }
        }
        /**
         * 销毁时调用，一般在渲染循环外调用
         */
        destroy() {
            if (!this.tpl) {
                return false;
            }
            this.tpl = undefined;
            if (this.resTab) {
                this.resTab.timeout = this.resTimeout;
                this.resTab.release();
            }
            this.forelet && this.forelet.removeWidget(this);
            this.parentNode = undefined;
            return true;
        }
        /**
         * 添加到dom树后调用，在渲染循环内调用
         */
        // tslint:disable:no-empty
        attach(notReal) {
        }
        /**
         * 更新到dom树前调用，一般在渲染循环外调用
         */
        beforeUpdate() {
            this.forelet && this.forelet.eventWidget(this, 'update');
        }
        /**
         * 更新到dom树后调用，在渲染循环内调用
         */
        afterUpdate() {
        }
        /**
         * 从dom树上移除前调用，一般在渲染循环内调用
         */
        detach(notReal) {
            if (!notReal) {
                this.children = undefined;
            }
        }
        /**
         * 获得样式数据
         */
        getSheet() {
            return this.sheet && this.sheet.value;
        }
        /**
         * 获得配置数据
         */
        getConfig() {
            return this.config && this.config.value;
        }
        /**
         * 获得渲染数据
         */
        getProps() {
            return this.props;
        }
        /**
         * 设置属性，默认外部传入的props是完整的props，重载可改变行为
         * @param props 新数据
         * @param oldProps 老数据
         */
        setProps(props, oldProps) {
            this.props = props;
        }
        /**
         * 更新属性，默认外部传入的props是更新命令，必须为Json对象，键的结构类似"a.b.c"，重载可改变行为
         */
        updateProps(props, oldProps) {
            if (!props) {
                return;
            }
            for (const k in props) {
                util_1.setValue(this.props, k, props[k]);
            }
        }
        /**
         * 获得渲染数据
         */
        getState() {
            return this.state;
        }
        /**
         * 设置状态
         */
        setState(state) {
            this.state = state;
        }
        /**
         * 绘制方法，
         * @param reset 表示新旧数据差异很大，不做差异计算，直接生成dom
         */
        paint(reset) {
            if (this._closed === true) {
                return;
            }
            painter_1.paintWidget(this, reset);
        }
        widgetEnabled() {
            return this._enabled;
        }
    }
    exports.Widget = Widget;
    Widget.DefaultResTimeout = 30000000000; // 资源缓冲时间，默认3秒
    /**
     * @description 注册组件
     * @example
     */
    exports.register = (name, widget, tpl, sheet, config, forelet, widcfg, wPath) => {
        const old = widgetMap.get(name);
        if (old) {
            log_1.cc.warn && log_1.log('widget already register, name:', name);
        }
        widget = widget || getWidget;
        widgetMap.set(name, { name, widget, tpl, sheet, config, forelet, widcfg, wPath });
        return old;
    };
    /**
     * @description 注册组件
     * @example
     */
    exports.or_register = (name) => {
        const old = widgetMap.get(name);
        if (old) {
            return old;
        }
        else {
            let meta = { name: name, widget: null, tpl: null };
            widgetMap.set(name, meta);
            return meta;
        }
    };
    /**
     * @description 查询是否存在目标 name 组件配置
     */
    exports.lookup = (name) => {
        return widgetMap.get(name);
    };
    /**
     * @description 列出所有的组件
     * @example
     */
    exports.list = () => {
        return [...widgetMap.values()];
    };
    /**
     * @description 取消注册组件
     * @example
     */
    exports.unregister = (name) => {
        return widgetMap.delete(name);
    };
    /**
     * @description 创建组件
     * @example
     */
    exports.factory = (name) => {
        const creator = widgetMap.get(name);
        if (!creator) {
            return;
        }
        const c = creator.widget();
        const w = c;
        w.name = name;
        if (creator.sheet) {
            w.r_sheet = creator.sheet;
        }
        if (creator.tpl) {
            w.tpl = creator.tpl;
        }
        if (creator.config) {
            w.config = creator.config;
        }
        if (creator.forelet) {
            w.forelet = creator.forelet();
        }
        w.create();
        return w;
    };
    /**
     * @description 计算相对组件路径
     * @example
     */
    exports.relative = (name, dir) => {
        let j;
        let i = name.length - 1;
        if (name.charCodeAt(i) !== 36) {
            return name;
        }
        j = dir.length - 1;
        if (dir.charCodeAt(j) !== 47) {
            j = dir.lastIndexOf('-');
        }
        while (i >= 0) {
            if (name.charCodeAt(i - 1) !== 36) {
                break;
            }
            i--;
            j = dir.lastIndexOf('-', j - 1);
        }
        if (i < 0) {
            return '';
        }
        name = name.slice(0, i);
        if (j < 0) {
            return name;
        }
        if (j < dir.length - 1) {
            dir = dir.slice(0, j + 1);
        }
        return dir + name;
    };
    /**
     * @description 获取tpl、css和cfg缓冲
     * @example
     */
    exports.getCache = (file) => {
        return cacheMap.get(file);
    };
    /**
     * @description 设置tpl、css和cfg缓冲
     * @example
     */
    exports.setCache = (file, data) => {
        cacheMap.set(file, data);
    };
    /**
     * @description 清除tpl、css和cfg缓冲
     * @example
     */
    exports.deleteCache = (file) => {
        cacheMap.delete(file);
    };
    // ============================== 本地
    // 组件模板表
    const widgetMap = new Map();
    // tpl、css和cfg缓冲
    const cacheMap = new Map();
    // 获得默认组件
    const getWidget = () => Widget;
    // ============================== 立即执行
    window.widgetMap = widgetMap;
    window.cacheMap = cacheMap;
});

_$pi.define("pi_gui/gui/gui_ui/combineImage/img", ["require", "exports", "../../gui_virtual/widget", "../../gui_virtual/forelet"], function (require, exports, widget_1, forelet_1) {
    "use strict";
    
    exports.forelet = new forelet_1.Forelet();
    class CombineImg extends widget_1.Widget {
        static registCombine(cname, cfg) {
            this.combineMap.set(cname, cfg);
        }
        setProps(prop) {
            const cfg = {};
            if (prop.src) {
            }
            else {
            }
            super.setProps(cfg);
        }
        updateProps(prop) {
            const cfg = {};
            super.updateProps(cfg);
        }
    }
    exports.CombineImg = CombineImg;
    CombineImg.combineMap = new Map();
    const readCombineCfg = (src) => {
    };
});

_$pi.define("pi_gui/gui/gui_ui/html.tpl", ["require", "exports", "../../../pi_sys/modules/util/hash", "../gui_compile/style", "../gui_virtual/tpl"], function (require, exports, _hash, style_1, tpl_1) {
    "use strict";
    
    const _path = 'pi_gui/gui/gui_ui/html.tpl';
    const _a = tpl_1.convertEntity;
    const _b = tpl_1.calAttrHash;
    const _c = tpl_1.calTextHash;
    const _e = tpl_1.addJson;
    const _f = tpl_1.installText;
    const _g = tpl_1.addText;
    const _h = tpl_1.chFunc;
    const _i = tpl_1.calNodeHash;
    const _d = tpl_1.calJsonHash;
    const _j = _hash.nextHash;
    const _s = style_1.styleStr2Json;
    exports.tpl = (function (_cfg, it, it1) {
        let $t, $n;
        it1 = it1 || {};
        it = it || {};
        $t = $n;
        {
            let $p = $t;
            let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 0, "cd": [] };
            $n["aH"] = 1996889236;
            {
                $n["s"] = { "n": 0 };
                $n["sH"] = 34336634;
                $n["sS"] = 1;
            }
            for (let i in it.innerhtml) {
                let v = it.innerhtml[i];
                if (v.dType === 'text') {
                    let divstyle = '';
                    for (let i1 in it1.divStyles) {
                        let v1 = it1.divStyles[i1];
                        if (v[v1]) {
                            divstyle = divstyle + v1 + ':' + v[v1] + ';';
                        }
                    }
                    let txtstyle = '';
                    for (let i2 in it1.textStyles) {
                        let v2 = it1.textStyles[i2];
                        if (v[v2]) {
                            txtstyle = txtstyle + v2 + ':' + v[v2] + ';';
                        }
                    }
                    if (v['on-tap']) {
                        $t = $n;
                        {
                            let $p = $t;
                            let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 1, "cd": [] };
                            $n["eS"] = 1;
                            $n["aH"] = 1737518437;
                            {
                                let attrvalue = "";
                                attrvalue += v['on-tap'];
                                attrvalue += "";
                                $n["e"]["pointerclick"] = attrvalue;
                                $n["eH"] = _j($n["eH"], _j(2533094024, tpl_1.calTextHash(attrvalue)));
                            }
                            {
                                let attrvalue = "";
                                attrvalue += "flex-direction: row;";
                                attrvalue += divstyle;
                                attrvalue += "width:auto;";
                                attrvalue = _s(attrvalue);
                                $n["s"] = attrvalue;
                                $n["sS"] = Object.keys(attrvalue).length;
                                $n["sH"] = _d(attrvalue);
                            }
                            $t = $n;
                            {
                                let $p = $t;
                                let $n = { "t": "", "a": {}, "e": {}, "eH": 0, "tg": "span", "si": 2, "cd": [] };
                                $n["aH"] = 1979317745;
                                {
                                    let attrvalue = "";
                                    attrvalue += txtstyle;
                                    attrvalue += "";
                                    attrvalue = _s(attrvalue);
                                    $n["s"] = attrvalue;
                                    $n["sS"] = Object.keys(attrvalue).length;
                                    $n["sH"] = _d(attrvalue);
                                }
                                $t = $n;
                                {
                                    let $p = $t;
                                    tpl_1.addText(v['text'], $p);
                                }
                                _i($n);
                                _h($n);
                                $p["cd"].push($n);
                            }
                            _i($n);
                            _h($n);
                            $p["cd"].push($n);
                        }
                    }
                    else {
                        $t = $n;
                        {
                            let $p = $t;
                            let $n = { "t": "", "a": {}, "e": {}, "eH": 0, "tg": "span", "si": 3, "cd": [] };
                            $n["aH"] = 1979317745;
                            {
                                let attrvalue = "";
                                attrvalue += txtstyle;
                                attrvalue += "";
                                attrvalue = _s(attrvalue);
                                $n["s"] = attrvalue;
                                $n["sS"] = Object.keys(attrvalue).length;
                                $n["sH"] = _d(attrvalue);
                            }
                            $t = $n;
                            {
                                let $p = $t;
                                tpl_1.addText(v['text'], $p);
                            }
                            _i($n);
                            _h($n);
                            $p["cd"].push($n);
                        }
                    }
                }
                else {
                    let imgstyle = '';
                    for (let i1 in it1.imgStyles) {
                        let v1 = it1.imgStyles[i1];
                        if (v[v1]) {
                            imgstyle = imgstyle + v1 + ':' + v[v1] + ';';
                        }
                    }
                    $t = $n;
                    {
                        let $p = $t;
                        let $n = { "a": {}, "e": {}, "eH": 0, "tg": "img", "si": 4, "cd": [] };
                        $n["aS"] = 1;
                        $n["aH"] = 1483984180;
                        {
                            let attrvalue = "";
                            attrvalue += v['src'];
                            attrvalue += "";
                            $n["a"]["src"] = attrvalue;
                        }
                        $n["aH"] = _j($n["aH"], _c($n["a"]["src"]));
                        {
                            let attrvalue = "";
                            attrvalue += imgstyle;
                            attrvalue += "";
                            attrvalue = _s(attrvalue);
                            $n["s"] = attrvalue;
                            $n["sS"] = Object.keys(attrvalue).length;
                            $n["sH"] = _d(attrvalue);
                        }
                        _i($n);
                        _h($n);
                        $p["cd"].push($n);
                    }
                }
            }
            _i($n);
            _h($n);
            return $n;
        }
    });
});

_$pi.define("pi_gui/gui/gui_ui/html", ["require", "exports", "../gui_virtual/forelet", "../gui_virtual/widget"], function (require, exports, forelet_1, widget_1) {
    "use strict";
    
    exports.forelet = new forelet_1.Forelet();
    /**
     * demo01
     * * 测试基本功能
     * * 样式解析
     * * 事件解析
     * * 组件匹配
     * * 简单数据使用
     */
    class GUIHtml extends widget_1.Widget {
        constructor() {
            super(...arguments);
            this.tapMap = new Map();
        }
        setProps(prop) {
            if (prop && prop.innerhtml) {
                for (let i = 0, len = prop.innerhtml.length; i < len; i++) {
                    const cfg = prop.innerhtml[i];
                    if (cfg['line-height']) {
                        cfg.height = cfg['line-height'];
                    }
                    else if (cfg['font-size']) {
                        cfg.height = cfg['font-size'];
                    }
                    if (cfg[TapStyles[0]]) {
                        this.tapMap.set(i, cfg[TapStyles[0]]);
                        cfg[TapStyles[0]] = `onTap(${i}, e)`;
                    }
                }
            }
            super.setProps(prop);
        }
        onTap(id, e) {
            const cmd = this.tapMap.get(id - 0);
            if (cmd !== undefined) {
                const cmdList = cmd.replace(')', '').split('(');
                const funcName = cmdList[0];
                if (cmdList[1]) {
                    const arg = cmdList[1].replace('(', '').replace(/^('|")/, '').replace(/('|")$/, '').trim();
                    const targetW = this.parentNode.w;
                    if (funcName && targetW && targetW[funcName]) {
                        targetW[funcName](arg, e);
                    }
                }
                else {
                    const targetW = this.parentNode.w;
                    if (funcName && targetW && targetW[funcName]) {
                        targetW[funcName](e);
                    }
                }
            }
        }
    }
    exports.GUIHtml = GUIHtml;
    const TextStyles = ['color', 'font-size', /* 'width' , 'height',*/ 'font-family', 'font-weight', 'line-height', 'text-indent'];
    const DivStyles = [/*'width',*/ 'height', 'background-color', 'opacity'];
    const ImgStyles = ['width', 'height'];
    const TapStyles = ['on-tap'];
    const URL = ['src'];
    const Text = ['text'];
    // const demoprop: Prop =  {
    //     innerhtml: [
    //         {
    //             dType: 'text',
    //             text: '逋',
    //             color: '#fff000',
    //             'font-size': '20px',
    //             'font-weight': '600'
    //         },
    //         {
    //             dType: 'text',
    //             text: '逋逋逋',
    //             color: '#0ff000',
    //             'font-size': '16px',
    //             'font-weight': '600',
    //             'background-color': '#0f0fa0',
    //             'on-tap': 'click("ssss")'
    //         },
    //         {
    //             dType: 'text',
    //             text: '逋逋逋逋逋逋',
    //             color: '#0ffff0',
    //             'font-size': '16px',
    //             'font-weight': '600',
    //             'background-color': '#0f0fa0'
    //         },
    //         {
    //             dType: 'img',
    //             src: '../images/01.png',
    //             color: '#0ff000',
    //             width: '40px',
    //             height: '40px'
    //         }
    //     ]
    // };
    /**
     * 切分 span,a,img,div
     * 封装: 用 div 封装
     * 样式处理:
     *      span
     *      img
     *      需移动到div
     * * 文本内关键字
     *      <, >, style, a, span, img, div
     *
     */
    const init = () => {
        exports.forelet.paint({
            textStyles: TextStyles,
            divStyles: DivStyles,
            imgStyles: ImgStyles
        });
    };
    // registerGUIInitHook(init)
    init();
});

_$pi.define("pi_gui/gui/gui_ui/progressive/progressive.tpl", ["require", "exports", "../../../../pi_sys/modules/util/hash", "../../gui_compile/style", "../../gui_virtual/tpl"], function (require, exports, _hash, style_1, tpl_1) {
    "use strict";
    
    const _path = 'pi_gui/gui/gui_ui/progressive/progressive.tpl';
    const _a = tpl_1.convertEntity;
    const _b = tpl_1.calAttrHash;
    const _c = tpl_1.calTextHash;
    const _e = tpl_1.addJson;
    const _f = tpl_1.installText;
    const _g = tpl_1.addText;
    const _h = tpl_1.chFunc;
    const _i = tpl_1.calNodeHash;
    const _d = tpl_1.calJsonHash;
    const _j = _hash.nextHash;
    const _s = style_1.styleStr2Json;
    exports.tpl = (function (_cfg, it, it1) {
        let $t, $n;
        it = it || { "orientation": 2, "arr": [], "min": 12, "addCount": 5, "checkPixel": 0.5, "scrollEnd": false };
        let _path = it.orientation === 2 ? 'y' : 'x';
        let _autoHeight = it.orientation === 2 ? 'auto' : '100%';
        let _autoWidth = it.orientation === 2 ? '100%' : 'auto';
        let _autoWrap = it.orientation === 2 ? 'wrap' : 'nowrap';
        $t = $n;
        {
            let $p = $t;
            let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 0, "cd": [] };
            $n["aS"] = 3;
            $n["eS"] = 1;
            $n["aH"] = 3578340050;
            {
                $n["s"] = { "c5": 1, "e8": [1, 100], "y": [1, 100], "b9": true };
                $n["sH"] = 3337196601;
                $n["sS"] = 4;
            }
            {
                let attrvalue = "";
                attrvalue += _path;
                attrvalue += "";
                $n["a"]["scroll_path"] = attrvalue;
            }
            $n["aH"] = _j($n["aH"], _c($n["a"]["scroll_path"]));
            $n["a"]["scroll_type"] = "none";
            $n["e"]["pointermove"] = "scroll(e)";
            $n["eH"] = _j($n["eH"], 877993680);
            $n["a"]["layout"] = "scroll";
            $t = $n;
            {
                let $p = $t;
                let $n = { "a": {}, "e": {}, "eH": 0, "tg": "div", "si": 1, "cd": [] };
                $n["aH"] = 516944947;
                {
                    let attrvalue = "";
                    attrvalue += "position: absolute; width:";
                    attrvalue += _autoWidth;
                    attrvalue += ";height:";
                    attrvalue += _autoHeight;
                    attrvalue += ";flex-wrap:";
                    attrvalue += _autoWrap;
                    attrvalue += ";";
                    attrvalue = _s(attrvalue);
                    $n["s"] = attrvalue;
                    $n["sS"] = Object.keys(attrvalue).length;
                    $n["sH"] = _d(attrvalue);
                }
                let arr = it.arr.slice(it.showStart, it.showEnd);
                {
                    let _$i = 0;
                    for (let v of arr) {
                        let i = _$i++;
                        $t = $n;
                        {
                            let $p = $t;
                            let $n = { "a": {}, "e": {}, "eH": 0, "tg": "widget", "si": 2, "cs": false, "ch": null };
                            $n["aH"] = 782767477;
                            {
                                let attrvalue = "";
                                attrvalue = v && v.widget ? v.widget : it.widget;
                                $n["a"]["w-tag"] = attrvalue;
                            }
                            $n["aH"] = _j($n["aH"], _c($n["a"]["w-tag"]));
                            $n["tg"] = $n["a"]["w-tag"];
                            $t = $n;
                            {
                                let $p = $t;
                                let $n = {}; //jpair pre
                                $n["i"] = i;
                                //jpair suf
                                //jpair pre
                                $n["v"] = v;
                                //jpair suf
                                _e($n, $p);
                            }
                            _i($n);
                            _h($n);
                            $p["cd"].push($n);
                        }
                    }
                }
                _i($n);
                _h($n);
                $p["cd"].push($n);
            }
            _i($n);
            _h($n);
            return $n;
        }
    });
});

/*
 * 渐进显示数组
 * props={direction:2, arr:[], showStart:0, showEnd:0, initCount:10, addCount:5, checkPixel:100,scrollEnd:false }
 */
_$pi.define("pi_gui/gui/gui_ui/progressive/progressive", ["require", "exports", "../../gui_virtual/widget"], function (require, exports, widget_1) {
    "use strict";
    
    // ============================== 导出
    /**
     * @description 导出组件Widget类
     * @example
     */
    class Progressive extends widget_1.Widget {
        constructor() {
            super(...arguments);
            // 滚动位置的状态，0表示滚动位置为开头，1表示为中间，2表示为底部
            this.state = 0;
            /**
             * @description 滚动监听
             * @example
             */
            this.scroll = (e) => {
                const el = this.tree.l;
                const props = this.props;
                let start, clientSize, scrollSize, check;
                if (props.orientation === 2) {
                    start = el.scrollY;
                    clientSize = el.height;
                    scrollSize = el.scrollHeight;
                }
                else {
                    start = el.scrollX;
                    clientSize = el.width;
                    scrollSize = el.scrollWidth;
                }
                if (start === 0) {
                    this.state = 0;
                }
                else if (start + clientSize >= scrollSize) {
                    this.state = 2;
                }
                else {
                    this.state = 1;
                }
                check = Number.isInteger(props.checkPixel) ? props.checkPixel : ((props.checkPixel * clientSize) | 0);
                if (start + clientSize + check >= scrollSize && props.showEnd < props.arr.length) {
                    // 向尾部添加数据
                    props.showEnd = Math.min(props.showEnd + props.addCount, props.arr.length);
                    return this.paint();
                }
            };
        }
        /**
         * @description 设置属性，默认外部传入的props是完整的props，重载可改变行为
         * @example
         */
        setProps(props, oldProps) {
            props.arr = props.arr || [];
            props.orientation = props.orientation || 2;
            props.initCount = props.initCount || 10;
            props.addCount = props.addCount || 5;
            props.checkPixel = props.checkPixel || 0.5;
            props.showStart = props.showStart || 0;
            props.showEnd = props.showEnd || Math.min(props.showStart + props.initCount, props.arr.length);
            super.setProps(props);
        }
    }
    exports.Progressive = Progressive;
});
// ============================== 本地
// ============================== 立即执行

_$pi.define("pi_gui/gui/gui_virtual/resize/resize", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     *
     * @param option :
     * @param cb :
     */
    exports.resize = (option, cb) => {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const img = new Image();
        img.crossOrigin = '';
        img.onload = () => {
            let scale = (img.width < img.height) ? (option.width / img.width) : (option.width / img.height);
            scale = (scale < 1) ? scale : 1;
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            context.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
            let base64 = null;
            if (option.type === 'jpeg') {
                base64 = canvas.toDataURL(`image/${option.type}`, option.ratio || 0.92);
            }
            else {
                base64 = canvas.toDataURL(`image/${option.type}`);
            }
            const mimeString = base64.split(',')[0].split(':')[1].split(';')[0]; // mime类型
            const byteString = atob(base64.split(',')[1]); // base64 解码
            const arrayBuffer = new ArrayBuffer(byteString.length); // 创建缓冲数组
            const intArray = new Uint8Array(arrayBuffer); // 创建视图
            for (let i = 0; i < byteString.length; i += 1) {
                intArray[i] = byteString.charCodeAt(i);
            }
            if (cb)
                cb({ base64, ab: arrayBuffer });
        };
        img.src = option.url;
    };
});

// /**
//  * 一般项目的目录结构：
//  *     boot/ 启动页面
//  *     app/a 选服界面或登录注册界面
//  *     app/b 主界面，新手引导前3分钟用到的功能和3d显示配置（主城和开始的几个副本场景，以及马上要用到的模型、特效）
//  *     app/b/ui
//  *     app/c 剩余的全部的功能和3d显示配置
//  *     app/c/ui
//  *     app/init 选择角色 （可能的一场战斗）
//  *     app/mod 最基础的模块
//  *     app/ui 最基础的组件
//  *     app/res 全部的场景资源， 进入场景前单独请求
//  *     pi/ 底层模块
//  * 图标采用类似资源的做法，大部分放在c部分，如果需要完整显示（比如a部分），应用应该提前载入或放到app/a/中。否则需要的时候，直接实时载入。
//  * 流程：
//  *     1、 显示封面。载入 100k 1-2秒。中间有loading显示，无进度显示。 
//  *         index.html + index.js + init.js + .depends + next.js
//  *         同步建立通讯
//  *     2、 显示进度条1 载入 500k 1-3秒。进度完毕后显示选服界面或登录注册界面
//  *         加载 pi/ app/mod app/ui app/a/
//  *         根据本地标志和服务器角色获取，判断是否第一次进入，启动slowdown选择不同流程载入。
//  *             无角色进入是init b c的代码配置的慢加载和可选的c资源的慢下载。
//  *             有角色进入是b c的代码配置的慢加载。
//  *         根据首次进入或玩家进新服，进入3或4的流程
//  *     3、选择角色
//  *         3.1、 显示进度条2。载入 500k-1M 2-4秒。进度完毕后显示选择角色 （可能的一场战斗）
//  *             app/init/
//  *             渐进加载场景资源 3-5秒
//  *             预计大概 操作3-5秒
//  *         3.2、 显示进度条3。载入 4M 4-10秒。进度完毕后显示主界面
//  *             app/b/
//  *             渐进加载主城场景资源 3-5秒
//  *             预计操作3-5分钟
//  *         3.3、 后台载入无进度显示
//  *             app/c/的代码配置 8M 慢加载20秒
//  *             app/c/的资源 20M 可选的慢下载200秒
//  *     4、 显示进度条2。加载 12M 4-10秒。 进度完毕后显示主界面
//  *         加载 app/b/的全部 app/c/的代码配置
//  * 注意：术语加载和下载是不同的。加载包括下载，数据包括代码、组件、资源都要进内存，主要为了减少下载后写入硬盘后，然后又较短时间内被读取的损耗。 下载则仅下载，数据从内存中丢弃。
//  * 如果是微信小游戏，则代码都已经全部加载。应用也无需改变流程。
//  */
_$pi.define("pi_gui/gui/gui_virtual/slowdown", ["require", "exports"], function (require, exports) {
    "use strict";
});
// // ============================== 导入
// import { depend, load } from '../../../pi_sys/modules/lang/mod';
// import { Json } from '../../../pi_sys/modules/lang/type';
// import { fileDepends, listDirFile, loadDir } from '../../../pi_sys/modules/widget/util';
// // ============================== 导出
// // 默认检查时间
// export let checkTime = 100;
// // 默认休眠时间
// export let sleepTime = 1000;
// // 网络请求的同时下载的数量
// export let limitCount = 3;
// /**
//  * @description 用util.loadDir来加载文件列表，保证模块和组件会自动加载。下载顺序依赖数组的倒序。
//  * @example
//  */
// export const start = (filesArr: string[][], flags: Json, resultMap: Json, callback: Function, ruleOut: Function) => {
//     const cb = (time: number) => {
//         setTimeout(() => {
//             start(filesArr, flags, resultMap, callback, ruleOut);
//         }, time || sleepTime);
//     };
//     if (load.loadingCount() >= limitCount) {
//         return cb(checkTime);
//     }
//     const files = filesArr.pop();
//     if (!files) {
//         return callback();
//     }
//     loadDir(files, flags, resultMap, null, cb, cb, null, ruleOut);
// };
// /**
//  * @description 将目录中需要下载的文件（本地没有或不是最新的），按限制的大小（默认256k~1兆），按后缀的优先级拆成多后缀多文件列表。
//  * @example
//  */
// // tslint:disable-next-line:max-line-length
// export const split = (dirs: string[], flags: Json, suffixSort: string[], limitMinSize: number = 256 * 1024, limitMaxSize: number = 1024 * 1024, ruleOut: Function): string[][] => {
//     const fileList = [];
//     const suffixMap = new Map();
//     listDirFile(dirs, flags, fileList, suffixMap, null, null, ruleOut);
//     const result = [];
//     let last = 0;
//     for (const suffix of suffixSort) {
//         const files = suffixMap.get(suffix);
//         if (!files) {
//             continue;
//         }
//         suffixMap.delete(suffix);
//         last = merge(result, last, files, limitMinSize, limitMaxSize);
//     }
//     // 处理剩余的后缀
//     for (const files of suffixMap.values()) {
//         last = merge(result, last, files, limitMinSize, limitMaxSize);
//     }
//     return result.reverse();
// };
// // ============================== 本地
// const merge = (result: string[][], last: number, files: any[], limitMinSize: number, limitMaxSize: number): number => {
//     let arr: string[];
//     if (last) {
//         arr = result[result.length - 1];
//     } else {
//         arr = [];
//         result.push(arr);
//     }
//     for (const f of files) {
//         if (last + f.size > limitMaxSize) {
//             arr = [];
//             result.push(arr);
//             last = 0;
//         }
//         last += f.size;
//         arr.push(f.path);
//     }
//     return last >= limitMinSize ? 0 : last;
// };
// // ============================== 立即执行

_$pi.define("pi_gui/gui/gui_virtual/virtual_propertys", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 虚拟节点属性表
     * * 所有类型虚拟节点属性并集
     */
    exports.VirtualPropertyList = [
        'tagName',
        'sid',
        'did',
        'offset',
        'offsetOld',
        'widget',
        'parent',
        'link',
        'ext',
        'attr',
        'attrHash',
        'attrSize',
        'event',
        'eventHash',
        'eventSize',
        'style',
        'styleHash',
        'styleSize',
        'didMap',
        'childHash',
        'childHashMap',
        'textHashMap',
        'children',
        // 内容
        'child',
        'childHas',
        'text',
        'str',
        'src'
    ];
});
// export const VirtualPropertyMap = {
//     sid: 
// };

/**
 * 事件处理模块
 * 提供在节点的事件上直接声明简单函数调用，简单函数还可以是抛出自定义事件的$notify函数
 * 将5种手势事件（单击tap、双击dbltap、长按longtap、移动move(挥swipe)、旋转缩放rotsal(rotote scale)）代码集成进来，作为引擎提供的本地事件，检测平台，模拟缺失平台的事件
 * 挥的判断是：touchend离开时间减去最后一次touchmove移动时间小于规定的值，并且最后一次移动的速度超过规定的速度
 *
 * 事件支持直接调用widget组件上的方法，和notify方法。
 * 如果是简单字符串就认为是无参数方法。
 * @example <app-ui-btn on-tap=select>"g2"</app-ui-btn>
 * 如果是方法调用，支持参数中使用事件e, 及e的域。
 * @example <app-ui-btn on-tap="select({{v.id}}, 1, e.x, e.y)">"g2"</app-ui-btn>
 * 如果是$notify，支持直接抛出自定义的事件。
 * @example <app-ui-btn on-tap='$notify("ev-brand-btn-select", { "id":{{v.id}}, "x":e.x, "y":e.y})'>"g2"</app-ui-btn>
 */
_$pi.define("pi_gui/widget/event", ["require", "exports", "../util/event", "../../pi_sys/modules/math/math", "../../pi_sys/setup/env", "../../pi_sys/modules/util/util"], function (require, exports, event_1, math_1, env, util_1) {
    "use strict";
    
    // ============================== 导出
    exports.USER_EVENT_PRE = 'ev-';
    exports.BUBBLE_EVENT_PRE = 'on-';
    exports.CAPTURE_EVENT_PRE = 'cap-';
    /**
     * @description tap事件默认的间隔时间
     */
    exports.TapInterval = 300;
    /**
     * @description tap事件默认是否停止广播
     */
    exports.TapStopPropagation = true;
    /**
     * @description 5种手势事件的移动距离限制
     */
    exports.MoveLimit = 15;
    /**
     * @description 单击的时间值，毫秒
     */
    exports.TapTime = 600;
    /**
     * @description 双击的时间值，毫秒
     */
    exports.DblTapTime = 600;
    /**
     * @description 长按的时间值，毫秒
     */
    exports.LongTapTime = 800;
    /**
     * @description 挥的速度的平方，px/秒
     */
    exports.SwipeSpeed = 300 * 300;
    /**
     * @description 挥的最后停顿时间（touchend离开时间减去最后一次touchmove移动时间），必须小于该时间才认为是挥动
     */
    exports.SwipeTime = 100;
    /**
     * @description 获得事件类型， 只能是ev- on- cap-
     * @example
     */
    exports.getEventType = (key) => {
        const c = key.charCodeAt(0);
        if (c === 101 && key.startsWith(exports.USER_EVENT_PRE)) {
            return exports.USER_EVENT_PRE;
        }
        else if (c === 111 && key.startsWith(exports.BUBBLE_EVENT_PRE)) {
            return exports.BUBBLE_EVENT_PRE;
        }
        else if (c === 99 && key.startsWith(exports.CAPTURE_EVENT_PRE)) {
            return exports.CAPTURE_EVENT_PRE;
        }
    };
    /**
     * @description 获得用户事件监听器
     * @example
     */
    // tslint:disable:no-reserved-keywords
    exports.getUserEventListener = (key, value) => {
        return getFunction(value);
    };
    /**
     * @description 获得本地事件监听器
     * @example
     */
    exports.getNativeEventListener = (key, value) => {
        return getNativeFunction(getFunction(value));
    };
    /**
     * @description 重绑定节点事件表
     * @example
     */
    exports.rebindEventMap = (oldNode, newNode) => {
        if (!oldNode.ext) {
            return;
        }
        const map = oldNode.ext.nativeEventMap;
        if (map) {
            for (const v of map.values()) {
                v.handler.vnode = newNode;
            }
        }
    };
    /**
     * @description 添加用户事件监听器，没有Handler表示删除用户事件监听器
     * @example
     */
    exports.addUserEventListener = (node, key, type, value) => {
        let map = node.ext.eventMap;
        if (!map) {
            node.ext.eventMap = map = new Map();
        }
        if (value) {
            map.set(key, exports.getUserEventListener(key, value));
        }
        else {
            map.delete(key);
        }
    };
    /**
     * @description 添加本地事件监听器，没有Handler表示删除本地事件监听器
     * @example
     */
    exports.addNativeEventListener = (node, realNode, key, type, value) => {
        const isCap = type === exports.CAPTURE_EVENT_PRE;
        let map = node.ext.nativeEventMap;
        if (!map) {
            node.ext.nativeEventMap = map = new Map();
        }
        else {
            const old = map.get(key);
            if (old) {
                if (key === 'cap-hashchange') {
                    window.removeEventListener('hashchange', old.listener, false);
                }
                else {
                    realNode.removeEventListener(old.type, old.listener, isCap);
                    const arr = old.types;
                    if (arr) {
                        for (const t of arr) {
                            realNode.removeEventListener(t.type, t.listener, isCap);
                        }
                    }
                }
            }
        }
        if (!value) {
            return;
        }
        const h = exports.getNativeEventListener(key, value);
        // 在监听器上绑定虚拟节点，这样不使用闭包来获得虚拟节点
        h.vnode = node;
        const bind = eventBind(realNode, h, getEventName(key, type));
        map.set(key, bind);
        // hashchange事件是一个只能绑定在body上的事件，要特殊处理,使得他能向下传递，其他事件都是可以向上传递的
        if (key === 'cap-hashchange') {
            window.addEventListener('hashchange', h, false);
        }
        else {
            realNode.addEventListener(bind.type, bind.listener, isCap); //{ passive: true, capture: isCap } TODO
            const arr = bind.listeners;
            if (arr) {
                for (const t of arr) {
                    realNode.addEventListener(t.type, t.listener, isCap); //{ passive: true, capture: isCap }
                }
            }
        }
    };
    /**
     * @description 沿节点树，通知节点上的事件监听器
     * @example
     */
    exports.notify = (node, eventType, e) => {
        // tslint:disable-next-line:prefer-const
        let listener;
        // tslint:disable-next-line:prefer-const
        let r;
        let set = false;
        if (e) {
            if (typeof e === 'object' || typeof e === 'function') {
                e.type = eventType;
                // e.srcNode为初始事件源，e.native为原生事件
                e.srcNode = node;
                // e.srcWidget为初始组件源
                e.srcWidget = node.widget;
                set = true;
            }
        }
        else {
            e = { type: eventType, srcNode: node, srcWidget: node.widget, node: null, widget: null };
        }
        while (node) {
            if (set) {
                // e.node为当前节点源
                e.node = node;
                e.widget = node.widget;
            }
            const listener = node.ext ? (node.ext.eventMap ? node.ext.eventMap.get(eventType) : null) : null;
            if (listener) {
                const r = listener(e, node.widget);
                // tslint:disable-next-line:no-empty
                if (!r) {
                }
                else if (r === event_1.HandlerResult.BREAK_OK) {
                    return;
                }
            }
            node = (node.parent) ? node.parent : node.widget.parentNode;
        }
    };
    // 全局事件函数的缓存
    const cacheMap = new Map();
    /**
     * @description 获得简单事件函数
     * @example
     */
    const getSampleFunction = (funName, args) => {
        return (e, w) => {
            let arr;
            if (args) {
                arr = args.arr;
                if (args.index >= 0) {
                    arr[args.index] = args.fields ? util_1.getValue(e, args.fields) : e;
                }
            }
            else {
                arr = [e];
            }
            if (funName === '$notify') {
                exports.notify(w.parentNode, arr[0], arr[1]);
                return event_1.HandlerResult.BREAK_OK;
            }
            const r = w.notify(funName, arr);
            if (r) {
                return r;
            }
            const f = w.forelet;
            if (!f) {
                return;
            }
            return f.notify(funName, arr);
        };
    };
    /**
     * @description 解析参数
     * @example
     */
    const parseArgs = (arg) => {
        arg = arg.replace(/'/g, '"');
        const len = arg.length;
        let attr;
        const findElemE = (arg, start) => {
            for (let i = start; i < len; i++) {
                if (arg[i] !== ' ') {
                    return (arg[i] === 'e') ? i : -1;
                }
            }
        };
        const findAttrOfE = (arg, start) => {
            if (arg[start] !== '.') {
                return;
            }
            let i = start + 1;
            for (; i < len; i++) {
                if (arg[i] === ' ' || arg[i] === ',') {
                    break;
                }
            }
            attr = arg.slice(start + 1, i);
        };
        const findStrEnd = (arg, start, closedChar) => {
            for (let i = start; i < len; i++) {
                if (arg[i] === closedChar) {
                    return i;
                }
            }
        };
        let j = findElemE(arg, 0);
        if (j < 0) {
            for (let c, i = 0; i < len; i++) {
                c = arg[i];
                if (c === '\'') {
                    i = findStrEnd(arg, i + 1, '\'');
                }
                else if (c === '"') {
                    i = findStrEnd(arg, i + 1, '"');
                }
                else if (c === ',') {
                    j = findElemE(arg, i + 1);
                    if (j !== -1) {
                        findAttrOfE(arg, j + 1);
                        break;
                    }
                }
            }
        }
        else {
            findAttrOfE(arg, j + 1);
        }
        if (j >= 0) {
            // tslint:disable:prefer-template
            arg = arg.substring(0, j) + '"$_"' + arg.substring(attr ? j + attr.length + 2 : j + 1, arg.length);
        }
        try {
            const r = JSON.parse('[' + arg + ']'); // 匹配字符串中的",e",将其替换成",'$_'"
            return { arr: r, index: r.indexOf('$_'), fields: attr };
        }
        catch (error) {
            throw new Error('parseArgs fail, args: ' + arg);
        }
    };
    /**
     * @description 获得事件函数
     * @example
     */
    const getFunction = (str) => {
        str = str.trim();
        // 字符串中存在(,解析字符串中的方法名和参数
        const index = str.indexOf('(');
        if (index > 0) {
            const funName = str.slice(0, index);
            return getSampleFunction(funName, parseArgs(str.slice(index + 1, str.length - 1)));
        }
        return getSampleFunction(str);
    };
    /**
     * @description 获得本地事件函数，从函数身上取到绑定的虚拟节点，添加到事件上
     * @example
     */
    const getNativeFunction = (h) => {
        // tslint:disable-next-line:no-unnecessary-local-variable
        const func = (e) => {
            const node = func.vnode;
            if (!node) {
                return;
            }
            let ext = node.ext;
            if (!ext) {
                ext = node.ext = {};
            }
            if ((!ext.eventAttr) && e.type === 'tap') {
                ext.eventAttr = { tap: { interval: exports.TapInterval, stop: exports.TapStopPropagation, nextTime: 0 } };
            }
            if (ext.eventAttr) {
                let cfg = ext.eventAttr[e.type];
                if ((!cfg) && e.type === 'tap') {
                    ext.eventAttr[e.type] = cfg = { interval: exports.TapInterval, stop: exports.TapStopPropagation, nextTime: 0 };
                }
                if (cfg) {
                    if (cfg.stop) {
                        e.native ? e.native.stopPropagation() : e.stopPropagation();
                    }
                    if (cfg.prevent) {
                        e.native ? e.native.preventDefault() : e.preventDefault();
                    }
                    if (cfg.interval) {
                        if (cfg.nextTime && cfg.nextTime > e.timeStamp) {
                            return;
                        }
                        cfg.nextTime = e.timeStamp + cfg.interval;
                    }
                }
            }
            e.node = node;
            e.srcNode = node;
            e.widget = node.widget;
            e.srcWidget = node.widget;
            return h(e, node.widget);
        };
        return func;
    };
    /**
     * @description 获得原始的事件类型名
     * @example
     */
    const getEventName = (str, type) => {
        return str.slice(type.length);
    };
    /**
     * @description 事件绑定
     * @example
     */
    const eventBind = (el, h, name) => {
        const func = gesture[env.get("device") ? 0 : 1][name];
        return func ? func(el, h) : { type: name, name2: null, handler: h, listener: h };
    };
    // 触控手势
    // 移动
    const touchMove = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let xx = 0;
        let yy = 0;
        let lasttime = 0;
        let lastx = 0;
        let lasty = 0;
        let state = -1;
        const fire = (e, type) => {
            h({
                type: 'move', subType: type, native: e, x: xx, y: yy,
                timeStamp: e.timeStamp, startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty
            });
        };
        const down = (e) => {
            if (e.touches.length > 1) {
                if (state > 0) {
                    cancel(e);
                }
                else if (state === 0) {
                    state = -1;
                }
                return;
            }
            state = 0;
            time = e.timeStamp;
            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
            lasttime = time;
            lastx = x;
            lasty = y;
            xx = x;
            yy = y;
        };
        const move = (e) => {
            if (state < 0) {
                return;
            }
            if (e.touches.length > 1) {
                return cancel(e);
            }
            lasttime = e.timeStamp;
            lastx = xx;
            lasty = yy;
            xx = e.touches[0].pageX;
            yy = e.touches[0].pageY;
            if (state > 0) {
                fire(e, 'keep');
            }
            else if (Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit) {
                state = 1;
                // 修正起始位置，去除移动开始时的跳动
                x = xx;
                y = yy;
                fire(e, 'start');
            }
        };
        const up = (e) => {
            if (state > 0) {
                const t = e.timeStamp - lasttime;
                h({
                    type: 'move', subType: 'over', native: e, x: xx, y: yy, timeStamp: e.timeStamp,
                    startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty,
                    swipe: (t < exports.SwipeTime) && ((lasty - xx) * (lasty - xx) + (lasty - yy) * (lasty - yy)) > exports.SwipeSpeed * t / 1000
                });
            }
            state = -1;
        };
        const cancel = (e) => {
            if (state > 0) {
                fire(e, 'cancel');
            }
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 单击
    const touchTap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let state = -1;
        const down = (e) => {
            if (e.touches.length > 1) {
                state = -1;
                return;
            }
            state = 1;
            time = e.timeStamp;
            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
        };
        const move = (e) => {
            const xx = e.touches[0].pageX;
            const yy = e.touches[0].pageY;
            if (state > 0 && (e.touches.length > 1 || Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit)) {
                state = -1;
            }
        };
        const up = (e) => {
            if (state > 0 && e.timeStamp < time + exports.TapTime) {
                h({ type: 'tap', native: e, x: x, y: y, timeStamp: e.timeStamp });
            }
            state = -1;
        };
        const cancel = (e) => {
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 双击
    const touchDbltap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let state = -1;
        const down = (e) => {
            if (e.touches.length > 1 || state === 0 || state > 1) {
                state = -1;
                return;
            }
            const t = e.timeStamp;
            const xx = e.touches[0].pageX;
            const yy = e.touches[0].pageY;
            if (state === 1 && (t > time + exports.DblTapTime || Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit)) {
                state = -1;
                return;
            }
            state++;
            time = t;
            x = xx;
            y = yy;
        };
        const move = (e) => {
            const xx = e.touches[0].pageX;
            const yy = e.touches[0].pageY;
            if (state > 0 && (e.touches.length > 1 || Math.abs(x - xx) > exports.MoveLimit || Math.abs(y - yy) > exports.MoveLimit)) {
                state = -1;
            }
        };
        const up = (e) => {
            if (state === 0 && e.timeStamp < time + exports.TapTime) {
                state = 1;
                time = e.timeStamp;
                return;
            }
            if (state === 2 && e.timeStamp < time + exports.TapTime) {
                h({ type: 'dbltap', native: e, x: x, y: y, timeStamp: e.timeStamp });
            }
            state = -1;
        };
        const cancel = (e) => {
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 抬起
    const touchUp = (el, h) => {
        const up = (e) => {
            h({ type: 'up', native: e, timeStamp: e.timeStamp });
        };
        return { type: 'touchend', listener: up, listeners: null, handler: h };
    };
    // 按下
    const touchDown = (el, h) => {
        const down = (e) => {
            h({ type: 'down', native: e, x: e.touches[0].pageX, y: e.touches[0].pageY, timeStamp: e.timeStamp });
        };
        return { type: 'touchstart', listener: down, listeners: null, handler: h };
    };
    // 长按
    const touchLongtap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let ref = 0;
        const down = (e) => {
            if (e.touches.length > 1) {
                return up(e);
            }
            ref && clearTimeout(ref);
            time = e.timeStamp;
            x = e.touches[0].pageX;
            y = e.touches[0].pageY;
            ref = setTimeout(() => {
                ref = 0;
                h({ type: 'longtap', native: e, x: x, y: y, timeStamp: time + exports.LongTapTime, startTime: time });
            }, exports.LongTapTime);
        };
        const move = (e) => {
            if (ref && (e.touches.length > 1 || Math.abs(x - e.touches[0].pageX) > exports.MoveLimit || Math.abs(y - e.touches[0].pageY) > exports.MoveLimit)) {
                clearTimeout(ref);
                ref = 0;
            }
        };
        const up = (e) => {
            ref && clearTimeout(ref);
            ref = 0;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: up }], handler: h
        };
    };
    // 旋转 缩放
    // tslint:disable-next-line:max-func-body-length
    const touchRotsal = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let x1 = 0;
        let y1 = 0;
        let x2 = 0;
        let y2 = 0;
        let xx = 0;
        let yy = 0;
        let xx1 = 0;
        let yy1 = 0;
        let xx2 = 0;
        let yy2 = 0;
        let dist1 = 0;
        let dist2 = 0;
        let vx1 = 0;
        let vy1 = 0;
        let vx2 = 0;
        let vy2 = 0;
        let direction = 0;
        let angle = 0;
        let state = -1;
        const fire = (e, type) => {
            h({
                type: 'rotsal', subType: type, native: e, dist: dist2, scale: dist2 / dist1,
                direction: direction, angle: angle, timeStamp: e.timeStamp, startTime: time,
                x: xx, y: yy, x1: x1, y1: y2, x2: x2, y2: y2, xx1: xx1, yy1: yy1, xx2: xx2, yy2: yy2, startDist: dist1
            });
        };
        const down = (e) => {
            if (e.touches.length === 1) {
                if (state > 0) {
                    cancel(e);
                }
                else if (state === 0) {
                    state = -1;
                }
                return;
            }
            state = 0;
            time = e.timeStamp;
            x1 = e.touches[0].pageX;
            y1 = e.touches[0].pageY;
            x2 = e.touches[1].pageX;
            y2 = e.touches[1].pageY;
            x = (x1 + x2) / 2;
            y = (y1 + y2) / 2;
            vx1 = x1 - x2;
            vy1 = y1 - y2;
            dist1 = Math.sqrt(vx1 * vx1 + vy1 * vy1);
        };
        const move = (e) => {
            if (state < 0) {
                return;
            }
            if (e.touches.length === 1) {
                return cancel(e);
            }
            xx1 = e.touches[0].pageX;
            yy1 = e.touches[0].pageY;
            xx2 = e.touches[1].pageX;
            yy2 = e.touches[1].pageY;
            xx = (xx1 + xx2) / 2;
            yy = (yy1 + yy2) / 2;
            vx2 = xx1 - xx2;
            vy2 = yy1 - yy2;
            if (state > 0) {
                dist2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);
                direction = math_1.getDirection(vx1, vy1, vx2, vy2);
                angle = math_1.getAngle(vx1, vy1, vx2, vy2);
                fire(e, 'keep');
            }
            else {
                const dx1 = Math.abs(x1 - xx1);
                const dy1 = Math.abs(y1 - yy1);
                const dx2 = Math.abs(x2 - xx2);
                const dy2 = Math.abs(y2 - yy2);
                if (dx1 + dy1 + dx2 + dy2 > exports.MoveLimit) {
                    state = 1;
                    dist2 = Math.sqrt(vx2 * vx2 + vy2 * vy2);
                    direction = math_1.getDirection(vx1, vy1, vx2, vy2);
                    angle = math_1.getAngle(vx1, vy1, vx2, vy2);
                    fire(e, 'start');
                }
            }
        };
        const up = (e) => {
            if (state > 0) {
                fire(e, 'over');
            }
            state = -1;
        };
        const cancel = (e) => {
            if (state > 0) {
                fire(e, 'cancel');
            }
            state = -1;
        };
        return {
            type: 'touchstart', listener: down, listeners: [{ type: 'touchmove', listener: move },
                { type: 'touchend', listener: up }, { type: 'touchcancel', listener: cancel }], handler: h
        };
    };
    // 鼠标手势
    // 移动
    const mouseMove = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let lasttime = 0;
        let lastx = 0;
        let lasty = 0;
        let state = -1;
        const fire = (e, type) => {
            h({
                type: 'move', subType: type, native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp,
                startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty
            });
        };
        const down = (e) => {
            state = 0;
            time = e.timeStamp;
            x = e.pageX;
            y = e.pageY;
            lasttime = time;
            lastx = x;
            lasty = y;
        };
        const move = (e) => {
            if (state > 0) {
                fire(e, 'keep');
                // tslint:disable-next-line:no-empty
            }
            else if (state < 0) {
            }
            else if (Math.abs(x - e.pageX) > exports.MoveLimit || Math.abs(y - e.pageY) > exports.MoveLimit) {
                state = 1;
                lasttime = e.timeStamp;
                lastx = e.pageX;
                lasty = e.pageY;
                // 修正起始位置，去除移动开始时的跳动
                x = lastx;
                y = lasty;
                fire(e, 'start');
            }
        };
        const up = (e) => {
            if (state > 0) {
                const t = e.timeStamp - lasttime;
                h({
                    type: 'move', subType: 'over', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp,
                    startTime: time, startX: x, startY: y, lastTime: lasttime, lastX: lastx, lastY: lasty,
                    swipe: (t < exports.SwipeTime) && ((lasty - e.pageX) * (lasty - e.pageX) + (lasty - e.pageY) * (lasty - e.pageY)) > exports.SwipeSpeed * t / 1000
                });
            }
            state = -1;
        };
        return {
            type: 'mousedown', listener: down, listeners: [{ type: 'mousemove', listener: move },
                { type: 'mouseup', listener: up }], handler: h
        };
    };
    // 单击
    const mouseTap = (el, h) => {
        const hh = (e) => {
            h({ type: 'tap', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'click', listener: hh, listeners: null, handler: h };
    };
    // 双击
    const mouseDbltap = (el, h) => {
        const hh = (e) => {
            h({ type: 'dbltap', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'dblclick', listener: hh, listeners: null, handler: h };
    };
    // 长按
    const mouseLongtap = (el, h) => {
        let time = 0;
        let x = 0;
        let y = 0;
        let ref = 0;
        const down = (e) => {
            ref && clearTimeout(ref);
            time = e.timeStamp;
            x = e.pageX;
            y = e.pageY;
            ref = setTimeout(() => {
                ref = 0;
                h({ type: 'longtap', native: e, x: x, y: y, timeStamp: time + exports.LongTapTime, startTime: time });
            }, exports.LongTapTime);
        };
        const move = (e) => {
            if (ref && (Math.abs(x - e.pageX) > exports.MoveLimit || Math.abs(y - e.pageY) > exports.MoveLimit)) {
                clearTimeout(ref);
                ref = 0;
            }
        };
        const up = (e) => {
            ref && clearTimeout(ref);
            ref = 0;
        };
        return {
            type: 'mousedown', listener: down, listeners: [{ type: 'mousemove', listener: move }, { type: 'mouseup', listener: up }],
            handler: h
        };
    };
    // 抬起
    const mouseUp = (el, h) => {
        const up = (e) => {
            h({ type: 'up', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'mouseup', listener: up, listeners: null, handler: h };
    };
    // 按下
    const mouseDown = (el, h) => {
        const down = (e) => {
            h({ type: 'down', native: e, x: e.pageX, y: e.pageY, timeStamp: e.timeStamp });
        };
        return { type: 'mousedown', listener: down, listeners: null, handler: h };
    };
    // ============================== 立即执行
    // 设置当前的手势函数表
    const gesture = [{
            move: touchMove,
            tap: touchTap,
            dbltap: touchDbltap,
            longtap: touchLongtap,
            rotsal: touchRotsal,
            up: touchUp,
            down: touchDown
        }, {
            move: mouseMove,
            tap: mouseTap,
            dbltap: mouseDbltap,
            longtap: mouseLongtap,
            up: mouseUp,
            down: mouseDown
        }
    ];
    // 事件分类，参考用
    const HTML_DEFAULT_EVENTS = {
        WINDOW_EVENT: {
            AFTER_PRINT: 'afterprint',
            BEFORE_PRINT: 'beforeprint',
            BEFORE_UNLOAD: 'beforeunload',
            ERROR: 'error',
            HASH_CHANGE: 'hashchange',
            LOAD: 'load',
            MESSAGE: 'message',
            OFFLINE: 'offline',
            LINE: 'line',
            PAGE_HIDE: 'pagehide',
            PAGE_SHOW: 'pageshow',
            POP_STATE: 'popstate',
            REDO: 'redo',
            RESIZE: 'resize',
            STORAGE: 'storage',
            UNDO: 'undo',
            UNLOAD: 'unload'
        },
        KEYBOARD_EVENT: {
            KEY_DOWN: 'keydown',
            KEY_PRESS: 'keypress',
            KEY_UP: 'keyup'
        },
        MOBILE_EVENT: {
            TOUCH_START: 'touchstart',
            TOUCH_END: 'touchend',
            TOUCH_MOVE: 'touchmove',
            TOUCH_CANCEL: 'touchcancel'
        },
        MOUSE_EVENT: {
            CLICK: 'click',
            DBL_CLICK: 'dblclick',
            DRAG: 'drag',
            DRAG_END: 'dragend',
            DRAG_ENTER: 'dragenter',
            DRAG_LEAVE: 'dragleave',
            DRAG_OVER: 'dragover',
            DRAG_START: 'dragstart',
            DROP: 'drop',
            MOUSE_DOWN: 'mousedown',
            MOUSE_MOVE: 'mousemove',
            MOUSE_OUT: 'mouseout',
            MOUSE_OVER: 'mouseover',
            MOUSE_UP: 'mouseup',
            MOUSE_WHEEL: 'mousewheel',
            SCROLL: 'scroll'
        },
        FORM_EVENT: {
            BLUR: 'blur',
            CHANGE: 'change',
            CTEXT_MENU: 'ctextmenu',
            FOCUS: 'focus',
            FORM_CHANGE: 'formchange',
            FORM_INPUT: 'forminput',
            INPUT: 'input',
            INVALID: 'invalid',
            RESET: 'reset',
            SELECT: 'select',
            SUBMIT: 'submit'
        },
        MEDIA_EVENT: {
            ABOUT: 'abort',
            CAN_PLAY: 'canplay',
            CAN_PLAY_THROUGH: 'canplaythrough',
            DURATI_CHANGE: 'duratichange',
            EMPTIED: 'emptied',
            ENDED: 'ended',
            ERROR: 'error',
            LOADED_DATA: 'loadeddata',
            LOADED_META_DATA: 'loadedmetadata',
            LOAD_START: 'loadstart',
            PAUSE: 'pause',
            PLAY: 'play',
            PLAYING: 'playing',
            PROGRESS: 'progress',
            RATE_CHANGE: 'ratechange',
            READY_STATE_CHANGE: 'readystatechange',
            SEEKED: 'seeked',
            SEEKING: 'seeking',
            STALLED: 'stalled',
            SUSPEND: 'suspend',
            TIME_UPDATE: 'timeupdate',
            VOLUME_CHANGE: 'volumechange',
            WATING: 'waiting'
        }
    };
});

_$pi.define("pi_gui/widget/virtual_node", ["require", "exports", "../../pi_sys/modules/util/util", "./painter"], function (require, exports, util_1, painter) {
    "use strict";
    
    /**
     * @description 转换类型获得VirtualNode
     * @example
     */
    exports.isVirtualNode = (node) => {
        if (node.children) {
            return node;
        }
    };
    /**
     * @description 转换类型获得VirtualNode
     * @example
     */
    exports.isVirtualWidgetNode = (node) => {
        if (node.hasChild !== undefined || node.child !== undefined) {
            return node;
        }
    };
    /**
     * @description 转换类型获得VirtualNode
     * @example
     */
    exports.isVirtualTextNode = (node) => {
        if (node.text !== undefined) {
            return node;
        }
    };
    /**
     * @description 获得指定属性的值
     * @example
     */
    exports.getAttribute = (attrs, name) => {
        return attrs[name];
    };
    /**
     * @description 寻找满足指定属性的第一个节点，递归调用，遍历vdom树。value为undefined，有属性就可以
     * @example
     */
    exports.findNodeByAttr = (node, key, value) => {
        const arr = node.children;
        for (let n of arr) {
            if (n.children) {
                const r = exports.getAttribute(n.attrs, key);
                if (value !== undefined) {
                    if (value === r) {
                        return n;
                    }
                }
                else if (r !== undefined) {
                    return n;
                }
                n = exports.findNodeByAttr(n, key, value);
                if (n) {
                    return n;
                }
            }
            else if (exports.isVirtualWidgetNode(n)) {
                const r = exports.getAttribute(n.attrs, key);
                if (value !== undefined) {
                    if (value === r) {
                        return n;
                    }
                }
                else if (r !== undefined) {
                    return n;
                }
            }
        }
    };
    /**
     * @description 寻找满足指定Tag的第一个节点，递归调用，遍历vdom树
     * @example
     */
    exports.findNodeByTag = (node, tag) => {
        const arr = node.children;
        for (let n of arr) {
            if (node.children) {
                if (n.tagName === tag) {
                    return n;
                }
                n = exports.findNodeByTag(n, tag);
                if (n) {
                    return n;
                }
            }
            else if (exports.isVirtualWidgetNode(n)) {
                if (n.tagName === tag) {
                    return n;
                }
            }
        }
    };
    /**
     * @description 用新节点创建
     * @example
     */
    exports.create = (n) => {
        if (exports.isVirtualWidgetNode(n)) {
            painter.createWidget(n);
        }
        else if (n.children) {
            createNode(n);
        }
        else if (n.text) {
            painter.createTextNode(n);
        }
    };
    /**
     * @description 用新节点替换旧节点
     * replace的前提是，已经判断这是同一个节点了，替换后对旧节点做标记，
     * @example
     */
    exports.replace = (oldNode, newNode) => {
        let b;
        if (oldNode.text !== undefined && oldNode.text !== null && newNode.text !== undefined && newNode.text !== null) {
            newNode.link = oldNode.link;
            newNode.oldOffset = oldNode.offset;
            oldNode.offset = -1;
            if (oldNode.text === newNode.text) {
                return false;
            }
            painter.modifyText(newNode, newNode.text, oldNode.text);
            return true;
        }
        painter.replaceNode(oldNode, newNode);
        newNode.oldOffset = oldNode.offset;
        oldNode.offset = -1;
        b = replaceAttr(oldNode, newNode);
        if (oldNode.childHash !== newNode.childHash || painter.forceReplace) {
            if (oldNode.children && newNode.children) {
                replaceChilds(oldNode, newNode);
            }
            else if (exports.isVirtualWidgetNode(oldNode) && exports.isVirtualWidgetNode(newNode)) {
                painter.modifyWidget(oldNode, newNode.child, oldNode.child);
            }
            b = true;
        }
        else if (oldNode.children && newNode.children) {
            // 将oldNode上的子节点及索引移动到新节点上
            newNode.didMap = oldNode.didMap;
            newNode.childHashMap = oldNode.childHashMap;
            newNode.textHashMap = oldNode.textHashMap;
            newNode.children = oldNode.children;
            for (const n of newNode.children) {
                n.parent = newNode;
            }
        }
        return b;
    };
    // ============================== 本地
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const replaceAttr = (oldNode, newNode) => {
        const oldArr = oldNode.attrs;
        if (oldNode.attrHash === newNode.attrHash && !painter.forceReplace) {
            return false;
        }
        if (newNode.attrSize && !newNode.ext) {
            newNode.ext = {};
        }
        util_1.objDiff(newNode.attrs, newNode.attrSize, oldArr, oldNode.attrSize, attrDiff, newNode);
        return true;
    };
    /**
     * @description 替换属性，计算和旧节点属性的差异
     * @example
     */
    const attrDiff = (newNode, key, v1, v2) => {
        if (v1 === undefined) {
            return painter.delAttr(newNode, key);
        }
        if (v2 === undefined) {
            return painter.addAttr(newNode, key, v1);
        }
        painter.modifyAttr(newNode, key, v1, v2);
    };
    /**
     * @description 在数组中寻找相同节点
     * @example
     */
    const findSameHashNode = (arr, node) => {
        if (!arr) {
            return;
        }
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (n.offset >= 0 && n.tagName === node.tagName && n.sid === node.sid && n.attrHash === node.attrHash) {
                return n;
            }
        }
    };
    /**
     * @description 在数组中寻找相似节点
     * @example
     */
    const findLikeHashNode = (arr, node) => {
        if (!arr) {
            return;
        }
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (n.offset >= 0 && n.tagName === node.tagName && n.sid === node.sid) {
                return n;
            }
        }
    };
    /**
     * @description 寻找相同节点的函数
     * VirtualNode根据 did attrHash childHash 寻找相同节点，如果没有找到，则返回undefined
     * @example
     */
    const findSameVirtualNode = (oldParent, newParent, child) => {
        let n;
        if (child.did && oldParent.didMap) {
            n = oldParent.didMap.get(child.did);
            if (n && n.offset >= 0 && n.tagName === child.tagName && n.sid === child.sid) {
                return n;
            }
        }
        else if (oldParent.childHashMap) {
            return findSameHashNode(oldParent.childHashMap.get(child.childHash), child);
        }
    };
    /**
     * @description 寻找相似节点的函数
     * VirtualNode根据 childHash attrHash offset 依次寻找相似节点，如果没有找到，则返回undefined
     * @example
     */
    const findLikeVirtualNode = (oldParent, newParent, child, offset) => {
        if (!oldParent.childHashMap) {
            return;
        }
        let n;
        const arr = oldParent.childHashMap.get(child.childHash);
        n = findLikeHashNode(arr, child);
        if (n) {
            return n;
        }
        n = oldParent.children[offset];
        if (n && n.childHash !== undefined && n.offset >= 0 && child.tagName === n.tagName && child.sid === n.sid) {
            return n;
        }
    };
    /**
     * @description 寻找相同文本节点的函数
     * VirtualNode根据 textHash依次寻找相同节点，如果没有找到，则返回undefined
     * @example
     */
    const findSameVirtualTextNode = (oldParent, newParent, child) => {
        const arr = oldParent.textHashMap && oldParent.textHashMap.get(child.childHash);
        if (arr && arr.length > 0) {
            return arr.shift();
        }
    };
    /**
     * @description 寻找相似文本节点的函数
     * VirtualNode根据 offset 寻找相似节点，如果没有找到，则返回undefined
     * @example
     */
    // tslint:disable:max-line-length
    const findLikeVirtualTextNode = (oldParent, newParent, child, offset) => {
        const n = oldParent.children[offset];
        if (n && n.text && n.offset >= 0) {
            return n;
        }
    };
    /**
     * @description 初始化子节点，并在父节点上添加索引
     * @example
     */
    const initAndMakeIndex = (n, i, parent) => {
        let map;
        let nodes;
        n.parent = parent;
        n.offset = i;
        n.widget = parent.widget;
        if (n.did) {
            if (!parent.didMap) {
                parent.didMap = new Map();
            }
            parent.didMap.set(n.did, n);
        }
        else {
            map = parent.childHashMap;
            if (!map) {
                parent.childHashMap = map = new Map();
            }
            nodes = map.get(n.childHash) || [];
            nodes.push(n);
            map.set(n.childHash, nodes);
            nodes = map.get(n.attrHash) || [];
            nodes.push(n);
            map.set(n.attrHash, nodes);
        }
    };
    /**
     * @description 文本索引
     * @example
     */
    const makeTextIndex = (n, i, parent) => {
        n.parent = parent;
        n.offset = i;
        let map = parent.textHashMap;
        if (!map) {
            parent.textHashMap = map = new Map();
        }
        const nodes = map.get(n.childHash) || [];
        nodes.push(n);
        map.set(n.childHash, nodes);
    };
    /**
     * @description 用新节点创建
     * @example
     */
    const createNode = (node) => {
        const arr = node.children;
        painter.createNode(node);
        const parent = node.link;
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (exports.isVirtualWidgetNode(n)) {
                initAndMakeIndex(n, i, node);
                painter.createWidget(n);
            }
            else if (n.children) {
                initAndMakeIndex(n, i, node);
                createNode(n);
            }
            else {
                makeTextIndex(n, i, node);
                painter.createTextNode(n);
            }
            painter.addNode(parent, n, true);
        }
    };
    /**
     * @description 子节点替换方法，不应该使用编辑距离算法
     * 依次处理所有删除的和一般修改的节点。最后处理位置变动和新增的，如果位置变动超过1个，则清空重新添加节点
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    const replaceChilds = (oldNode, newNode) => {
        let n;
        let same;
        let arr = newNode.children;
        const len = arr.length;
        let next = false;
        let insert = false;
        let move = 0;
        for (let i = 0, offset = 0; i < len; i++) {
            n = arr[i];
            if (n.tagName !== undefined) {
                initAndMakeIndex(n, i, newNode);
                // 在旧节点寻找相同节点
                same = findSameVirtualNode(oldNode, newNode, n);
            }
            else {
                makeTextIndex(n, i, newNode);
                // 在旧节点寻找相同节点
                same = findSameVirtualTextNode(oldNode, newNode, n);
            }
            if (!same) {
                offset++;
                // 猜测用最新的位置差能够找到变动的节点
                n.oldOffset = -offset;
                next = true;
                continue;
            }
            // 记录最新相同节点的位置差
            offset = same.offset + 1;
            exports.replace(same, n);
            // 计算有无次序变动
            if (move >= 0) {
                move = (move <= offset) ? offset : -1;
            }
        }
        if (next) {
            move = 0;
            // 寻找相似节点
            for (let i = 0; i < len; i++) {
                n = arr[i];
                if (n.oldOffset >= 0) {
                    // 计算有无次序变动
                    if (move >= 0) {
                        move = (move <= n.oldOffset) ? n.oldOffset : -1;
                    }
                    continue;
                }
                if (n.tagName !== undefined) {
                    same = findLikeVirtualNode(oldNode, newNode, n, -n.oldOffset - 1);
                }
                else {
                    same = findLikeVirtualTextNode(oldNode, newNode, n, -n.oldOffset - 1);
                }
                if (!same) {
                    exports.create(n);
                    insert = true;
                    continue;
                }
                exports.replace(same, n);
                // 计算有无次序变动
                if (move >= 0) {
                    move = (move <= n.oldOffset) ? n.oldOffset : -1;
                }
            }
        }
        // 删除没有使用的元素
        arr = oldNode.children;
        for (let i = arr.length - 1; i >= 0; i--) {
            if (arr[i].offset >= 0) {
                painter.delNode(arr[i]);
            }
        }
        arr = newNode.children;
        const parent = newNode.link;
        // 如果有节点次序变动，则直接在新节点上加入新子节点数组，代码更简单，性能更好
        if (move < 0) {
            // painter.paintCmd3(parent, "innerHTML", ""); //不需要清空，重新加一次，一样保证次序
            for (let i = 0; i < len; i++) {
                painter.addNode(parent, arr[i]);
            }
        }
        else if (insert) {
            // 如果没有节点次序变动，则插入节点
            for (let i = 0; i < len; i++) {
                n = arr[i];
                if (n.oldOffset < 0) {
                    painter.insertNode(parent, n, n.offset);
                }
            }
        }
    };
});
// ============================== 立即执行

/*
 * 样式模块，提供组件内包含子组件范围内基于clazz的样式匹配，clazz使用内联样式作用到实际节点上。
 * 而内联样式则不支持伪类( :hover)、伪对象( :first-child)和关键帧动画( animation keyframes)。
 * 因此，不能支持伪类和关键帧动画。可以使用全局class来处理。
 * 样式沿组件树上溯，寻找到后就注入，这样优先使用外部定义，如果没有则使用默认。
 */
_$pi.define("pi_gui/widget/style", ["require", "exports", "./html", "../../pi_sys/modules/util/util", "../../pi_sys/setup/depend"], function (require, exports, html_1, util_1, depend_1) {
    "use strict";
    
    /**
     * @description 解析字符串，返回样式表
     * @example
     * 只支持class
     */
    exports.parse = (str, path) => {
        let r = styleRxp.exec(str);
        if (!r) {
            return null;
        }
        const sheet = new Map();
        while (r) {
            const s = r[1];
            const effect = exports.parseEffect(r[2], path);
            r = styleRxp.exec(str);
            if (!effect) {
                continue;
            }
            let rr = classRxp.exec(s);
            while (rr) {
                sheet.set(rr[1], effect);
                rr = classRxp.exec(s);
            }
        }
        return sheet.size > 0 ? sheet : null;
    };
    /**
     * @description 分析样式效果，可用于内联样式和外部样式的分析
     * @example
     */
    exports.parseEffect = (str, path) => {
        const arr = str.split(';');
        const effect = { map: new Map(), url: null };
        const map = effect.map;
        let n = 0;
        for (const s of arr) {
            const i = s.indexOf(':');
            if (i < 0) {
                continue;
            }
            n++;
            const k = html_1.getSupportedProperty(s.slice(0, i).trim());
            const v = s.slice(i + 1);
            const url = getURL(k, v, path);
            if (!url) {
                map.set(k, v);
            }
            else {
                effect.url = url;
            }
        }
        return n > 0 ? effect : null;
    };
    /**
     * @description 计算clazz的样式特效，沿组件树上溯查找定义的clazz
     * @example
     */
    exports.calc = (widget, clazz, clazzStr, result) => {
        // 先从本地缓存中寻找
        let effect = widget.styleCache.get(clazzStr);
        if (effect) {
            util_1.mapCopy(effect.map, result.map);
            if (effect.url) {
                result.url = effect.url;
            }
            return result;
        }
        effect = { map: new Map(), url: null };
        const sheet = widget.getSheet();
        if (sheet) {
            // unMatchClazz数组里面存放了还没有匹配到的clazz
            const unMatchClazz = [];
            for (const name of clazz) {
                const e = sheet.get(name);
                if (e) {
                    util_1.mapCopy(e.map, effect.map);
                    if (e.url) {
                        effect.url = e.url;
                    }
                }
                else {
                    unMatchClazz.push(name);
                }
            }
            if (unMatchClazz.length > 0 && widget.parentNode) {
                exports.calc(widget.parentNode.widget, unMatchClazz, unMatchClazz.join(' '), effect);
            }
        }
        else if (widget.parentNode) {
            exports.calc(widget.parentNode.widget, clazz, clazzStr, effect);
        }
        widget.styleCache.set(clazzStr, effect);
        util_1.mapCopy(effect.map, result.map);
        result.url = effect.url;
        return result;
    };
    /**
     * @description 合并内联样式和clazz样式
     * @example
     */
    exports.merge = (innerStyle, clazzStyle) => {
        if (!innerStyle) {
            return clazzStyle;
        }
        if (!clazzStyle) {
            return innerStyle;
        }
        const map = new Map();
        util_1.mapCopy(clazzStyle.map, map);
        util_1.mapCopy(innerStyle.map, map);
        return { map: map, url: innerStyle.url ? innerStyle.url : clazzStyle.url };
    };
    /**
     * @description 计算新旧样式的差异部分
     * @example
     */
    exports.difference = (oldStyle, newStyle) => {
        if (!oldStyle) {
            return newStyle;
        }
        const diff = { map: new Map(), url: null };
        const om = oldStyle.map;
        const dm = diff.map;
        if (!newStyle) {
            for (const k of om.keys()) {
                dm.set(k, '');
            }
            return diff;
        }
        util_1.mapDiff(newStyle.map, om, diffMap, dm);
        if (oldStyle.url) {
            if (newStyle.url) {
                if (oldStyle.url.key !== newStyle.url.key || !util_1.arrayEqual(oldStyle.url.arr, newStyle.url.arr)) {
                    diff.url = newStyle.url;
                }
            }
        }
        else if (newStyle.url) {
            diff.url = newStyle.url;
        }
        return diff;
    };
    /**
     * @description 在高优先级的样式中过滤指定新样式
     * @example
     */
    exports.filter = (highStyle, style) => {
        if (!highStyle) {
            return;
        }
        const map2 = style.map;
        const map1 = highStyle.map;
        for (const k of map2.keys()) {
            if (!map1.has(k)) {
                continue;
            }
            map2.delete(k);
            if (style.url && style.url.key === k) {
                style.url = null;
            }
        }
    };
    // ============================== 本地
    // 匹配样式
    const styleRxp = /\s*([^{]*)\s*{\s*([^}]*)}/g;
    // 匹配类选择器
    const classRxp = /\s*\.([-_\w]+)\s*,?/g;
    // 匹配CSS的effect中的url，不匹配含有:的字符串，所以如果是http:或https:，则不替换
    const effectURL = /url\(([^\)"':]*)\)/g;
    // 获得路径的url
    const getURL = (k, v, path) => {
        // 替换url为全路径
        let rr = effectURL.exec(v);
        if (!rr) {
            return;
        }
        const info = { key: k, arr: [] };
        let suffix = 0;
        const arr = info.arr;
        do {
            // tslint:disable:prefer-template
            arr.push(v.slice(suffix, rr.index) + 'url(');
            arr.push(depend_1.relativePath(rr[1], path));
            suffix = rr.index + rr[0].length - 1;
            rr = effectURL.exec(v);
        } while (rr);
        arr.push(v.slice(suffix));
        return info;
    };
    // 写入diffMap
    const diffMap = (dm, key, newv, oldv) => {
        dm.set(key, newv || '');
    };
});

/**
 * vdom和组件的渲染器，提供全局的命令列表，将真实dom操作延迟到帧渲染时调用
 * 新建DOM节点及子节点时，不发送渲染命令，直接调用方法
 * 注意：如果父组件修改子组件属性，并且子组件也更改根节点的属性，则以最后修改的为准
 * 注意：如果父组件定义了子组件w-class样式，并且子组件也定义了根节点的w-class样式，则以子组件的优先
 */
_$pi.define("pi_gui/widget/painter", ["require", "exports", "../../pi_sys/setup/depend", "../../pi_sys/feature/log", "../../pi_sys/modules/util/res_mgr", "../../pi_sys/modules/util/util", "./event", "../../pi_sys/modules/util/frame_mgr", "./style", "./virtual_node", "./widget"], function (require, exports, depend_1, log_1, res_mgr_1, util_1, event, frame_mgr_1, style_1, virtual_node_1, widget_1) {
    "use strict";
    
    /**
     * @description 是否忽略hash相同，强制比较和替换
     * @example
     */
    exports.forceReplace = false;
    /**
     * @description 是否显示w-前缀的属性
     * @example
     */
    exports.showWAttr = false;
    /**
     * @description 创建节点后的处理函数，一般给扩展方调用
     * @example
     */
    exports.createHandler = null;
    /**
     * @description 是否显示w-前缀的属性
     * @example
     */
    exports.setShowWAttr = (value) => {
        exports.showWAttr = value;
    };
    /**
     * @description 是否显示w-前缀的属性
     * @example
     */
    exports.setCreateHandler = (func) => {
        exports.createHandler = func;
    };
    /**
     * @description 获得真实的dom节点
     * @example
     */
    exports.getRealNode = (node) => {
        let n;
        while (node) {
            n = virtual_node_1.isVirtualWidgetNode(node);
            if (!n) {
                return node.link;
            }
            node = n.link.tree;
        }
    };
    /**
     * @description 替换节点，只替换了当前节点的link ext, 其他属性和子节点均没有替换
     * @example
     */
    exports.replaceNode = (oldNode, newNode) => {
        newNode.link = oldNode.link;
        const n = virtual_node_1.isVirtualWidgetNode(newNode);
        if (n) {
            n.link.parentNode = n;
        }
        newNode.ext = oldNode.ext;
        event.rebindEventMap(oldNode, newNode);
    };
    /**
     * @description 添加节点的属性，并没有真正的添加，只是传了一个命令
     * @example
     */
    exports.addAttr = (node, key, value) => {
        exports.setAttr(node, key, value);
    };
    /**
     * @description 修改节点的属性
     * @example
     */
    exports.modifyAttr = (node, key, newValue, oldValue) => {
        exports.setAttr(node, key, newValue);
    };
    /**
     * @description 删除节点的属性
     * @example
     */
    exports.delAttr = (node, key) => {
        exports.setAttr(node, key);
    };
    /**
     * @description 添加节点的属性，并没有真正的添加，只是传了一个命令
     * @example
     */
    // tslint:disable-next-line:cyclomatic-complexity
    exports.setAttr = (node, key, value, immediately) => {
        if (key === 'class') {
            cmdSet(exports.getRealNode(node), 'className', value, immediately);
            return;
        }
        if (key === 'style') {
            return setAttrStyle(node, key, value, immediately);
        }
        if (setAttrEventListener(node, key, value) && !exports.showWAttr) {
            return;
        }
        if (key.charCodeAt(0) === 119 && key.charCodeAt(1) === 45) {
            if (key === 'w-class') {
                setAttrClazz(node, key, value, immediately);
            }
            else if (key === 'w-plugin') {
                setAttrPlugin(node, value ? JSON.parse(value) : undefined);
            }
            else if (key === 'w-props') {
                if (virtual_node_1.isVirtualWidgetNode(node)) {
                    node.ext.propsUpdate = (value === 'update');
                }
            }
            else if (key.charCodeAt(2) === 101 && key.charCodeAt(3) === 118 && key.charCodeAt(4) === 45) {
                // "w-ev-***"
                let attr = node.ext.eventAttr;
                if (!attr) {
                    node.ext.eventAttr = attr = {};
                }
                attr[key.slice(5)] = value ? JSON.parse(value) : undefined;
            }
            if (!exports.showWAttr) {
                return;
            }
        }
        const el = exports.getRealNode(node);
        // 匹配img src
        if (key === 'src' && node.tagName === 'img') {
            if (value) {
                if (value.indexOf(':') < 0) {
                    value = depend_1.relativePath(value, node.widget.tpl.path);
                    loadSrc(el, node.widget, value, immediately);
                }
                else {
                    cmdSet(el, 'src', value, immediately);
                }
            }
            else {
                cmdSet(el, 'src', '', immediately);
            }
        }
        else if (key === 'value' && (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA')) {
            cmdSet(el, 'value', value, immediately);
        }
        else if (value) {
            cmdObjCall(el, 'setAttribute', key, value, immediately);
        }
        else {
            cmdObjCall(el, 'removeAttribute', key, '', immediately);
        }
    };
    /**
     * @description 创建组件
     * @example
     */
    exports.createWidget = (node) => {
        // 处理相对tpl路径的组件
        let s = node.widget.tpl.wpath;
        if (!s) {
            node.widget.tpl.wpath = s = node.widget.tpl.path.replace(/\//g, '-');
        }
        const w = widget_1.factory(widget_1.relative(node.tagName, s));
        if (!w) {
            throw new Error(`widget not found, name: ${node.tagName}`);
        }
        node.link = w;
        node.widget.children.push(w);
        w.parentNode = node;
        if (node.hasChild || node.child) {
            if (virtual_node_1.getAttribute(node.attrs, 'w-props')) {
                w.updateProps(node.child);
            }
            else {
                w.setProps(node.child);
            }
        }
        w.paint();
        if (node.widget.inDomTree) {
            attachList.push(w);
        }
        if (node.attrSize) {
            node.ext = {};
        }
        const obj = node.attrs;
        for (const k in obj) {
            exports.setAttr(node, k, obj[k], true);
        }
        exports.createHandler && exports.createHandler(node);
    };
    /**
     * @description 创建真实节点
     * @example
     */
    exports.createNode = (node) => {
        node.link = document.createElement(node.tagName);
        if (node.attrSize) {
            node.ext = {};
        }
        const obj = node.attrs;
        for (const k in obj) {
            exports.setAttr(node, k, obj[k], true);
        }
        exports.createHandler && exports.createHandler(node);
    };
    /**
     * @description 创建文本节点
     * @example
     */
    exports.createTextNode = (node) => {
        node.link = document.createTextNode(node.text);
    };
    /**
     * @description 插入节点
     * @example
     */
    exports.insertNode = (parent, node, offset) => {
        cmdList.push([insertBefore, [parent, exports.getRealNode(node), offset]]);
    };
    /**
     * @description 添加节点
     *
     * @example
     */
    exports.addNode = (parent, node, immediately) => {
        if (immediately) {
            parent.appendChild(exports.getRealNode(node));
        }
        else {
            cmdList.push([parent, 'appendChild', [exports.getRealNode(node)]]);
        }
    };
    /**
     * @description 删除节点，不仅要删除节点还要删除其下widget
     * @example
     */
    exports.delNode = (node) => {
        let r = node.link;
        if (virtual_node_1.isVirtualNode(node)) {
            delChilds(node);
        }
        else if (virtual_node_1.isVirtualWidgetNode(node)) {
            util_1.arrDrop(node.widget.children, r);
            const w = r;
            exports.delWidget(w);
            r = exports.getRealNode(w.tree);
        }
        cmdList.push([r, 'remove', []]);
    };
    /**
     * @description 修改组件节点的数据
     * @example
     */
    exports.modifyWidget = (node, newValue, oldValue) => {
        const w = node.link;
        if (node.ext && node.ext.propsUpdate) {
            w.updateProps(newValue, oldValue);
        }
        else {
            w.setProps(newValue, oldValue);
        }
        w.paint();
    };
    /**
     * @description 修改文本节点的文本
     * @example
     */
    exports.modifyText = (node, newValue, oldValue) => {
        cmdList.push([node.link, 'nodeValue', newValue]);
    };
    /**
     * @description 删除widget及其子widgets
     * @example
     */
    exports.delWidget = (w) => {
        if (!w.destroy()) {
            return;
        }
        if (w.inDomTree) {
            detachList.push(w);
        }
        delWidgetChildren(w.children);
    };
    /**
     * @description 获得显示在真实的dom节点的组件名称
     * @example
     */
    exports.getShowWidgetName = (node, name) => {
        const n = virtual_node_1.isVirtualWidgetNode(node);
        // tslint:disable:prefer-template
        return (n) ? exports.getShowWidgetName(n.link.tree, name + ' ' + n.link.name) : name;
    };
    /**
     * @description 渲染Widget方法，如果当前正在渲染，则缓冲，渲染完成后会继续渲染该数据
     * @example
     */
    exports.paintWidget = (w, reset) => {
        const tpl = w.tpl;
        if (!tpl) {
            return;
        }
        const frameMgr = frame_mgr_1.getGlobal();
        if (cmdList.length === 0) {
            frameMgr.setBefore(paint1);
        }
        const tree = tpl.value(w.getConfig() || empty, w.getProps(), w.getState(), w);
        let old = w.tree;
        tree.widget = w;
        if (old) {
            if (reset) {
                try {
                    w.beforeUpdate();
                    const arr = w.children;
                    for (const w of arr) {
                        exports.delWidget(w);
                    }
                    w.children = [];
                    virtual_node_1.create(tree);
                    const node = exports.getRealNode(tree);
                    node.setAttribute('w-tag', exports.getShowWidgetName(tree, w.name));
                    cmdList.push([replaceTree, [node, exports.getRealNode(old)]]);
                    cmdList.push([mergnParent, [w.parentNode]]);
                    cmdList.push([w, 'afterUpdate', []]);
                    w.tree = tree;
                }
                catch (e) {
                    log_1.cc.warn() && log_1.log('paint reset fail, ', w, e);
                }
            }
            else {
                const b = old.attrHash !== tree.attrHash || old.childHash !== tree.childHash || exports.forceReplace;
                if (b) {
                    try {
                        w.beforeUpdate();
                        old = w.tree;
                        virtual_node_1.replace(old, tree);
                        cmdList.push([w, 'afterUpdate', []]);
                        w.tree = tree;
                    }
                    catch (e) {
                        log_1.cc.warn() && log_1.log('paint replace fail, ', w, e);
                        if (old.offset < 0) {
                            fixOld(virtual_node_1.isVirtualNode(old));
                        }
                    }
                }
            }
        }
        else {
            try {
                virtual_node_1.create(tree);
                exports.getRealNode(tree).setAttribute('w-tag', exports.getShowWidgetName(tree, w.name));
                w.tree = tree;
                w.firstPaint();
            }
            catch (e) {
                log_1.cc.warn() && log_1.log('paint create fail, ', w, e);
            }
        }
    };
    const mergnParent = (pNode) => {
        const obj = pNode.attrs;
        if (pNode.ext) {
            if (pNode.ext.clazzStyle) {
                pNode.ext.clazzStyle.map.clear();
            }
            if (pNode.ext.style) {
                pNode.ext.style.map.clear();
            }
            if (pNode.ext.innerStyle) {
                pNode.ext.innerStyle.map.clear();
            }
        }
        for (const k in obj) {
            exports.setAttr(pNode, k, obj[k], true);
        }
    };
    /**
     * @description 渲染命令2方法
     * @example
     */
    exports.paintCmd = (func, args) => {
        const frameMgr = frame_mgr_1.getGlobal();
        if (cmdList.length === 0) {
            frameMgr.setBefore(paint1);
        }
        cmdList.push([func, args]);
    };
    /**
     * @description 渲染命令3方法
     * @example
     */
    exports.paintCmd3 = (obj, funcOrAttr, args) => {
        const frameMgr = frame_mgr_1.getGlobal();
        if (cmdList.length === 0) {
            frameMgr.setBefore(paint1);
        }
        cmdList.push([obj, funcOrAttr, args]);
    };
    /**
     * @description 绘制时，添加组件，调用组件及子组件的attach方法
     * @example
     */
    exports.paintAttach = (w) => {
        attachList.push(w);
    };
    /**
     * @description 绘制时，删除组件，调用组件及子组件的detach方法
     * @example
     */
    exports.paintDetach = (w) => {
        detachList.push(w);
    };
    // ============================== 本地
    // 空配置
    const empty = {}; // 每个painter的指令都被放入其中
    let cmdList = [];
    // 每个被添加的widget
    let attachList = [];
    // 每个被删除的widget
    let detachList = [];
    // 临时变量
    let cmdList1 = [];
    let attachList1 = [];
    let detachList1 = [];
    /**
     * @description 最终的渲染方法，渲染循环时调用，负责实际改变dom
     * @example
     */
    const paint1 = () => {
        let arr = detachList;
        detachList = detachList1;
        detachList1 = arr;
        arr = cmdList;
        cmdList = cmdList1;
        cmdList1 = arr;
        arr = attachList;
        attachList = attachList1;
        attachList1 = arr;
        // 先调用所有要删除的widget的detach方法
        arr = detachList1;
        for (const w of arr) {
            paintDetach1(w);
        }
        arr.length = 0;
        arr = cmdList1;
        for (const cmd of arr) {
            if (cmd.length === 3) {
                const args = cmd[2];
                if (Array.isArray(args)) {
                    util_1.objCall(cmd[0], cmd[1], args);
                }
                else {
                    cmd[0][cmd[1]] = args;
                }
            }
            else if (cmd.length === 2) {
                util_1.call(cmd[0], cmd[1]);
            }
        }
        // arr.length > 3 && level <= LogLevel.debug && debug(level, "painter cmd: ", arr.concat([]));
        arr.length = 0;
        // 调用所有本次添加上的widget的attach方法
        arr = attachList1;
        for (const w of arr) {
            paintAttach1(w);
        }
        arr.length = 0;
    };
    /**
     * @description 删除子组件
     * @example
     */
    const delWidgetChildren = (arr) => {
        for (const w of arr) {
            if (w.destroy()) {
                delWidgetChildren(w.children);
            }
        }
    };
    /**
     * @description 绘制时，添加组件，调用组件及子组件的attach方法
     * @example
     */
    const paintAttach1 = (w) => {
        if (w.inDomTree) {
            return;
        }
        w.inDomTree = true;
        w.attach();
        for (const c of w.children) {
            paintAttach1(c);
        }
    };
    /**
     * @description 绘制时，删除组件，调用组件及子组件的detach方法
     * @example
     */
    const paintDetach1 = (w) => {
        if (!w.inDomTree) {
            return;
        }
        w.inDomTree = false;
        for (const c of w.children) {
            paintDetach1(c);
        }
        w.detach();
    };
    /**
     * @description 设置节点的style
     * @example
     */
    const setAttrStyle = (node, key, value, immediately) => {
        node.ext.innerStyle = value ? style_1.parseEffect(value, node.widget.tpl.path) : null;
        setDiffStyle(node, immediately);
    };
    /**
     * @description 设置节点的clazz
     * @example
     */
    const setAttrClazz = (node, key, value, immediately) => {
        if (value) {
            const clazz = value.trim().split(/\s+/);
            if (clazz[0].length > 0) {
                node.ext.clazzStyle = style_1.calc(node.widget, clazz, clazz.join(' '), { map: new Map(), url: null });
            }
        }
        else {
            node.ext.clazzStyle = null;
        }
        setDiffStyle(node, immediately);
    };
    /**
     * @description 设置节点的插件
     * @example
     */
    const setAttrPlugin = (node, cfg) => {
        const w = node.widget;
        const old = node.ext.plugin;
        node.ext.plugin = cfg;
        new Promise((resolve_1, reject_1) => { require([depend_1.relativePath(cfg ? cfg.mod : old.mod, w.tpl.path)], resolve_1, reject_1); }).then((mod) => {
            mod.pluginBind && mod.pluginBind(w, node, cfg, old);
        });
    };
    /**
     * @description 设置节点的style
     * @example
     */
    const setDiffStyle = (node, immediately) => {
        const ext = node.ext;
        const style = style_1.merge(ext.innerStyle, ext.clazzStyle);
        const diff = style_1.difference(ext.style, style);
        ext.style = style;
        if (!diff) {
            return;
        }
        const el = getFilterStyleRealNode(node, diff);
        if (!el) {
            return;
        }
        loadURL(el, node.widget, diff);
        cmdCall(exports.setStyle, el, diff, immediately);
    };
    /**
     * @description 获得过滤样式后的真实的dom节点,如果过滤的样式不存在，则不向下获取dom节点
     * @example
     */
    const getFilterStyleRealNode = (node, diff) => {
        let n;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            n = virtual_node_1.isVirtualWidgetNode(node);
            if (!n) {
                return node.link;
            }
            node = n.link.tree;
            if (!node) {
                return null;
            }
            if (!node.ext) {
                continue;
            }
            style_1.filter(node.ext.clazzStyle, diff);
            style_1.filter(node.ext.innerStyle, diff);
            if (diff.map.size === 0) {
                return null;
            }
        }
    };
    /**
     * @description 设置节点的事件，因为并不影响显示，所以立即处理，而不是延迟到渲染时。因为vnode已经被改变，如果延迟，也是会有事件不一致的问题
     * @example
     */
    const setAttrEventListener = (node, key, value) => {
        // tslint:disable:no-reserved-keywords
        const type = event.getEventType(key);
        if (type === event.USER_EVENT_PRE) {
            event.addUserEventListener(node, key, type, value);
            return true;
        }
        if (type) {
            event.addNativeEventListener(node, exports.getRealNode(node), key, type, value);
            return true;
        }
        return false;
    };
    /**
     * @description 命令属性设置
     * @example
     */
    const cmdSet = (obj, key, value, immediately) => {
        if (immediately) {
            obj[key] = value;
        }
        else {
            cmdList.push([obj, key, value]);
        }
    };
    /**
     * @description 命令方法调用
     * @example
     */
    const cmdCall = (func, arg1, arg2, immediately) => {
        if (immediately) {
            func(arg1, arg2);
        }
        else {
            cmdList.push([func, [arg1, arg2]]);
        }
    };
    /**
     * @description 命令方法调用
     * @example
     */
    const cmdObjCall = (obj, func, arg1, arg2, immediately) => {
        if (immediately) {
            obj[func](arg1, arg2);
        }
        else {
            cmdList.push([obj, func, [arg1, arg2]]);
        }
    };
    /**
     * @description 删除节点的子节点，不仅要删除节点还要删除其下widget
     * @example
     */
    const delChilds = (node) => {
        const arr = node.children;
        for (const n of arr) {
            if (virtual_node_1.isVirtualNode(n)) {
                delChilds(n);
            }
            else if (virtual_node_1.isVirtualWidgetNode(n)) {
                exports.delWidget(n.link);
            }
        }
    };
    /**
     * @description 设置元素的样式，跳过指定样式
     * @example
     */
    exports.setStyle = (el, style) => {
        const s = el.style;
        const map = style.map;
        for (const [k, v] of map) {
            s[k] = v;
        }
    };
    /**
     * @description 插入节点
     * @example
     */
    const insertBefore = (parent, el, offset) => {
        parent.insertBefore(el, parent.childNodes[offset]);
    };
    /**
     * @description 删除树节点
     * @example
     */
    const replaceTree = (newEl, oldEl) => {
        const parent = oldEl.parentNode;
        parent && parent.replaceChild(newEl, oldEl);
    };
    /**
     * @description 替换图像的src
     * @example
     */
    const loadSrc = (el, widget, src, immediately) => {
        let tab = widget.resTab;
        if (!tab) {
            widget.resTab = tab = new res_mgr_1.ResTab();
        }
        // const name = RES_TYPE_BLOB + ':' + src;
        // const res = tab.get(name);
        // if (res) {
        // 	cmdSet(el, 'src', res.link, immediately);
        // } else {
        // 	tab.load(name, RES_TYPE_BLOB, src, undefined, (res) => {
        // 		paintCmd3(el, 'src', res.link);
        // 	});
        // }
    };
    /**
     * @description 替换含URL的样式或图像的src
     * @example
     */
    const loadURL = (el, widget, style) => {
        let tab = widget.resTab;
        const url = style.url;
        if (!url) {
            return;
        }
        if (!tab) {
            widget.resTab = tab = new res_mgr_1.ResTab();
        }
        const arr = url.arr.concat();
        let count = (arr.length / 2) | 0;
        for (let i = arr.length - 2; i > 0; i -= 2) {
            const file = arr[i];
            // const name = RES_TYPE_BLOB + ':' + file;
            // const res = tab.get(name);
            // if (res) {
            // 	arr[i] = res.link;
            // 	count--;
            // 	if (count <= 0) {
            // 		style.map.set(url.key, arr.join(''));
            // 	}
            // } else {
            // 	tab.load(name, RES_TYPE_BLOB, file, undefined, urlLoad(arr, i, () => {
            // 		count--;
            // 		if (count <= 0) {
            // 			paintCmd3(el.style, url.key, arr.join(''));
            // 		}
            // 	}));
            // }
        }
    };
    /**
     * @description 替换含URL的样式或图像的src
     * @example
     */
    const urlLoad = (arr, i, callback) => {
        return (res) => {
            arr[i] = res.link;
            callback();
        };
    };
    /**
     * @description 尽量修复旧节点，已经重绑定的事件和发出的渲染指令还是会生效
     * @example
     */
    const fixOld = (old) => {
        if (!old) {
            return;
        }
        const arr = old.children;
        for (let n, i = 0, len = arr.length; i < len; i++) {
            n = arr[i];
            if (n.offset >= 0) {
                continue;
            }
            n.offset = i;
            fixOld(virtual_node_1.isVirtualNode(n));
        }
    };
});

// 模块描述
/*
负责显示逻辑，是数据和原始dom间的桥梁
组件支持嵌套，并且tpl中的自定义元素支持相对路径。
组件名的规则：可以使用英文小写字母加'_'和''。 '-'表示路径分隔，'$'只能在最后，1个'$'表示本目录开始查找，N个'$'表示上溯N-1个父目录开始查找。如果没有'$'表示从根目录下开始查找
举例：
<role_show$ style=""></role_show$>表示本目录下的role_show组件，
<role_show$$ style=""> </role_show$$>表示父目录下的role_show组件，
<role_show-zb_show$$ style=""></role_show-zb_show$$>表示父目录下role_show目录下的zb_show组件
<app-base-btn style=""></app-base-btn>表示根目录开始，app/base目录下的btn组件
*/
_$pi.define("pi_gui/widget/widget", ["require", "exports", "../../pi_sys/modules/util/event", "../../pi_sys/feature/log", "../../pi_sys/modules/util/util", "./painter"], function (require, exports, event_1, log_1, util_1, painter_1) {
    "use strict";
    
    /**
     * @description 组件
     * @example
     * 组件，包含样式和模板的js类,
     * 注意区分 widget实例和widget节点
     * widget节点的link属性指向了widget实例
     */
    class Widget extends event_1.HandlerTable {
        constructor() {
            super(...arguments);
            // 必须要赋初值，不然new出来的实例里面是没有这些属性的
            this.name = null; // 组件的名称
            this.tpl = null; // 组件的模板
            this.sheet = null; // 组件的样式
            this.config = null; // 所对应的配置
            this.forelet = null; // 所对应的forelet
            this.props = null; // 由父组件设置的组件属性
            this.state = null; // 由forelet设置的组件状态
            this.tree = null; // 组件所对应的节点树
            this.parentNode = null; // 父节点，parentNode.link的对象就是widget
            this.children = []; // 所有的子组件
            this.inDomTree = false; // 是否在dom树中
            this.resTab = null; // 资源表
            this.resTimeout = 3000; // 资源缓冲时间，默认3秒
            this.styleCache = new Map(); // 样式查询缓存
        }
        /**
         * 创建后调用，一般在渲染循环外调用
         */
        create() {
            this.forelet && this.forelet.addWidget(this);
        }
        /**
         * 第一次计算后调用，此时创建了真实的dom，但并没有加入到dom树上，一般在渲染循环外调用
         */
        firstPaint() {
            this.forelet && this.forelet.eventWidget(this, 'firstPaint');
        }
        /**
         * 销毁时调用，一般在渲染循环外调用
         */
        destroy() {
            if (!this.tpl) {
                return false;
            }
            this.tpl = undefined;
            if (this.resTab) {
                this.resTab.timeout = this.resTimeout;
                this.resTab.release();
            }
            this.forelet && this.forelet.removeWidget(this);
            return true;
        }
        /**
         * 添加到dom树后调用，在渲染循环内调用
         */
        // tslint:disable:no-empty
        attach() {
        }
        /**
         * 更新到dom树前调用，一般在渲染循环外调用
         */
        beforeUpdate() {
            this.forelet && this.forelet.eventWidget(this, 'update');
        }
        /**
         * 更新到dom树后调用，在渲染循环内调用
         */
        afterUpdate() {
        }
        /**
         * 从dom树上移除前调用，一般在渲染循环内调用
         */
        detach() {
        }
        /**
         * 获得样式数据
         */
        getSheet() {
            return this.sheet && this.sheet.value;
        }
        /**
         * 获得配置数据
         */
        getConfig() {
            return this.config && this.config.value;
        }
        /**
         * 获得渲染数据
         */
        getProps() {
            return this.props;
        }
        /**
         * 设置属性，默认外部传入的props是完整的props，重载可改变行为
         * @param props 新数据
         * @param oldProps 老数据
         */
        setProps(props, oldProps) {
            this.props = props;
        }
        /**
         * 更新属性，默认外部传入的props是更新命令，必须为Json对象，键的结构类似"a.b.c"，重载可改变行为
         */
        updateProps(props, oldProps) {
            if (!props) {
                return;
            }
            if (!this.props) {
                this.props = props;
                return;
            }
            for (const k in props) {
                util_1.setValue(this.props, k, props[k]);
            }
        }
        /**
         * 获得渲染数据
         */
        getState() {
            return this.state;
        }
        /**
         * 设置状态
         */
        setState(state) {
            this.state = state;
        }
        /**
         * 绘制方法，
         * @param reset 表示新旧数据差异很大，不做差异计算，直接生成dom
         */
        paint(reset) {
            painter_1.paintWidget(this, reset);
        }
    }
    exports.Widget = Widget;
    /**
     * @description 注册组件
     * @example
     */
    exports.register = (name, widget, tpl, sheet, config, forelet) => {
        const old = widgetMap.get(name);
        if (old) {
            log_1.cc.warn() && log_1.log('widget already register, name:', name);
        }
        widget = widget || getWidget;
        widgetMap.set(name, { name, widget, tpl, sheet, config, forelet });
        return old;
    };
    /**
     * @description 查询组件
     * @example
     */
    exports.lookup = (name) => {
        return widgetMap.get(name);
    };
    /**
     * @description 列出所有的组件
     * @example
     */
    exports.list = () => {
        return [...widgetMap.values()];
    };
    /**
     * @description 取消注册组件
     * @example
     */
    exports.unregister = (name) => {
        return widgetMap.delete(name);
    };
    /**
     * @description 创建组件
     * @example
     */
    exports.factory = (name) => {
        const creator = widgetMap.get(name);
        if (!creator) {
            return;
        }
        const c = creator.widget();
        const w = new c();
        w.name = name;
        if (creator.sheet) {
            w.sheet = creator.sheet;
        }
        if (creator.tpl) {
            w.tpl = creator.tpl;
        }
        if (creator.config) {
            w.config = creator.config;
        }
        if (creator.forelet) {
            w.forelet = creator.forelet();
        }
        w.create();
        return w;
    };
    /**
     * @description 计算相对组件路径
     * @example
     */
    exports.relative = (name, dir) => {
        let j;
        let i = name.length - 1;
        if (name.charCodeAt(i) !== 36) {
            return name;
        }
        j = dir.length - 1;
        if (dir.charCodeAt(j) !== 47) {
            j = dir.lastIndexOf('-');
        }
        while (i >= 0) {
            if (name.charCodeAt(i - 1) !== 36) {
                break;
            }
            i--;
            j = dir.lastIndexOf('-', j - 1);
        }
        if (i < 0) {
            return '';
        }
        name = name.slice(0, i);
        if (j < 0) {
            return name;
        }
        if (j < dir.length - 1) {
            dir = dir.slice(0, j + 1);
        }
        return dir + name;
    };
    /**
     * @description 获取tpl、css和cfg缓冲
     * @example
     */
    exports.getCache = (file) => {
        return cacheMap.get(file);
    };
    /**
     * @description 设置tpl、css和cfg缓冲
     * @example
     */
    exports.setCache = (file, data) => {
        cacheMap.set(file, data);
    };
    /**
     * @description 清除tpl、css和cfg缓冲
     * @example
     */
    exports.deleteCache = (file) => {
        cacheMap.delete(file);
    };
    // ============================== 本地
    // 组件模板表
    const widgetMap = new Map();
    // tpl、css和cfg缓冲
    const cacheMap = new Map();
    // 获得默认组件
    const getWidget = () => Widget;
});
// ============================== 立即执行

/*
负责进行业务逻辑处理，是数据库和显示组件间的桥梁， 输入->逻辑计算->输出
输入：
1、用户事件
2、数据库中数据被修改的事件
3、网络事件

输出：
1、操作数据库（同步）
2、网络通信（异步）
3、生成显示数据，调用paint，显示到界面上（可选同步或异步）

为了平滑显示，复杂的处理逻辑应该使用任务管理器进行调度处理
*/
_$pi.define("pi_gui/widget/forelet", ["require", "exports", "../util/event", "../../pi_sys/modules/util/task_mgr"], function (require, exports, event_1, task_mgr_1) {
    "use strict";
    
    // ============================== 导出
    /**
     * @description 前端部件
     * @example
     */
    class Forelet extends event_1.HandlerTable {
        constructor() {
            super(...arguments);
            // 必须要赋初值，不然new出来的实例里面是没有这些属性的
            this.widgets = []; // 关联的组件
            this.listener = null; // 监听器
            // tslint:disable:variable-name
            this._data = null; // 延迟渲染的数据
            this._dataState = DataState.init; // 延迟渲染的状态
            this._args = [this];
        }
        /**
         * @description 添加widget，自动在widget创建时调用
         * @example
         */
        addWidget(w) {
            this.listener && this.listener('add', w);
            w.setState(this._data);
            this.widgets.push(w);
        }
        /**
         * @description widget事件
         * @example
         */
        // tslint:disable:no-reserved-keywords
        eventWidget(w, type) {
            this.listener && this.listener(type, w);
        }
        /**
         * @description widget被移除，自动在widget销毁时调用
         * @example
         */
        removeWidget(w) {
            const arr = this.widgets;
            const i = arr.indexOf(w);
            if (i < 0) {
                return;
            }
            if (i < arr.length - 1) {
                arr[i] = arr[arr.length - 1];
            }
            arr.length--;
            this.listener && this.listener('remove', w);
        }
        /**
         * @description 获取指定名称的widget
         * @example
         */
        getWidget(name) {
            const arr = this.widgets;
            for (const w of arr) {
                if (w.name === name) {
                    return w;
                }
            }
        }
        /**
         * @description 绘制方法，
         * @parms reset表示新旧数据差异很大，不做差异计算，直接生成dom
         * @parms immediately，表示同步计算dom，不延迟到系统空闲时
         * @example
         */
        paint(data, reset, immediately) {
            const s = this._dataState;
            // tslint:disable:no-constant-condition
            this._dataState = (reset || s === DataState.reset_true) ? DataState.reset_true : DataState.reset_false;
            this._data = data;
            if (immediately) {
                return paint1(this);
            }
            if (s === DataState.init) {
                if (this.widgets.length > 0) {
                    task_mgr_1.set(paint1, this._args, 900000, 1);
                }
                else {
                    this._dataState = DataState.init;
                }
            }
        }
    }
    exports.Forelet = Forelet;
    // ============================== 本地
    /**
     * @description 处理器返回值
     */
    var DataState;
    (function (DataState) {
        DataState[DataState["init"] = 0] = "init";
        DataState[DataState["reset_false"] = 1] = "reset_false";
        DataState[DataState["reset_true"] = 2] = "reset_true";
    })(DataState || (DataState = {}));
    /**
     * @description 绘制方法，
     * @example
     */
    const paint1 = (f) => {
        const data = f._data;
        const r = f._dataState === DataState.reset_true;
        f._dataState = DataState.init;
        for (const w of f.widgets) {
            w.setState(data);
            w.paint(r);
        }
    };
});
// ============================== 立即执行

_$pi.define("pi_gui/gui/gui_virtual/util", ["require", "exports", "../../../pi_sys/setup/depend", "../gui_virtual/tpl", "../../widget/html", "../../../pi_sys/modules/util/res_mgr", "../../../pi_sys/load/app", "../../../pi_sys/modules/util/util", "./forelet", "./painter", "./virtaul_node_keyword", "./widget", "./virtual_style", "../gui/r_document"], function (require, exports, depend_1, tpl_1, html_1, res_mgr_1, app_1, util_1, forelet_1, painter_1, virtaul_node_keyword_1, widget_1, virtual_style_1, r_document_1) {
    "use strict";
    
    // ============================== 导出
    exports.scriptTpl = true; // 通过script加载tpl
    const tplWait = []; // 脚本加载tpl队列
    const slowWait = {
        suffixMap: new Map(),
        fileMap: {}
    }; // 慢下载
    /**
     * @description 将指定名称的组件，加入到el元素的第一个元素前，会延迟到帧调用时添加
     * @example
     */
    exports.addWidget = (el, name, props) => {
        const w = widget_1.factory(name);
        if (!w) {
            return;
        }
        if (props) {
            w.setProps(props);
        }
        w.paint();
        painter_1.paintCmd3(el, 'appendChild', [w.tree[virtaul_node_keyword_1.VNKeyWords.link]]);
        return w;
    };
    /**
     * @description 标签匹配， 判断模式字符串，是否和标签匹配，标签可以多级
     * @example
     * not($b1) or($b1,$b2) and(or($b1=c1,$b2!=c2), not($b3)
     * 	$b1、$b2表示flag是否含有此键， $b2!=c2表示flag的b2键的值要不等于c2
     */
    exports.flagMatch = (pattern, flags) => {
        return exports.parseMatch({ str: pattern.trim() }, flags);
    };
    // /**
    //  * @description 列出目录及子目录下所有的文件，跳过重复文件
    //  * 如果一个目录中含有 .exclude.<文件后缀>.<标签匹配语句> 文件，则表示该目录指定后缀（没有后缀表示所有文件）需要进行排除匹配，如果匹配成功，则该目录及子目录的指定后缀的文件被排除。
    //  * @example
    //  */
    // // tslint:disable-next-line:max-line-length
    // export const listDir = (info: any, flags: Json, fileList: string[], suffixMap: Map<string, any[]>, resultMap: any, suffixCfg: any, withOut: Function): void => {
    //     if (resultMap[info.path]) {
    //         return;
    //     }
    //     let scfg;
    //     const children = info.children;
    //     const files = [];
    //     const dirs = [];
    //     for (const name in children) {
    //         if (!children.hasOwnProperty(name)) {
    //             continue;
    //         }
    //         const info = children[name];
    //         if (info.children) {
    //             dirs.push(info);
    //             continue;
    //         }
    //         if (!name.startsWith(exclude)) {
    //             files.push(info);
    //             continue;
    //         }
    //         const i = name.indexOf('.', exclude.length);
    //         if (!flagMatch(name.slice(i + 1), flags)) {
    //             continue;
    //         }
    //         const suf = name.slice(exclude.length, i);
    //         if (!suf) {
    //             return;
    //         }
    //         if (!scfg) {
    //             scfg = { ...suffixCfg };
    //         }
    //         scfg[suf] = 'none';
    //     }
    //     for (let i = files.length - 1; i > -1; i--) {
    //         listFile(files[i], flags, fileList, suffixMap, resultMap, scfg || suffixCfg, withOut);
    //     }
    //     for (const d of dirs) {
    //         listDir(d, flags, fileList, suffixMap, resultMap, scfg || suffixCfg, withOut);
    //     }
    // };
    // // tslint:disable-next-line:max-line-length
    // export const listDirFile = (dirs: string[], flags: Json, fileList: any[], suffixMap: Map<string, any[]>, resultMap: any, suffixCfg: any, withOut: Function): void => {
    //     const dirSuffixCfg = {};
    //     resultMap = resultMap || {};
    //     if (suffixCfg) {
    //         for (const k in suffix_cfg) {
    //             if (!suffixCfg[k]) {
    //                 suffixCfg[k] = suffix_cfg[k];
    //             }
    //         }
    //     } else {
    //         suffixCfg = suffix_cfg;
    //     }
    //     for (const dir of dirs) {
    //         const info = getFile(dir);
    //         if (!info) {
    //             continue;
    //         }
    //         if (info.children) {
    //             // tslint:disable-next-line:max-line-length
    //             listDir(info, flags, fileList, suffixMap, resultMap, findExclude(getParentInfo(info.path), flags, suffixCfg, dirSuffixCfg), withOut);
    //         } else {
    //             listFile(info, flags, fileList, suffixMap, resultMap, suffixCfg, withOut);
    //         }
    //     }
    //     // fileList 去除所有的模块文件
    //     for (let f, i = fileList.length - 1; i >= 0; i--) {
    //         f = fileList[i].path;
    //         // 跳过后缀不为".js"的文件
    //         if ((f.charCodeAt(f.length - 1) !== 115 || f.charCodeAt(f.length - 2) !== 106 || f.charCodeAt(f.length - 3) !== 46)) {
    //             continue;
    //         }
    //         if (i < fileList.length - 1) {
    //             fileList[i] = fileList[fileList.length - 1];
    //         }
    //         fileList.length--;
    //     }
    // };
    // export const fileDepends = (suffixMap: Map<string, any[]>, fileList: any[]): string[] => {
    //     // modNames 去除已经加载的模块文件
    //     const modNames = suffixMap.get('js') || [];
    //     // tpl现在也和一般的js模块相同了
    //     const tpl = suffixMap.get('tpl') || [];
    //     modNames.push(...tpl);
    //     for (let f, i = modNames.length - 1; i >= 0; i--) {
    //         f = modNames[i].path;
    //         modNames[i] = f.endsWith('.tpl') ? f : f.slice(0, f.length - 3);
    //         if (commonjs.check(modNames[i]) !== true) {
    //             continue;
    //         }
    //         if (i < modNames.length - 1) {
    //             modNames[i] = modNames[modNames.length - 1];
    //         }
    //         modNames.length--;
    //     }
    //     // 获得包括依赖模块在内的等待加载的模块文件
    //     // tslint:disable:no-reserved-keywords
    //     const set = commonjs.depend(modNames);
    //     modNames.length = 0;
    //     // fileList 加上模块依赖的文件，合并下载
    //     for (let i = set.length - 1; i >= 0; i--) {
    //         const m = set[i];
    //         if (m.loaded || m.buildFunc) {
    //             continue;
    //         }
    //         fileList.push(m.info);
    //         modNames.push(m.id);
    //     }
    //     return modNames;
    // };
    // /**
    //  * @description 加载并注册指定目录及子目录下的所有模块、组件和资源（图片、声音、字体……）
    //  * 次序是按照目录逐层加载，目录按序深度遍历加载
    //  * 精确下载，如果目录含匹配定义文件，如果和当前标签不匹配，则该目录及子目录不下载和加载。
    //  * 先加载所有的模块及其依赖模块，然后加载所有的组件，最后执行所有模块内的loadDirCompleted方法。
    //  * 前端的三种兼容（compat）： 
    //  *  1、模块（B模块修饰A模块） 
    //  *  2、组件（B组件修饰A组件） 
    //  *  3、资源（文字-构建系统预处理 css图片及字体-构建系统预处理），统一通过loadDirCompleted方法来处理兼容问题。这样可以支持平台差异，包括系统平台差异和渠道平台差异。
    //  * 
    //  * 组件可以是<组件名>.widget，也可以是<组件名>.wcss, <组件名>.tpl, <组件名>.js，如果有tpl就算一个组件，会默认同名的css和js构成组件，如果js模块内导出了一个forelet，则认为是这个组件的forelet。
    //  * .widget、*.wcss、*.js可以引用到dirs以外的文件，该文件又可能引用新的文件，会需要多次碎片加载，所以都不支持引用外部目录的文件。
    //  * @example
    //  */
    // // tslint:disable-next-line:max-line-length
    // export const loadDir = (dirs: string[], flags: Json, resultMap: any, suffixCfg: any, successCallback: Function, errorCallback: Function, processCallback?: Function, withOut?: Function, slowLength = -1): Json => {
    //     const fileList = [];
    //     const suffixMap = new Map();
    //     listDirFile(dirs, flags, fileList, suffixMap, resultMap, suffixCfg, withOut);
    //     const modNames = fileDepends(suffixMap, fileList);
    //     processCallback && processCallback({
    //         type: 'requireStart',
    //         modAmout: modNames.length,
    //         tplAmout: suffixMap.has('tpl') ? suffixMap.get('tpl').length : 0
    //     });
    //     const down = load.create(fileList, (fileMap) => {
    //         // 加载所有的模块
    //         // tslint:disable:non-literal-require
    //         commonjs.require(modNames, fileMap, (mods) => {
    //             if (scriptTpl) {
    //                 if (slowLength > 0) {
    //                     suffixMap.forEach((v, i) => {
    //                         const arr = slowWait.suffixMap.get(i);
    //                         if (arr) {
    //                             slowWait.suffixMap.set(i, arr.concat(v));
    //                         } else {
    //                             slowWait.suffixMap.set(i, v);
    //                         }
    //                     });
    //                     for (const k in fileMap) {
    //                         slowWait.fileMap[k] = fileMap[k];
    //                     }
    //                     successCallback && successCallback();
    //                 } else if (slowLength === 0) {
    //                     loadNext(slowWait.suffixMap, slowWait.fileMap, [], successCallback, processCallback, true);
    //                 } else {
    //                     loadNext(suffixMap, fileMap, mods, successCallback, processCallback);
    //                 }
    //             } else {
    //                 loadNext(suffixMap, fileMap, mods, successCallback, processCallback);
    //             }
    //         }, errorCallback, processCallback);
    //     }, errorCallback, processCallback);
    //     down.fileTab = resultMap || {};
    //     load.start(down);
    //     return down;
    // };
    /**
     * @description 加载全局css，并自动加载css上的图片和字体，并加载fileMap的BlobURL资源
     * @example
     */
    exports.loadCssRes = (fileMap, callback) => {
        // 从fileMap中，提前将全部的BlobURL资源载入资源管理器上
        const tab = new res_mgr_1.ResTab();
        const cssArr = [];
        const rcssArr = [];
        for (const k in fileMap) {
            const type = depend_1.fileSuffix(k);
            // if (BlobType[type]) {
            //     // tslint:disable:prefer-template
            //     tab.load(RES_TYPE_BLOB + ':' + (type === 'webp' ? getWebpSrc(k) : k), RES_TYPE_BLOB, k, fileMap);
            // } else if (type === 'css') {
            //     cssArr.push(k);
            // } else if (type === 'rcss') {
            //     rcssArr.push(k);
            // }
            if (type === 'css') {
                cssArr.push(k);
            }
            else if (type === 'rcss') {
                rcssArr.push(k);
            }
        }
        // 加载不包含资源的全局样式和应用全局样式，应该是完全的兼容样式
        for (const k of cssArr) {
            loadCss(fileMap[k]);
        }
        // 加载包含资源的全局样式和应用全局样式，并自动加载css上的资源，应该是完全的兼容样式
        let count = 1;
        const cb = (s) => {
            s && html_1.addCssNode(s);
            count--;
            count === 0 && callback && callback();
        };
        for (const k of rcssArr) {
            count++;
            replaceURL(util_1.utf8Decode(fileMap[k]), k, fileMap, cb);
        }
        cb('');
        return tab;
    };
    /**
     * @description 设置tpl模板加载函数
     * @example
     */
    exports.setTplFun = (func) => {
        tplFun = func;
    };
    // ============================== 本地
    // 排除前缀
    const exclude = '.exclude.';
    // 标签匹配的正则表达式
    // tslint:disable:variable-name
    const var_reg = /^\$([a-zA-Z0-9\.\_]+)\s*/;
    const str_reg = /^([a-zA-Z][a-zA-Z0-9\.\_]*)\s*/;
    const number_reg = /^([0-9\.]+)\s*/;
    // 样式中匹配URL的正则表达式，不匹配含有:的字符串，所以如果是http:或https:，则不替换
    const CSS_URL = /url\(([^\)"':]*)\)/g;
    // 默认的后缀配置处理, "downonly"表示仅下载，如果本地有则不加载， "none"表示不下载不加载
    const suffix_cfg = {
        png: 'downonly', jpg: 'downonly', jpeg: 'downonly',
        webp: 'downonly', gif: 'downonly', svg: 'downonly', mp3: 'downonly', ogg: 'downonly', aac: 'downonly', gltf: 'none', bin: 'none'
    };
    // tpl模板加载函数
    let tplFun = (tplStr, filename) => {
        return { value: tpl_1.toFun(tplStr, filename), path: filename, wpath: null };
    };
    /**
     * @description 获得webp文件的源文件
     * @example
     */
    const getWebpSrc = (path) => {
        const s = path.slice(0, path.length - 5);
        let s1 = s + '.png';
        if (depend_1.getFile(s1)) {
            return s1;
        }
        s1 = s + '.jpg';
        if (depend_1.getFile(s1)) {
            return s1;
        }
        s1 = s + '.jpeg';
        if (depend_1.getFile(s1)) {
            return s1;
        }
        return path;
    };
    /**
     * @description 寻找父目录的文件信息
     * @example
     */
    const getParentInfo = (path) => {
        const i = path.lastIndexOf('/');
        return (i > 0) ? depend_1.getFile(path.slice(0, i + 1)).path : undefined;
    };
    /**
     * @description 寻找父目录下的排除文件
     * @example
     */
    const findExclude = (parent, flags, suffixCfg, cache) => {
        let scfg;
        while (parent) {
            let c = cache[parent.path];
            if (c === undefined) {
                const children = parent.children;
                for (const name in children) {
                    if (!children.hasOwnProperty(name)) {
                        continue;
                    }
                    if (children[name].children) {
                        continue;
                    }
                    if (!name.startsWith(exclude)) {
                        continue;
                    }
                    const i = name.indexOf('.', exclude.length);
                    if (!exports.flagMatch(name.slice(i + 1), flags)) {
                        continue;
                    }
                    const suf = name.slice(exclude.length, i);
                    if (!suf) {
                        continue;
                    }
                    if (!c) {
                        c = {};
                    }
                    c[suf] = 'none';
                }
                cache[parent.path] = c || null;
            }
            if (c) {
                if (!scfg) {
                    scfg = Object.assign({}, suffixCfg);
                }
                Object.assign(scfg, c);
            }
            parent = getParentInfo(parent.path);
        }
        return scfg || suffixCfg;
    };
    // /**
    //  * @description 列出文件
    //  * @example
    //  */
    // // tslint:disable-next-line:max-line-length
    // const listFile = (info: Json, flags: Json, fileList: string[], suffixMap: Map<string, any[]>, resultMap: any, suffixCfg: any, withOut: Function): void => {
    //     const path = info.path;
    //     if (withOut && withOut(path)) {
    //         // console.log(`not load ${path}`);
    //         return ;
    //     }
    //     // if (path.endsWith('.dcss')) {
    //     //     return ;
    //     // }
    //     // if (path.endsWith('.kcss')) {
    //     //     return ;
    //     // }
    //     if (path.endsWith('.wcss')) {
    //         return ;
    //     }
    //     if (path.endsWith('.widget') || path.endsWith('.cfg')) {
    //         return ;
    //     }
    //     if (resultMap[path]) {
    //         return;
    //     }
    //     const suffix = fileSuffix(path);
    //     const suffix1 = fileSuffix1(path);
    //     const type = suffixCfg[suffix];
    //     const type1 = suffixCfg[suffix1];
    //     if (type === 'none' || type1 === 'none') {
    //         return;
    //     }
    //     if (type === 'downonly' || type1 === 'downonly') {
    //         if (load.isLocal(path)) {
    //             return;
    //         }
    //     }
    //     fileList && fileList.push(info);
    //     if (!suffixMap) {
    //         return;
    //     }
    //     let arr = suffixMap.get(suffix);
    //     if (!arr) {
    //         arr = [];
    //         suffixMap.set(suffix, arr);
    //     }
    //     arr.push(info);
    // };
    /**
     * @description 用BlobURL方式加载css
     * @example
     */
    const loadCss = (data) => {
        const url = URL.createObjectURL(new Blob([data], { type: 'text/css' }));
        return html_1.loadCssNode(url, () => {
            URL.revokeObjectURL(url);
        });
    };
    // /**
    //  * @description 替换样式字符串中的url，并增加资源的引用计数
    //  * @example
    //  */
    // const replaceURL = (css: string, path: string, fileMap, callback: Function) => {
    //     const tab = new ResTab();
    //     let count = 1;
    //     const cb = () => {
    //         count--;
    //         count === 0 && callback(css.replace(CSS_URL, (str: string, s: string) => {
    //             s = relativePath(s, path);
    //             const res = tab.get(RES_TYPE_BLOB + ':' + s);
    //             if (!res) {
    //                 return '';
    //             }
    //             res.use();
    //             return 'url(' + res.link + ')';
    //         }));
    //     };
    //     css.replace(CSS_URL, (str: string, s: string) => {
    //         count++;
    //         s = relativePath(s, path);
    //         tab.load(RES_TYPE_BLOB + ':' + s, RES_TYPE_BLOB, s, fileMap, cb, cb);
    //         return '';
    //     });
    //     cb();
    // };
    /**
     * @description 替换样式字符串中的url，并增加资源的引用计数
     * @example
     */
    const replaceURL = (css, path, fileMap, callback) => {
        const tab = new res_mgr_1.ResTab();
        let count = 1;
        const cb = () => {
            count--;
            count === 0 && callback(css.replace(CSS_URL, (str, s) => {
                s = depend_1.relativePath(s, path);
                const res = tab.get(s, false);
                if (!res) {
                    return '';
                }
                res.use();
                return 'url(' + res.link + ')';
            }));
        };
        css.replace(CSS_URL, (str, s) => {
            count++;
            s = depend_1.relativePath(s, path);
            tab.load("", s, fileMap, false).then(() => {
                cb();
            });
            return '';
        });
        cb();
    };
    // /**
    //  * @description 目录加载的下一步，分析和创建*.tpl和*.widget对应的组件，执行脚本
    //  * @example
    //  */
    // // tslint:disable-next-line:max-line-length
    // const loadNext = (suffixMap: Map<string, any[]>, mods: Mod[], successCallback?: Function, processCallback?: Function, isSlow = false): void => {
    //     task(() => {
    //         if (isSlow) {
    //             autoRegisterWidget(fileMap, suffixMap);
    //             successCallback && successCallback();
    //             slowWait.suffixMap.clear();
    //             slowWait.fileMap = {};
    //         } else {
    //             processCallback && processCallback({ type: 'loadDirCompleted' });
    //             for (const m of mods) {
    //                 loadDirCompleted(m, fileMap);
    //             }
    //             autoRegisterWidget(fileMap, suffixMap);
    //             successCallback && successCallback(fileMap, mods);
    //         }
    //     }, undefined, 3000000, 1);
    // };
    /**
     * @description 调用模块的loadDirCompleted方法
     * @example
     */
    const loadDirCompleted = (mod, fileMap) => {
        const func = mod && mod.loadDirCompleted;
        func && func(fileMap);
    };
    /**
     * @description 标签匹配， 判断模式字符串，是否和标签匹配，标签可以多级
     * @example
     * not($b1) or($b1,$b2) and(or($b1=c1,$b2!=c2), not($b3)) ($b2)
     * 	$b1、$b2表示flag是否含有此键， $b2!=c2表示flag的b2键的值要不等于c2
     */
    exports.parseMatch = (pattern, flags) => {
        let s = pattern.str;
        if (s.startsWith('and(')) {
            pattern.str = s.slice(4).trim();
            return parseAnd(pattern, flags);
        }
        if (s.startsWith('or(')) {
            pattern.str = s.slice(3).trim();
            return parseOr(pattern, flags);
        }
        if (s.startsWith('not(')) {
            pattern.str = s.slice(4).trim();
            return parseNot(pattern, flags);
        }
        if (s.startsWith('(')) {
            pattern.str = s.slice(1).trim();
            const r = exports.parseMatch(pattern, flags);
            s = pattern.str;
            if (s.charCodeAt(0) !== 41) { // ")"
                throw new Error('parse error, invalid pattern:' + pattern.str);
            }
            return r;
        }
        return parseEqual(pattern, flags);
    };
    /**
     * @description 分析not， ")"结束
     * @example
     */
    const parseNot = (pattern, flags) => {
        const r = exports.parseMatch(pattern, flags);
        const s = pattern.str;
        if (s.charCodeAt(0) !== 41) { // ")"
            throw new Error('parse error, invalid pattern:' + pattern.str);
        }
        pattern.str = s.slice(1).trim();
        return !r;
    };
    /**
     * @description 分析or， ","分隔， ")"结束
     * @example
     */
    const parseOr = (pattern, flags) => {
        let rr = false;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            const r = exports.parseMatch(pattern, flags);
            const s = pattern.str;
            if (s.charCodeAt(0) === 44) { // ","
                pattern.str = s.slice(1).trim();
            }
            else if (s.charCodeAt(0) === 41) { // ")"
                pattern.str = s.slice(1).trim();
                return rr || r;
            }
            else {
                throw new Error('parse error, invalid pattern:' + pattern.str);
            }
            rr = rr || r;
        }
    };
    /**
     * @description 分析and， ","分隔， ")"结束
     * @example
     */
    const parseAnd = (pattern, flags) => {
        let rr = true;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            const r = exports.parseMatch(pattern, flags);
            const s = pattern.str;
            if (s.charCodeAt(0) === 44) { // ","
                pattern.str = s.slice(1).trim();
            }
            else if (s.charCodeAt(0) === 41) { // ")"
                pattern.str = s.slice(1).trim();
                return rr && r;
            }
            else {
                throw new Error('parse error, invalid pattern:' + pattern.str);
            }
            rr = rr && r;
        }
    };
    /**
     * @description 分析变量， 判断 = != 3种情况
     * @example
     */
    const parseEqual = (pattern, flags) => {
        const v1 = parseValue(pattern, flags);
        const s = pattern.str;
        if (s.charCodeAt(0) === 41) { // ")"
            return v1 !== false && v1 !== undefined;
        }
        if (s.charCodeAt(0) === 44) { // ","
            return v1 !== false && v1 !== undefined;
        }
        if (s.charCodeAt(0) === 61) { // "="
            pattern.str = s.slice(1).trim();
            const v2 = parseValue(pattern, flags);
            return v1 === v2;
        }
        if (s.charCodeAt(0) === 33 && s.charCodeAt(1) === 61) { // "!="
            pattern.str = s.slice(2).trim();
            const v2 = parseValue(pattern, flags);
            return v1 !== v2;
        }
        throw new Error('parse error, invalid pattern:' + pattern.str);
    };
    /**
     * @description 分析值，要么是变量，要么是字面量
     * @example
     */
    const parseValue = (pattern, flags) => {
        const s = pattern.str;
        if (s.charCodeAt(0) === 36) { // "$"
            const arr = var_reg.exec(s);
            if (!arr) {
                throw new Error('parse error, invalid pattern:' + pattern.str);
            }
            pattern.str = s.slice(arr[0].length);
            return util_1.getValue(flags, arr[1]);
        }
        let arr = str_reg.exec(s);
        if (arr) {
            pattern.str = s.slice(arr[0].length);
            return arr[1];
        }
        arr = number_reg.exec(s);
        if (!arr) {
            throw new Error('parse error, invalid pattern:' + pattern.str);
        }
        pattern.str = s.slice(arr[0].length);
        return parseFloat(arr[1]);
    };
    const fileSuffix1 = (file) => {
        const i = file.indexOf('.');
        if (i === -1) {
            return '';
        }
        return file.slice(i, file.length);
    };
    var WidgetForelet;
    (function (WidgetForelet) {
        WidgetForelet[WidgetForelet["WIDGET"] = 1] = "WIDGET";
        WidgetForelet[WidgetForelet["FORELET"] = 2] = "FORELET";
    })(WidgetForelet || (WidgetForelet = {}));
    const getWidgetOfForelet = (config, name, type) => {
        return new Promise((resolve, _reject) => {
            let path;
            if (type === WidgetForelet.WIDGET) {
                if (!config.widget && !config.js) {
                    resolve(null);
                    return;
                }
                path = config.widget || config.js;
            }
            if (type === WidgetForelet.FORELET) {
                if (!config.forelet) {
                    resolve(null);
                    return;
                }
                path = config.forelet;
            }
            path = depend_1.relativePath(path, name.replace(/-/g, '/')).replace(/\.[jt]s$/, '');
            new Promise((resolve_1, reject_1) => { require([path], resolve_1, reject_1); }).then((mod) => {
                if (!mod.exports) {
                    mod = { exports: mod };
                }
                if (type === WidgetForelet.WIDGET) {
                    resolve(util_1.getExportFunc(mod, util_1.checkType, widget_1.Widget)());
                }
                else if (type === WidgetForelet.FORELET) {
                    resolve(util_1.getExportFunc(mod, util_1.checkInstance, forelet_1.Forelet));
                }
            });
        });
    };
    const getTpl = (config, name) => {
        return new Promise((resolve, _reject) => {
            let tplPath = config.tpl;
            tplPath = depend_1.relativePath(tplPath, name);
            new Promise((resolve_2, reject_2) => { require([tplPath], resolve_2, reject_2); }).then((tplFunc) => {
                let tpl = widget_1.getCache(tplPath);
                if (!tpl) {
                    // if (!tplFunc) { return; }
                    tpl = { value: tplFunc.tpl, path: tplPath, wpath: null };
                    widget_1.setCache(tplPath, tpl);
                }
                else if (!tpl.value) {
                    tpl.value = tplFunc.tpl;
                }
                resolve(tpl);
            });
        });
    };
    var CFGWCSS;
    (function (CFGWCSS) {
        CFGWCSS["CFG"] = "cfg";
        CFGWCSS["WCSS"] = "wcss";
    })(CFGWCSS || (CFGWCSS = {}));
    const KCSS = "kcss";
    const WIDGET_CFG = "widcfg";
    const DCSS = "dcss";
    let kcss_catch = new Map();
    let widcfg_catch = new Map();
    const getJsonData = (config, widgetPath, type, files) => {
        const cfg = type === CFGWCSS.CFG ? config.cfg : config.css;
        if (!cfg) {
            return;
        }
        if (Array.isArray(cfg)) {
            let c;
            for (const f of cfg) {
                let config = type === CFGWCSS.CFG ?
                    getCfgItem(f, widgetPath, files) :
                    getWcssItem(f, widgetPath, files);
                if (!config || !config.value) {
                    continue;
                }
                config = config.value;
                if (!c) {
                    c = {};
                }
                for (const k in config) {
                    c[k] = config[k];
                }
            }
            return c ? { value: c } : null;
        }
        else {
            return type === CFGWCSS.CFG ?
                getCfgItem(cfg, widgetPath, files) :
                getWcssItem(cfg, widgetPath, files);
        }
    };
    const getWcssItem = (css, path, combinJson) => {
        const wcssPath = depend_1.relativePath(css, path);
        let wcss = widget_1.getCache(wcssPath);
        if (!wcss || !wcss.value) {
            !wcss && (wcss = {});
            let json;
            if (combinJson) {
                json = combinJson[wcssPath];
            }
            if (!json) {
                return;
            }
            const { anim, clazz } = json;
            if (clazz) {
                Object.keys(clazz || {}).forEach((key) => {
                    wcss[key] = new virtual_style_1.VirtualStyle(clazz[key]);
                });
            }
            if (anim) {
                wcss.keyframes = anim;
            }
            wcss = { value: wcss };
            widget_1.setCache(wcssPath, wcss);
        }
        return wcss;
    };
    const getCfgItem = (cfg, path, combinJson) => {
        const cfgPath = depend_1.relativePath(cfg, path);
        let config = widget_1.getCache(cfgPath);
        if (!config || !config.value) {
            let json;
            if (combinJson) {
                json = combinJson[cfgPath];
            }
            if (!json) {
                return;
            }
            config = { value: json };
            widget_1.setCache(cfgPath, config);
        }
        return config;
    };
    // ##########################################################
    // ============================== 立即执行
    // const isMiniGame = !!load.isWXMiniGame();
    const isMiniGame = false;
    exports.registerHandler = () => {
        // export const autoRegisterWidget = (fileMap: Json, sufMap: Map<string, Json[]>, processCb?:Function) => {
        //     const cssList = sufMap.get('dcss');
        //     if (cssList && cssList.length > 0) { 
        //         cssList.forEach((css: any) => {
        //             RDocument.dcssRegist(new Uint8Array(fileMap[css.path]));
        //         });
        //     }
        app_1.setCfgHandler(DCSS, (_file, data) => {
            return new Promise((resolve, _reject) => {
                r_document_1.RDocument.dcssRegist(data);
                resolve(null);
            });
        });
        app_1.setCfgHandler(WIDGET_CFG, (file, data) => {
            return new Promise((resolve, _reject) => {
                const widcfgJson = JSON.parse(util_1.utf8Decode(data));
                let kcssPath = file.replace('.widcfg', '.kcss');
                let kcssJson;
                if (depend_1.getFile(kcssPath)) {
                    kcssJson = kcss_catch.get(kcssPath); // 从缓存中取到kcss
                    if (kcssJson) {
                        kcss_catch.delete(kcssPath);
                    }
                    widcfg_catch.set(file, widcfgJson);
                }
                for (const filename in widcfgJson) {
                    if (!widcfgJson.hasOwnProperty(filename) || !filename.endsWith('.widget')) {
                        continue;
                    }
                    let w_path = filename.replace(/\.widget$/, '');
                    const w_name = w_path.replace(/\//g, '-');
                    const lastPath = w_path.lastIndexOf('/');
                    w_path = w_path.substring(0, lastPath + 1);
                    let w = widget_1.or_register(w_name);
                    w.config = getJsonData(widcfgJson[filename], w_path, CFGWCSS.CFG, widcfgJson);
                    if (kcssJson) {
                        w.sheet = getJsonData(widcfgJson[filename], w_path, CFGWCSS.WCSS, kcssJson);
                    }
                    let t = getTpl(widcfgJson[filename], w_path).then((tpl) => {
                        w.tpl = tpl;
                    });
                    let wi = getWidgetOfForelet(widcfgJson[filename], w_name, WidgetForelet.WIDGET).then((widget) => {
                        if (widget) {
                            w.widget = () => new widget();
                        }
                        else {
                            w.widget = () => new widget_1.Widget();
                        }
                    });
                    let f = getWidgetOfForelet(widcfgJson[filename], w_name, WidgetForelet.FORELET).then((forelet) => {
                        w.forelet = forelet;
                    });
                    w.widcfg = widcfgJson[filename];
                    w.wPath = w_path;
                    // widcfg处理完成，通知
                    Promise.all([t, wi, f]).then((r) => {
                        resolve(null);
                    });
                }
            });
        });
        app_1.setCfgHandler(KCSS, (file, data) => {
            return new Promise((resolve, _reject) => {
                const kcssJson = JSON.parse(util_1.utf8Decode(data));
                let widcfgPath = file.replace('.kcss', '.widcfg');
                let widcfgJson = widcfg_catch.get(widcfgPath);
                if (widcfgJson) {
                    for (const filename in widcfgJson) {
                        if (!widcfgJson.hasOwnProperty(filename) || !filename.endsWith('.widget')) {
                            continue;
                        }
                        let w_path = filename.replace(/\.widget$/, '');
                        const w_name = w_path.replace(/\//g, '-');
                        const lastPath = w_path.lastIndexOf('/');
                        w_path = w_path.substring(0, lastPath + 1);
                        let w = widget_1.or_register(w_name);
                        w.sheet = getJsonData(widcfgJson[filename], w_path, CFGWCSS.WCSS, kcssJson);
                    }
                    widcfg_catch.delete(widcfgPath);
                }
                else {
                    kcss_catch.set(file, kcssJson);
                }
                resolve(null);
            });
        });
    };
});

/*
 * 用户登陆注册
 */
_$pi.define("pi_gui/gui/main", ["require", "exports", "./gui_virtual/util", "../widget/forelet", "./combine_image/combine"], function (require, exports, util_1, forelet_1, combine_1) {
    "use strict";
    
    // import { test1000 } from '../demo1000/demo1000';
    // import { initDefaultStyle } from './default_style';
    // import { GUIInstance } from './gui';
    // import { loadFonts } from './loadfont';
    // import { addFontCanvas } from './loadfont_canvas';
    /**
     * 导出forelet
     */
    exports.forelet = new forelet_1.Forelet();
    /***
     * 初始化
     */
    exports.main = () => {
        util_1.registerHandler();
        combine_1.initCombineImageCfg();
        // const canvas = document.createElement("canvas");
        // if (RDocument.MainDocumentUniqueID === undefined) {
        // 	let engine = RDocument.createMainEngine(canvas);
        // 	// 销毁gui， TODO
        // }
        // const l: number = 0 , t: number = 0, w: number = 960 , h: number = 540;
        // canvas.width    = w;
        // canvas.height   = h;
        // canvas.style.left   = `${l}px`;
        // canvas.style.top    = `${t}px`;
        // initGUI(canvas, undefined, { left: l, top: t, width: w, height: h, clearColor: '#00000000' });
        // loadFonts(
        //     'font/sarasa-gothic-sc-italic/',
        //     [
        //         {
        //             name: 'kaijian',
        //             src: 'font/kaijian/frequency.png',
        //             bin: 'font/kaijian/frequency.json.bin'
        //         }
        //     ],
        //     () => {
        // initDefaultStyle(vdocumnet);
        // init();
        // setTimeout(() => {
        // (<any>window).test04();
        // setTimeout(() => {
        // (<any>window).test52();
        // test1000();
        // }, 10000);
        //         }, 20000);
        //     }
        // );
    };
});
// const init_gui = (canvas: HTMLCanvasElement) => {
//     // ################################################# gui 初始化
//     const guiInstance = new GUIInstance(canvas);
//     GUIInstance.mainInstance = guiInstance;
//     // ################################################# 事件处理
//     FormatEvent.format(canvas);
//     FormatEvent.addDownListener(guiInstance.vdocument.downFire);
//     FormatEvent.addUpListener(guiInstance.vdocument.upFire);
//     FormatEvent.addMoveListener(guiInstance.vdocument.moveFire);
//     FormatEvent.addWheelListener(guiInstance.vdocument.wheelFire);
//     // ################################################# gui debug
//     Tools.logFlag = false;
//     Tools.warnFlag = false;
//     Tools.errorFlag = false;
//     Tools.isDev = false;
//     (<any>window).Inspector = Inspector;
//     addFontCanvas('kaiti', 'normal', 28, 30, guiInstance.vdocument.uniqueID);
//     return guiInstance.vdocument;
// };
// /**
//  * 屏幕适配
//  * @param CANVAS : canvas 需包装在一个DIV内，div 放bady下，canvas , div 均绝对定位
//  */
// const format_gui_display = (canvas: HTMLCanvasElement) => {
//     FormatCanvasDisplay.addResizeListener(resizeCall);
//     BeforeInitTools.Design_Height   = 750;
//     BeforeInitTools.Design_Width    = 1334;
//     FormatCanvasDisplay.format(canvas);
// };
// const resizeCall = () => {
//     let l: number , t: number, w: number, h: number;
//     l = FormatCanvasDisplay.getContentDisplayLeft();
//     t = FormatCanvasDisplay.getContentDisplayTop();
//     w = FormatCanvasDisplay.getContentDisplayWidth();
//     h = FormatCanvasDisplay.getContentDisplayHeight();
//     resetSize(l, t, w, h);
// };

_$pi.define("pi_gui/widget/resize/resize", ["require", "exports"], function (require, exports) {
    "use strict";
    
    exports.resize = (option, cb) => {
        let canvas = document.createElement('canvas');
        let context = canvas.getContext('2d');
        let img = new Image();
        img.crossOrigin = '';
        img.onload = function () {
            let scale = (img.width < img.height) ? (option.width / img.width) : (option.width / img.height);
            scale = (scale < 1) ? scale : 1;
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            context.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
            let base64 = null;
            if (option.type == "jpeg") {
                base64 = canvas.toDataURL("image/" + option.type, option.ratio || 0.92);
            }
            else {
                base64 = canvas.toDataURL("image/" + option.type);
            }
            let mimeString = base64.split(',')[0].split(':')[1].split(';')[0]; // mime类型
            let byteString = atob(base64.split(',')[1]); //base64 解码
            let arrayBuffer = new ArrayBuffer(byteString.length); //创建缓冲数组
            let intArray = new Uint8Array(arrayBuffer); //创建视图
            for (let i = 0; i < byteString.length; i += 1) {
                intArray[i] = byteString.charCodeAt(i);
            }
            if (cb)
                cb({ base64, ab: arrayBuffer });
        };
        img.src = option.url;
    };
});

/**
 * 一些dom相关的函数
 */
_$pi.define("pi_gui/widget/scroller/dom", ["require", "exports"], function (require, exports) {
    "use strict";
    
    // ============================================= 执行
    const TOUCH_EVENT = 1;
    const MOUSE_EVENT = 2;
    const elementStyle = document.createElement('div').style;
    const vendor = (() => {
        const transformNames = {
            webkit: 'webkitTransform',
            Moz: 'MozTransform',
            O: 'OTransform',
            ms: 'msTransform',
            standard: 'transform'
        };
        for (const key in transformNames) {
            if (elementStyle[transformNames[key]] !== undefined) {
                return key;
            }
        }
        return false;
    })();
    const prefixStyle = (style) => {
        if (vendor === false) {
            return false;
        }
        if (vendor === 'standard') {
            return style;
        }
        return vendor + style.charAt(0).toUpperCase() + style.substr(1);
    };
    const transform = prefixStyle('transform');
    // ============================================= 导出
    exports.addEvent = (el, eventType, fn, capture) => {
        el.addEventListener(eventType, fn, { passive: false, capture: !!capture });
    };
    exports.removeEvent = (el, eventType, fn, capture) => {
        el.removeEventListener(eventType, fn, !!capture);
    };
    exports.offset = (el) => {
        let left = 0;
        let top = 0;
        while (el) {
            left -= el.offsetLeft;
            top -= el.offsetTop;
            el = el.offsetParent;
        }
        return {
            left,
            top
        };
    };
    exports.hasPerspective = prefixStyle('perspective') in elementStyle;
    exports.hasTouch = 'ontouchstart' in window;
    exports.hasTransform = transform !== false;
    exports.hasTransition = prefixStyle('transition') in elementStyle;
    exports.style = {
        transform,
        transitionTimingFunction: prefixStyle('transitionTimingFunction'),
        transitionDuration: prefixStyle('transitionDuration'),
        transitionDelay: prefixStyle('transitionDelay'),
        transformOrigin: prefixStyle('transformOrigin'),
        transitionEnd: prefixStyle('transitionEnd')
    };
    exports.eventType = {
        touchstart: TOUCH_EVENT,
        touchmove: TOUCH_EVENT,
        touchend: TOUCH_EVENT,
        mousedown: MOUSE_EVENT,
        mousemove: MOUSE_EVENT,
        mouseup: MOUSE_EVENT
    };
    exports.getRect = (el) => {
        if (el instanceof window.SVGElement) {
            const rect = el.getBoundingClientRect();
            return {
                top: rect.top,
                left: rect.left,
                width: rect.width,
                height: rect.height
            };
        }
        else {
            return {
                top: el.offsetTop,
                left: el.offsetLeft,
                width: el.offsetWidth,
                height: el.offsetHeight
            };
        }
    };
    exports.preventDefaultException = (el, exceptions) => {
        for (const i in exceptions) {
            if (exceptions[i].test(el[i])) {
                return true;
            }
        }
        return false;
    };
    exports.tap = (e, eventName) => {
        const ev = document.createEvent('Event');
        ev.initEvent(eventName, true, true);
        ev.pageX = e.pageX;
        ev.pageY = e.pageY;
        e.target.dispatchEvent(ev);
    };
    exports.click = (e) => {
        const target = e.target;
        if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {
            const ev = document.createEvent(window.MouseEvent ? 'MouseEvents' : 'Event');
            ev.initEvent('click', true, true);
            ev._constructed = true;
            target.dispatchEvent(ev);
        }
    };
    exports.prepend = (el, target) => {
        if (target.firstChild) {
            exports.before(el, target.firstChild);
        }
        else {
            target.appendChild(el);
        }
    };
    exports.before = (el, target) => {
        target.parentNode.insertBefore(el, target);
    };
});
// ============================================= 本地

_$pi.define("pi_gui/widget/scroller/ease", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 缓动函数
     */
    // ======================================================== 导出
    exports.ease = {
        // easeOutQuint
        swipe: {
            style: 'cubic-bezier(0.23, 1, 0.32, 1)',
            fn: (t) => {
                return (--t * t * t * t * t) + 1;
            }
        },
        // easeOutQuard
        swipeBounce: {
            style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
            fn: (t) => {
                return t * (2 - t);
            }
        },
        // easeOutQuart
        bounce: {
            style: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
            fn: (t) => {
                return 1 - (--t * t * t * t);
            }
        }
    };
});

_$pi.define("pi_gui/widget/scroller/util", ["require", "exports"], function (require, exports) {
    "use strict";
    
    /**
     * 存放了scroller的util函数
     */
    // ======================================================== 导出
    /**
     * 是否具有冲量,就是手指松开之后再滑动一段
     */
    exports.momentum = (current, start, time, lowerMargin, wrapperSize, options) => {
        const distance = current - start;
        const speed = Math.abs(distance) / time;
        const { deceleration, itemHeight, swipeBounceTime, bounceTime } = options;
        let duration = options.swipeTime;
        const rate = 15;
        let destination = current + speed / deceleration * (distance < 0 ? -1 : 1);
        if (destination < lowerMargin) {
            destination = wrapperSize ? lowerMargin - (wrapperSize / rate * speed) : lowerMargin;
            duration = swipeBounceTime - bounceTime;
        }
        else if (destination > 0) {
            destination = wrapperSize ? wrapperSize / rate * speed : 0;
            duration = swipeBounceTime - bounceTime;
        }
        return {
            destination: Math.round(destination),
            duration
        };
    };
    // 属性扩展
    exports.extend = (target, source) => {
        for (const key in source) {
            target[key] = source[key];
        }
    };
    /**
     * 感觉这个判断没啥实际意义啊
     */
    exports.isBadAndroid = /Android /.test(window.navigator.appVersion) && !(/Chrome\/\d/.test(window.navigator.appVersion));
});

// /*
//  * 组件工具模块
//  */
_$pi.define("pi_gui/widget/util", ["require", "exports"], function (require, exports) {
    "use strict";
});
// // ============================== 导入
// // import { butil, commonjs, depend, load, Mod } from '../../pi_sys/modules/lang/mod';
// import { Json } from '../../pi_sys/modules/lang/type';
// import * as hash from '../../pi_sys/modules/util/hash';
// import { addCssNode, loadCssNode } from './html';
// import { cc, log} from '../../pi_sys/feature/log';
// import { BlobType, RES_TYPE_BLOB, ResTab } from '../../pi_sys/modules/util/res_mgr';
// import { set as task } from '../../pi_sys/modules/util/task_mgr';
// import { utf8Decode } from '../../pi_sys/modules/util/util';
// import { toFun, toFunComplete } from '../../pi_sys/modules/util/tpl';
// import { checkInstance, checkType, getExportFunc, getValue, mapCopy } from '../../pi_sys/modules/util/util';
// import { parse, Sheet } from '../widget/style';
// import { Forelet } from './forelet';
// import { paintCmd3 } from './painter';
// import { factory, getCache, register, setCache, Widget } from './widget';
// export let scriptTpl = true; // 通过script加载tpl
// const tplWait = []; // 脚本加载tpl队列
// /**
//  * @description 将指定名称的组件，加入到el元素的第一个元素前，会延迟到帧调用时添加
//  * @example
//  */
// export const addWidget = (el: HTMLElement, name: string, props?: Json): Widget => {
//     const w = factory(name);
//     if (!w) {
//         return;
//     }
//     if (props) {
//         w.setProps(props);
//     }
//     w.paint();
//     paintCmd3(el, 'appendChild', [w.tree.link]);
//     return w;
// };
// /**
//  * @description 标签匹配， 判断模式字符串，是否和标签匹配，标签可以多级
//  * @example
//  * not($b1) or($b1,$b2) and(or($b1=c1,$b2!=c2), not($b3)
//  * 	$b1、$b2表示flag是否含有此键， $b2!=c2表示flag的b2键的值要不等于c2
//  */
// export const flagMatch = (pattern: string, flags: Json): boolean => {
//     return parseMatch({ str: pattern.trim() }, flags);
// };
// /** .exclude.not(or(r))
//  * @description 列出目录及子目录下所有的文件，跳过重复文件
//  * 如果一个目录中含有 .exclude.<文件后缀>.<标签匹配语句> 文件，则表示该目录指定后缀（没有后缀表示所有文件）需要进行排除匹配，如果匹配成功，则该目录及子目录的指定后缀的文件被排除。
//  * @example
//  */
// export const listDir = (info: any, flags: Json, fileList: string[], suffixMap: Map<string, any[]>, resultMap: any, suffixCfg: any, withOut: Function): void => {
//     if (resultMap[info.path]) {
//         return;
//     }
//     let scfg;
//     const children = info.children;
//     const files = [];
//     const dirs = [];
//     for (const name in children) {
//         if (!children.hasOwnProperty(name)) {
//             continue;
//         }
//         const info = children[name];
//         if (info.children) {
//             dirs.push(info);
//             continue;
//         }
//         if (!name.startsWith(exclude)) {
//             files.push(info);
//             continue;
//         }
//         const i = name.indexOf('.', exclude.length);
//         if (!flagMatch(name.slice(i + 1), flags)) {
//             continue;
//         }
//         const suf = name.slice(exclude.length, i);
//         if (!suf) {
//             return;
//         }
//         if (!scfg) {
//             scfg = { ...suffixCfg };
//         }
//         scfg[suf] = 'none';
//     }
//     for (let i = files.length - 1; i > -1; i--) {
//         listFile(files[i], flags, fileList, suffixMap, resultMap, scfg || suffixCfg, withOut);
//     }
//     for (const d of dirs) {
//         listDir(d, flags, fileList, suffixMap, resultMap, scfg || suffixCfg, withOut);
//     }
// };
// export const listDirFile = (dirs: string[], flags: Json, fileList: any[], suffixMap: Map<string, any[]>, resultMap: any, suffixCfg: any, withOut: Function): void => {
//     const dirSuffixCfg = {};
//     resultMap = resultMap || {};
//     if (suffixCfg) {
//         for (const k in suffix_cfg) {
//             if (!suffixCfg[k]) {
//                 suffixCfg[k] = suffix_cfg[k];
//             }
//         }
//     } else {
//         suffixCfg = suffix_cfg;
//     }
//     for (const dir of dirs) {
//         const info = depend.get(dir);
//         if (!info) {
//             continue;
//         }
//         if (info.children) {
//             listDir(info, flags, fileList, suffixMap, resultMap, findExclude(getParentInfo(info.path), flags, suffixCfg, dirSuffixCfg), withOut);
//         } else {
//             listFile(info, flags, fileList, suffixMap, resultMap, suffixCfg, withOut);
//         }
//     }
//     // fileList 去除所有的模块文件
//     for (let f, i = fileList.length - 1; i >= 0; i--) {
//         f = fileList[i].path;
//         // 跳过后缀不为".js"的文件
//         if ((f.charCodeAt(f.length - 1) !== 115 || f.charCodeAt(f.length - 2) !== 106 || f.charCodeAt(f.length - 3) !== 46)) {
//             continue;
//         }
//         if (i < fileList.length - 1) {
//             fileList[i] = fileList[fileList.length - 1];
//         }
//         fileList.length--;
//     }
// }
// export const fileDepends = (suffixMap: Map<string, any[]>, fileList: any[]): string[] => {
//     // modNames 去除已经加载的模块文件
//     const modNames = suffixMap.get("js") || [];
//     for (let f, j, i = modNames.length - 1; i >= 0; i--) {
//         f = modNames[i].path;
//         modNames[i] = f.slice(0, f.length - 3);
//         if (commonjs.check(modNames[i]) !== true) {
//             continue;
//         }
//         if (i < modNames.length - 1) {
//             modNames[i] = modNames[modNames.length - 1];
//         }
//         modNames.length--;
//     }
//     // 获得包括依赖模块在内的等待加载的模块文件
//     // tslint:disable:no-reserved-keywords
//     const set = commonjs.depend(modNames);
//     modNames.length = 0;
//     // fileList 加上模块依赖的文件，合并下载
//     for (let i = set.length - 1; i >= 0; i--) {
//         const m = set[i];
//         if (m.loaded || m.buildFunc) {
//             continue;
//         }
//         fileList.push(m.info);
//         modNames.push(m.id);
//     }
//     return modNames;
// }
// /**
//  * @description 加载并注册指定目录及子目录下的所有模块、组件和资源（图片、声音、字体……）
//  * 次序是按照目录逐层加载，目录按序深度遍历加载
//  * 精确下载，如果目录含匹配定义文件，如果和当前标签不匹配，则该目录及子目录不下载和加载。
//  * 先加载所有的模块及其依赖模块，然后加载所有的组件，最后执行所有模块内的loadDirCompleted方法。
//  * 前端的三种兼容（compat）： 1、模块（B模块修饰A模块） 2、组件（B组件修饰A组件） 3、资源（文字-构建系统预处理 css图片及字体-构建系统预处理），统一通过loadDirCompleted方法来处理兼容问题。这样可以支持平台差异，包括系统平台差异和渠道平台差异。
//  * 
//  * 组件可以是<组件名>.widget，也可以是<组件名>.wcss, <组件名>.tpl, <组件名>.js，如果有tpl就算一个组件，会默认同名的css和js构成组件，如果js模块内导出了一个forelet，则认为是这个组件的forelet。
//  * .widget、*.wcss、*.js可以引用到dirs以外的文件，该文件又可能引用新的文件，会需要多次碎片加载，所以都不支持引用外部目录的文件。
//  * @example
//  */
// export const loadDir = (dirs: string[], flags: Json, resultMap: any, suffixCfg: any, successCallback: Function, errorCallback: Function, processCallback?: Function, withOut?: Function): Json => {
//     const fileList = [];
//     const suffixMap = new Map();
//     listDirFile(dirs, flags, fileList, suffixMap, resultMap, suffixCfg, withOut);
//     const modNames = fileDepends(suffixMap, fileList);
//     processCallback && processCallback({
//         type: 'requireStart',
//         modAmout: modNames.length,
//         tplAmout: suffixMap.has("tpl") ? suffixMap.get("tpl").length : 0
//     });
//     const down = load.create(fileList, (fileMap) => {
//         // 加载所有的模块
//         // tslint:disable:non-literal-require
//         commonjs.require(modNames, fileMap, (mods) => {
//             if (scriptTpl) {
//                 defineTpl(suffixMap, fileMap, () => {
//                     loadNext(suffixMap, fileMap, mods, successCallback, processCallback);
//                 }, processCallback)
//             }
//             else {
//                 loadNext(suffixMap, fileMap, mods, successCallback, processCallback);
//             }
//         }, errorCallback, processCallback);
//     }, errorCallback, processCallback);
//     down.fileTab = resultMap || {};
//     load.start(down);
//     return down;
// };
// /**
//  * @description 加载全局css，并自动加载css上的图片和字体，并加载fileMap的BlobURL资源
//  * @example
//  */
// export const loadCssRes = (fileMap, callback: Function): ResTab => {
//     // 从fileMap中，提前将全部的BlobURL资源载入资源管理器上
//     const tab = new ResTab();
//     const cssArr = [];
//     const rcssArr = [];
//     for (const k in fileMap) {
//         const type = butil.fileSuffix(k);
//         if (BlobType[type]) {
//             // tslint:disable:prefer-template
//             tab.load(RES_TYPE_BLOB + ':' + (type === 'webp' ? getWebpSrc(k) : k), RES_TYPE_BLOB, k, fileMap);
//         } else if (type === 'css') {
//             cssArr.push(k);
//         } else if (type === 'rcss') {
//             rcssArr.push(k);
//         }
//     }
//     // 加载不包含资源的全局样式和应用全局样式，应该是完全的兼容样式
//     for (const k of cssArr) {
//         loadCss(fileMap[k]);
//     }
//     // 加载包含资源的全局样式和应用全局样式，并自动加载css上的资源，应该是完全的兼容样式
//     let count = 1;
//     const cb = (s: string) => {
//         s && addCssNode(s);
//         count--;
//         count === 0 && callback && callback();
//     };
//     for (const k of rcssArr) {
//         count++;
//         replaceURL(butil.utf8Decode(fileMap[k]), k, fileMap, cb);
//     }
//     cb('');
//     return tab;
// };
// /**
//  * @description 设置tpl模板加载函数
//  * @example
//  */
// export const setTplFun = (func: Function) => {
//     tplFun = func;
// };
// // ============================== 本地
// // 排除前缀
// const exclude = '.exclude.';
// // 标签匹配的正则表达式
// // tslint:disable:variable-name
// const var_reg = /^\$([a-zA-Z0-9\.\_]+)\s*/;
// const str_reg = /^([a-zA-Z][a-zA-Z0-9\.\_]*)\s*/;
// const number_reg = /^([0-9\.]+)\s*/;
// // 样式中匹配URL的正则表达式，不匹配含有:的字符串，所以如果是http:或https:，则不替换
// const CSS_URL = /url\(([^\)"':]*)\)/g;
// // 默认的后缀配置处理, "downonly"表示仅下载，如果本地有则不加载， "none"表示不下载不加载
// const suffix_cfg = {
//     png: 'downonly', jpg: 'downonly', jpeg: 'downonly',
//     webp: 'downonly', gif: 'downonly', svg: 'downonly', mp3: 'downonly', ogg: 'downonly', aac: 'downonly', gltf: 'none', bin: 'none'
// };
// // tpl模板加载函数
// let tplFun: Function = (tplStr, filename) => {
//     return { value: toFun(tplStr, filename), path: filename, wpath: null };
// };
// /**
//  * @description 获得webp文件的源文件
//  * @example
//  */
// const getWebpSrc = (path): string => {
//     const s = path.slice(0, path.length - 5);
//     let s1 = s + '.png';
//     if (depend.get(s1)) {
//         return s1;
//     }
//     s1 = s + '.jpg';
//     if (depend.get(s1)) {
//         return s1;
//     }
//     s1 = s + '.jpeg';
//     if (depend.get(s1)) {
//         return s1;
//     }
//     return path;
// };
// /**
//  * @description 寻找父目录的文件信息
//  * @example
//  */
// const getParentInfo = (path): string => {
//     const i = path.lastIndexOf('/');
//     return (i > 0) ? depend.get(path.slice(0, i + 1)) : undefined;
// };
// /**
//  * @description 寻找父目录下的排除文件
//  * @example
//  */
// const findExclude = (parent: Json, flags: Json, suffixCfg: Json, cache: Json): Json => {
//     let scfg;
//     while (parent) {
//         let c = cache[parent.path];
//         if (c === undefined) {
//             const children = parent.children;
//             for (const name in children) {
//                 if (!children.hasOwnProperty(name)) {
//                     continue;
//                 }
//                 if (children[name].children) {
//                     continue;
//                 }
//                 if (!name.startsWith(exclude)) {
//                     continue;
//                 }
//                 const i = name.indexOf('.', exclude.length);
//                 if (!flagMatch(name.slice(i + 1), flags)) {
//                     continue;
//                 }
//                 const suf = name.slice(exclude.length, i);
//                 if (!suf) {
//                     continue;
//                 }
//                 if (!c) {
//                     c = {};
//                 }
//                 c[suf] = 'none';
//             }
//             cache[parent.path] = c || null;
//         }
//         if (c) {
//             if (!scfg) {
//                 scfg = { ...suffixCfg };
//             }
//             Object.assign(scfg, c);
//         }
//         parent = getParentInfo(parent.path);
//     }
//     return scfg || suffixCfg;
// };
// /**
//  * @description 列出文件
//  * @example
//  */
// const listFile = (info: Json, flags: Json, fileList: string[], suffixMap: Map<string, any[]>, resultMap: any, suffixCfg: any, withOut: Function): void => {
//     const path = info.path;
//     if (withOut && withOut(path)) {
//         return
//     }
//     if (resultMap[path]) {
//         return;
//     }
//     const suffix = butil.fileSuffix(path);
//     const suffix1 = fileSuffix1(path);
//     const type = suffixCfg[suffix];
//     const type1 = suffixCfg[suffix1];
//     if (type === 'none' || type1 === 'none') {
//         return;
//     }
//     if (type === 'downonly' || type1 === 'downonly') {
//         if (load.isLocal(path)) {
//             return;
//         }
//     }
//     fileList && fileList.push(info);
//     if (!suffixMap) {
//         return;
//     }
//     let arr = suffixMap.get(suffix);
//     if (!arr) {
//         arr = [];
//         suffixMap.set(suffix, arr);
//     }
//     arr.push(info);
// };
// /**
//  * @description 用BlobURL方式加载css
//  * @example
//  */
// const loadCss = (data: ArrayBuffer): HTMLStyleElement => {
//     const url = URL.createObjectURL(new Blob([data], { type: 'text/css' }));
//     return loadCssNode(url, () => {
//         URL.revokeObjectURL(url);
//     });
// };
// /**
//  * @description 替换样式字符串中的url，并增加资源的引用计数
//  * @example
//  */
// const replaceURL = (css: string, path: string, fileMap, callback: Function) => {
//     const tab = new ResTab();
//     let count = 1;
//     const cb = () => {
//         count--;
//         count === 0 && callback(css.replace(CSS_URL, (str: string, s: string) => {
//             s = butil.relativePath(s, path);
//             const res = tab.get(RES_TYPE_BLOB + ':' + s);
//             if (!res) {
//                 return '';
//             }
//             res.use();
//             return 'url(' + res.link + ')';
//         }));
//     };
//     css.replace(CSS_URL, (str: string, s: string) => {
//         count++;
//         s = butil.relativePath(s, path);
//         tab.load(RES_TYPE_BLOB + ':' + s, RES_TYPE_BLOB, s, fileMap, cb, cb);
//         return '';
//     });
//     cb();
// };
// /**
//  * @description 目录加载的下一步，分析和创建*.tpl和*.widget对应的组件，执行脚本
//  * @example
//  */
// const loadNext = (suffixMap: Map<string, any[]>, fileMap: Json, mods: Mod[], successCallback?: Function, processCallback?: Function): void => {
//     task(() => {
//         processCallback && processCallback({ type: 'loadTpl' });
//         const arr = suffixMap.get("tpl") || [];
//         for (const f of arr) {
//             loadTpl(f.path, fileMap);
//         }
//     }, undefined, 3000000, 1);
//     task(() => {
//         processCallback && processCallback({ type: 'loadWidget' });
//         const arr = suffixMap.get("widget") || [];
//         for (const f of arr) {
//             loadWidget(f.path, fileMap);
//         }
//     }, undefined, 3000000, 1);
//     task(() => {
//         processCallback && processCallback({ type: 'loadWidgetCfg' });
//         const arr = suffixMap.get("widcfg") || [];
//         for (const f of arr) {
//             loadWidCfg(f.path, fileMap);
//         }
//     }, undefined, 3000000, 1);
//     task(() => {
//         processCallback && processCallback({ type: 'loadDirCompleted' });
//         for (const m of mods) {
//             loadDirCompleted(m, fileMap);
//         }
//         successCallback && successCallback(fileMap, mods);
//     }, undefined, 3000000, 1);
// };
// const defineTpl = (suffixMap, fileMap: Json, successCallback?: Function, processCallback?: Function) => {
//     const tplArr = suffixMap.get("tpl") || [];
//     if (tplArr.length === 0) {
//         return successCallback();
//     }
//     const map = new Map();
//     let len = 0;
//     const defineArr = [];
//     tplArr.forEach(v => {
//         let tpl = getCache(v.path);
//         if (!tpl) {
//             let tpl = { value: null, path: v.path, wpath: null };
//             setCache(v.path, tpl);
//             map.set(v.path, 1);
//             defineArr.push(fileMap[v.path]);
//             len += fileMap[v.path].byteLength;
//         }
//     });
//     const d = new Int8Array(len);
//     len = 0;
//     defineArr.forEach((v: ArrayBuffer) => {
//         d.set(new Int8Array(v), len);
//         len += v.byteLength;
//     });
//     releaseDefine(d.buffer);
//     tplWait.push({
//         map: map,
//         total: map.size,
//         successCallback: successCallback,
//         processCallback: processCallback
//     })
// }
// /**
//  * @description 创建组件
//  * @example
//  */
// const loadTpl = (filename: string, fileMap: Json): void => {
//     let widget;
//     let forelet;
//     const name = filename.slice(0, filename.length - 4);
//     const s = name + '.widget'; // 忽略有widget配置的组件
//     if (fileMap[s]) {
//         return;
//     }
//     const mod = commonjs.relativeGet(name);
//     if (mod) {
//         widget = getExportFunc(mod, checkType, Widget);
//         forelet = getExportFunc(mod, checkInstance, Forelet);
//     }
//     const config = loadCfg(name + '.cfg', fileMap, name);
//     const tpl = loadTpl1(filename, fileMap, name);
//     const css = loadWcss(name + '.wcss', fileMap, name);
//     register(name.replace(/\//g, '-'), widget, tpl, css, config, forelet);
// };
// /**
//  * @description 创建组件
//  * @example
//  */
// const loadWidCfg = (filename: string, fileMap: Json): void => {
//     let widget;
//     let config;
//     let tpl;
//     let css;
//     let forelet;
//     const files = JSON.parse(butil.utf8Decode(fileMap[filename]));
//     for(let filename in files) {
//         if (!files.hasOwnProperty(filename))
//             continue;
//         if(!filename.endsWith(".widget"))
//             continue;
//         const name = filename.slice(0, filename.length - 7);
//         let cfg = files[filename];
//         if (cfg.js || cfg.widget) {
//             const mod = commonjs.relativeGet(commonjs.modName(cfg.js || cfg.widget), name);
//             if (!mod) {
//                 warn(level, 'widget not found, name:', name, cfg.js || cfg.widget);
//                 return;
//             }
//             widget = getExportFunc(mod, checkType, Widget);
//         }
//         if (cfg.cfg) {
//             const s = butil.relativePath(cfg.cfg, name);
//             config = files[s];
//             if (!config) {
//                 warn(level, 'widget cfg not found, name:', name, cfg.cfg);
//             }
//             config = { value: config };
//         }
//         if (cfg.css) {
//             css = loadWcss(cfg.css, fileMap, name);
//             if (!css) {
//                 warn(level, 'widget css not found, name:', name, cfg.css);
//             }
//         }
//         if (cfg.tpl) {
//             tpl = loadTpl1(cfg.tpl, fileMap, name);
//         }
//         if (cfg.forelet) {
//             const mod = commonjs.relativeGet(commonjs.modName(cfg.forelet), name);
//             if (!mod) {
//                 warn(level, 'widget forelet not found, name:', name, cfg.forelet);
//                 return;
//             }
//             forelet = getExportFunc(mod, checkInstance, Forelet);
//         }
//         register(name.replace(/\//g, '-'), widget, tpl, css, config, forelet);
//     }
// }
// /**
//  * @description 创建组件
//  * @example
//  */
// const loadWidget = (filename: string, fileMap: Json): void => {
//     let widget;
//     let config;
//     let tpl;
//     let css;
//     let forelet;
//     const name = filename.slice(0, filename.length - 7);
//     const cfg = JSON.parse(butil.utf8Decode(fileMap[filename]));
//     if (cfg.js || cfg.widget) {
//         const mod = commonjs.relativeGet(commonjs.modName(cfg.js || cfg.widget), name);
//         if (!mod) {
//             warn(level, 'widget not found, name:', name, cfg.js || cfg.widget);
//             return;
//         }
//         widget = getExportFunc(mod, checkType, Widget);
//     }
//     if (cfg.cfg) {
//         config = loadCfg(cfg.cfg, fileMap, name);
//         if (!config) {
//             warn(level, 'widget cfg not found, name:', name, cfg.cfg);
//         }
//     }
//     if (cfg.css) {
//         css = loadWcss(cfg.css, fileMap, name);
//         if (!css) {
//             warn(level, 'widget css not found, name:', name, cfg.css);
//         }
//     }
//     if (cfg.tpl) {
//         tpl = loadTpl1(cfg.tpl, fileMap, name);
//     }
//     if (cfg.forelet) {
//         const mod = commonjs.relativeGet(commonjs.modName(cfg.forelet), name);
//         if (!mod) {
//             warn(level, 'widget forelet not found, name:', name, cfg.forelet);
//             return;
//         }
//         forelet = getExportFunc(mod, checkInstance, Forelet);
//     }
//     register(name.replace(/\//g, '-'), widget, tpl, css, config, forelet);
// };
// /**
//  * @description 加载模板
//  * @example
//  */
// const loadTpl1 = (file: string, fileMap: Json, widget: string): Json => {
//     const s = butil.relativePath(file, widget);
//     let tpl = getCache(s);
//     if (!tpl) {
//         cc.warn() && log(`${file} is not load with script. `)
//         const data = fileMap[s];
//         if (!data) {
// 			cc.warn() && log('widget tpl not found, name:', widget, file);
//             return;
//         }
//         tpl = tplFun(butil.utf8Decode(data), s);
//         setCache(s, tpl);
//     } else if (!tpl.value) {
//         tpl.value = toFun(butil.utf8Decode(fileMap[s]), s);
//     }
//     return tpl;
// };
// /**
//  * @description 加载配置
//  * @example
//  */
// const loadCfg = (cfg: string | string[], fileMap: Json, widget: string): Json => {
//     if (Array.isArray(cfg)) {
//         let c;
//         for (const f of cfg) {
//             let config = loadCfg1(f, fileMap, widget);
//             if (!config) {
//                 continue;
//             }
//             config = config.value;
//             if (!config) {
//                 continue;
//             }
//             if (!c) {
//                 c = {};
//             }
//             for (const k in config) {
//                 c[k] = config[k];
//             }
//         }
//         return c ? { value: c } : null;
//     } else {
//         return loadCfg1(cfg, fileMap, widget);
//     }
// };
// /**
//  * @description 加载配置
//  * @example
//  */
// const loadCfg1 = (cfg: string, fileMap: Json, widget: string): Json => {
//     const s = butil.relativePath(cfg, widget);
//     let config = getCache(s);
//     if (!config) {
//         const data = fileMap[s];
//         if (!data) {
//             return;
//         }
//         config = { value: JSON.parse(butil.utf8Decode(data)) };
//         setCache(s, config);
//     } else if (!config.value) {
//         config.value = parse(butil.utf8Decode(fileMap[s]), s);
//     }
//     return config;
// };
// /**
//  * @description 加载配置
//  * @example
//  */
// const loadWcss = (wcss: string | string[], fileMap: Json, widget: string): Json => {
//     if (Array.isArray(wcss)) {
//         let sheet;
//         for (const f of wcss) {
//             let css = loadWcss1(f, fileMap, widget);
//             if (!css) {
//                 continue;
//             }
//             css = css.value;
//             if (!css) {
//                 continue;
//             }
//             if (!sheet) {
//                 sheet = new Map();
//             }
//             mapCopy(css, sheet);
//         }
//         return { value: sheet };
//     } else {
//         return loadWcss1(wcss, fileMap, widget);
//     }
// };
// /**
//  * @description 加载样式
//  * @example
//  */
// const loadWcss1 = (wcss: string, fileMap: Json, widget: string): Json => {
//     const s = butil.relativePath(wcss, widget);
//     let css = getCache(s);
//     if (!css) {
//         const data = fileMap[s];
//         if (!data) {
//             return;
//         }
//         css = { value: parse(butil.utf8Decode(data), s) };
//         setCache(s, css);
//     } else if (!css.value) {
//         css.value = parse(butil.utf8Decode(fileMap[s]), s);
//     }
//     return css;
// };
// /**
//  * @description 调用模块的loadDirCompleted方法
//  * @example
//  */
// const loadDirCompleted = (mod: Json, fileMap: Json): void => {
//     if(!mod)return;
//     const func = mod.loadDirCompleted;
//     func && func(fileMap);
// };
// /**
//  * @description 标签匹配， 判断模式字符串，是否和标签匹配，标签可以多级
//  * @example
//  * not($b1) or($b1,$b2) and(or($b1=c1,$b2!=c2), not($b3)) ($b2)
//  * 	$b1、$b2表示flag是否含有此键， $b2!=c2表示flag的b2键的值要不等于c2
//  */
// export const parseMatch = (pattern: any, flags: Json): boolean => {
//     let s = pattern.str;
//     if (s.startsWith('and(')) {
//         pattern.str = s.slice(4).trim();
//         return parseAnd(pattern, flags);
//     }
//     if (s.startsWith('or(')) {
//         pattern.str = s.slice(3).trim();
//         return parseOr(pattern, flags);
//     }
//     if (s.startsWith('not(')) {
//         pattern.str = s.slice(4).trim();
//         return parseNot(pattern, flags);
//     }
//     if (s.startsWith('(')) {
//         pattern.str = s.slice(1).trim();
//         const r = parseMatch(pattern, flags);
//         s = pattern.str;
//         if (s.charCodeAt(0) !== 41) { // ")"
//             throw new Error('parse error, invalid pattern:' + pattern.str);
//         }
//         return r;
//     }
//     return parseEqual(pattern, flags);
// };
// /**
//  * @description 分析not， ")"结束
//  * @example
//  */
// const parseNot = (pattern: any, flags: Json): boolean => {
//     const r = parseMatch(pattern, flags);
//     const s = pattern.str;
//     if (s.charCodeAt(0) !== 41) { // ")"
//         throw new Error('parse error, invalid pattern:' + pattern.str);
//     }
//     pattern.str = s.slice(1).trim();
//     return !r;
// };
// /**
//  * @description 分析or， ","分隔， ")"结束
//  * @example
//  */
// const parseOr = (pattern: any, flags: Json): boolean => {
//     let rr = false;
//     // tslint:disable-next-line:no-constant-condition
//     while (true) {
//         const r = parseMatch(pattern, flags);
//         const s = pattern.str;
//         if (s.charCodeAt(0) === 44) { // ","
//             pattern.str = s.slice(1).trim();
//         } else if (s.charCodeAt(0) === 41) { // ")"
//             pattern.str = s.slice(1).trim();
//             return rr || r;
//         } else {
//             throw new Error('parse error, invalid pattern:' + pattern.str);
//         }
//         rr = rr || r;
//     }
// };
// /**
//  * @description 分析and， ","分隔， ")"结束
//  * @example
//  */
// const parseAnd = (pattern: any, flags: Json): boolean => {
//     let rr = true;
//     // tslint:disable-next-line:no-constant-condition
//     while (true) {
//         const r = parseMatch(pattern, flags);
//         const s = pattern.str;
//         if (s.charCodeAt(0) === 44) { // ","
//             pattern.str = s.slice(1).trim();
//         } else if (s.charCodeAt(0) === 41) { // ")"
//             pattern.str = s.slice(1).trim();
//             return rr && r;
//         } else {
//             throw new Error('parse error, invalid pattern:' + pattern.str);
//         }
//         rr = rr && r;
//     }
// };
// /**
//  * @description 分析变量， 判断 = != 3种情况
//  * @example
//  */
// const parseEqual = (pattern: any, flags: Json): boolean => {
//     const v1 = parseValue(pattern, flags);
//     const s = pattern.str;
//     if (s.charCodeAt(0) === 41) { // ")"
//         return v1 !== false && v1 !== undefined;
//     }
//     if (s.charCodeAt(0) === 44) { // ","
//         return v1 !== false && v1 !== undefined;
//     }
//     if (s.charCodeAt(0) === 61) { // "="
//         pattern.str = s.slice(1).trim();
//         const v2 = parseValue(pattern, flags);
//         return v1 === v2;
//     }
//     if (s.charCodeAt(0) === 33 && s.charCodeAt(1) === 61) {// "!="
//         pattern.str = s.slice(2).trim();
//         const v2 = parseValue(pattern, flags);
//         return v1 !== v2;
//     }
//     throw new Error('parse error, invalid pattern:' + pattern.str);
// };
// /**
//  * @description 分析值，要么是变量，要么是字面量
//  * @example
//  */
// const parseValue = (pattern: any, flags: Json): any => {
//     const s = pattern.str;
//     if (s.charCodeAt(0) === 36) { // "$"
//         const arr = var_reg.exec(s);
//         if (!arr) {
//             throw new Error('parse error, invalid pattern:' + pattern.str);
//         }
//         pattern.str = s.slice(arr[0].length);
//         return getValue(flags, arr[1]);
//     }
//     let arr = str_reg.exec(s);
//     if (arr) {
//         pattern.str = s.slice(arr[0].length);
//         return arr[1];
//     }
//     arr = number_reg.exec(s);
//     if (!arr) {
//         throw new Error('parse error, invalid pattern:' + pattern.str);
//     }
//     pattern.str = s.slice(arr[0].length);
//     return parseFloat(arr[1]);
// };
// const fileSuffix1 = (file: string): string => {
//     let i = file.indexOf(".");
//     if (i === -1) {
//         return "";
//     }
//     return file.slice(i, file.length);
// }
// // 用BlobURL的方式加载的模块，二进制转换字符串及编译，浏览器内核会异步处理
// // 创建函数的方式加载，二进制转换字符串及编译，主线程同步处理性能不好
// const releaseDefine = (data: ArrayBuffer) => {
//     let blob = new Blob([data], { type: "text/javascript" });
//     loadJS({ src: URL.createObjectURL(blob), revokeURL: URL.revokeObjectURL });
// };
// const loadJS = (cfg) => {
//     let head = document.head;
//     let n: any = document.createElement('script');
//     n.charset = 'utf8';
//     n.onerror = (e) => {
//         n.onload = n.onerror = undefined;
//         head.removeChild(n);
//         cfg.revokeURL && cfg.revokeURL(cfg.src);
//     };
//     n.onload = () => {
//         n.onload = n.onerror = undefined;
//         head.removeChild(n);
//         cfg.revokeURL && cfg.revokeURL(cfg.src);
//     };
//     n.async = true;
//     n.crossorigin = true;
//     n.src = cfg.src;
//     head.appendChild(n);
// };
// (self as any)._$defineTpl = (name: string, func: Function) => {
//     let path = name + ".tpl";
//     let tpl = getCache(path);
//     if (!tpl) {
//         throw `tpl names ${name} not found`
//     }
//     for (let i = 0; i < tplWait.length; i++) {
//         let f = tplWait[i];
//         if (f.map.delete(path)) {
//             f.processCallback && f.processCallback({
//                 type: "defineTpl",
//                 total: f.total,
//                 curr: f.total - f.map.size
//             })
//             // 编译
//             if (!tpl.value) {
//                 tpl.value = toFunComplete(func, name);
//             }
//             f.processCallback && f.processCallback({
//                 type: "buildTpl",
//                 total: f.total,
//                 curr: f.total - f.map.size
//             })
//             if (f.map.size === 0) {
//                 f.successCallback && f.successCallback()
//                 tplWait.splice(i, 1);
//             }
//             return
//         }
//     }
//     console.error(`${name} not found in tplWait`);
// };
// // ============================== 立即执行

// /**
//  一般项目的目录结构：
// 	boot/ 启动页面
// 	app/a 选服界面或登录注册界面
// 	app/b 主界面，新手引导前3分钟用到的功能和3d显示配置（主城和开始的几个副本场景，以及马上要用到的模型、特效）
// 	app/b/ui
// 	app/c 剩余的全部的功能和3d显示配置
// 	app/c/ui
// 	app/init 选择角色 （可能的一场战斗）
// 	app/mod 最基础的模块
// 	app/ui 最基础的组件
// 	app/res 全部的场景资源， 进入场景前单独请求
// 	pi/ 底层模块
_$pi.define("pi_gui/widget/slowdown", ["require", "exports"], function (require, exports) {
    "use strict";
});
// 图标采用类似资源的做法，大部分放在c部分，如果需要完整显示（比如a部分），应用应该提前载入或放到app/a/中。否则需要的时候，直接实时载入。
// 流程：
// 	1、 显示封面。载入 100k 1-2秒。中间有loading显示，无进度显示。 
//         index.html + index.js + init.js + .depends + next.js
//         同步建立通讯
// 	2、 显示进度条1 载入 500k 1-3秒。进度完毕后显示选服界面或登录注册界面
// 		加载 pi/ app/mod app/ui app/a/
//         根据本地标志和服务器角色获取，判断是否第一次进入，启动slowdown选择不同流程载入。
//             无角色进入是init b c的代码配置的慢加载和可选的c资源的慢下载。
//             有角色进入是b c的代码配置的慢加载。
//         根据首次进入或玩家进新服，进入3或4的流程
// 	3、选择角色
// 		3.1、 显示进度条2。载入 500k-1M 2-4秒。进度完毕后显示选择角色 （可能的一场战斗）
// 			app/init/
// 			渐进加载场景资源 3-5秒
// 			预计大概 操作3-5秒
// 		3.2、 显示进度条3。载入 4M 4-10秒。进度完毕后显示主界面
// 			app/b/
//             渐进加载主城场景资源 3-5秒
//             预计操作3-5分钟
// 		3.3、 后台载入无进度显示
// 			app/c/的代码配置 8M 慢加载20秒
// 			app/c/的资源 20M 可选的慢下载200秒
// 	4、 显示进度条2。加载 12M 4-10秒。 进度完毕后显示主界面
// 		加载 app/b/的全部 app/c/的代码配置
// 注意：术语加载和下载是不同的。加载包括下载，数据包括代码、组件、资源都要进内存，主要为了减少下载后写入硬盘后，然后又较短时间内被读取的损耗。 下载则仅下载，数据从内存中丢弃。
// 如果是微信小游戏，则代码都已经全部加载。应用也无需改变流程。
//  */
// // ============================== 导入
// import { Json } from '../../pi_sys/modules/lang/type';
// import { listDirFile, loadDir, fileDepends } from '../widget/util';
// // import { load, depend } from '../../pi_sys/modules/lang/mod';
// // ============================== 导出
// // 默认检查时间
// export let checkTime = 100;
// // 默认休眠时间
// export let sleepTime = 1000;
// // 网络请求的同时下载的数量
// export let limitCount = 3;
// /**
//  * @description 用util.loadDir来加载文件列表，保证模块和组件会自动加载。下载顺序依赖数组的倒序。
//  * @example
//  */
// export const start = (filesArr: string[][], flags: Json, resultMap: Json, callback: Function, ruleOut: Function) => {
//     const cb = (time: number) => {
//         setTimeout(() => {
//             start(filesArr, flags, resultMap, callback, ruleOut)
//         }, time || sleepTime);
//     };
//     if (load.loadingCount() >= limitCount) {
//         return cb(checkTime);
//     }
//     let files = filesArr.pop();
//     if (!files) {
//         return callback();
//     }
//     loadDir(files, flags, resultMap, null, cb, cb, null, ruleOut, filesArr.length);
// };
// /**
//  * @description 将目录中需要下载的文件（本地没有或不是最新的），按限制的大小（默认256k~1兆），按后缀的优先级拆成多后缀多文件列表。
//  * @example
//  */
// export const split = (dirs: string[], flags: Json, suffixSort: string[], limitMinSize: number = 256 * 1024, limitMaxSize: number = 1024 * 1024, ruleOut: Function): string[][] => {
//     const fileList = [];
//     const suffixMap = new Map;
//     listDirFile(dirs, flags, fileList, suffixMap, null, null, ruleOut);
//     const result = [];
//     let last = 0;
//     for (let suffix of suffixSort) {
//         let files = suffixMap.get(suffix);
//         if (!files)
//             continue;
//         suffixMap.delete(suffix);
//         last = merge(result, last, files, limitMinSize, limitMaxSize);
//     }
//     // 处理剩余的后缀
//     for (let files of suffixMap.values()) {
//         last = merge(result, last, files, limitMinSize, limitMaxSize);
//     }
//     return result.reverse();
// };
// // ============================== 本地
// const merge = (result: string[][], last: number, files: any[], limitMinSize: number, limitMaxSize: number): number => {
//     let arr: string[];
//     if (last) {
//         arr = result[result.length - 1];
//     } else {
//         arr = [];
//         result.push(arr);
//     }
//     for (let f of files) {
//         if (last + f.size > limitMaxSize) {
//             arr = [];
//             result.push(arr);
//             last = 0;
//         }
//         last += f.size;
//         arr.push(f.path);
//     }
//     return last >= limitMinSize ? 0 : last;
// }
// // ============================== 立即执行

_$pi.define("pi_gui/gui/gui_root/tool", ["require", "exports", "../../../pi_sys/modules/util/frame_mgr", "../gui_virtual/painter", "../gui_virtual/virtaul_node_keyword", "../gui_virtual/widget", "../../../pi_sys/modules/lang/time", "../../../pi_sys/modules/util/event", "../../../pi_sys/modules/util/task_mgr", "../../../pi_sys/modules/util/util", "./root_manager", "../gui/tools"], function (require, exports, frame_mgr_1, painter_1, virtaul_node_keyword_1, widget_1, time_1, event_1, task_mgr_1, util_1, root_manager_1, tools_1) {
    "use strict";
    
    exports.PageOpenDebug = {
        tempTime: 0,
        active: false,
        BeforePageOpen: (name) => {
            exports.PageOpenDebug.tempTime = Date.now();
            tools_1.Tools.warn(`${name} Open Start: ${exports.PageOpenDebug.tempTime}`);
        },
        AfterPageOpen: (name) => {
            const now = Date.now();
            tools_1.Tools.warn(`${name} Open Start: ${now}`);
            tools_1.Tools.warn(`${name} Open Use: ${now - exports.PageOpenDebug.tempTime}`);
        }
    };
    window.PageOpenDebug = exports.PageOpenDebug;
    // 是否记录页面路由信息
    exports.routerRecord = true;
    /**
     * @description 获得是否禁止返回
     * @example
     */
    exports.isForbidBack = () => {
        return exports.forbidBack;
    };
    /**
     * @description 设置是否禁止返回
     * @example
     */
    exports.setForbidBack = (b) => {
        exports.forbidBack = b;
    };
    /**
     * @description 获得是否禁止默认滚动
     * @example
     */
    exports.isPreventScroll = () => {
        return exports.preventScroll;
    };
    /**
     * @description 设置是否禁止默认滚动
     * @example
     */
    exports.setPreventScroll = (b) => {
        exports.preventScroll = b;
    };
    /**
     * @description 弹出界面，返回关闭对象
     * @param back 为返回按钮的处理，Callback表示处理函数-必须调用w.cancel方法， cancel表示调用cancel函数，force表示强制不返回，next表示调用cancel函数继续调用返回，默认处理为cancel
     * @example
     */
    exports.pop = (w, ok, cancel, process, back, originProps) => {
        const b = { widget: w, callback: null };
        const close = { widget: w, callback: backClose };
        if (back === undefined || back === 'cancel') {
            b.callback = () => {
                close.callback(close.widget);
                cancel && cancel('back');
            };
        }
        else if (back === 'next') {
            b.callback = () => {
                close.callback(close.widget);
                cancel && cancel('back');
                exports.backCall();
            };
        }
        else if (back !== 'force') {
            b.callback = back;
        }
        exports.backList.push(b);
        let r;
        let propsSensitive = false;
        for (let i = 0; i < exports.routerList.length; i++) {
            const props = exports.routerList[i].props;
            if (props && props.pi_norouter) {
                propsSensitive = true;
                break;
            }
        }
        if ((w && w.props && w.props.pi_norouter) || propsSensitive) {
            r = { name: b.widget.name, props: { pi_norouter: true } };
        }
        else {
            r = { name: b.widget.name, props: originProps };
        }
        exports.routerList.push(r);
        routerListSerialize();
        // 设置回调
        w.ok = w.$ok = (arg) => {
            close.callback(close.widget);
            ok && ok(arg);
        };
        w.cancel = w.$cancel = (arg) => {
            close.callback(close.widget);
            cancel && cancel(arg);
        };
        w.process = w.$process = process;
        exports.add(w);
        return close;
    };
    /**
     * @description 弹出新界面，返回关闭对象
     * @param back 为返回按钮的处理，Callback表示处理函数-必须调用w.cancel方法， cancel表示调用cancel函数，force表示强制不返回，next表示调用cancel函数继续调用返回，默认处理为cancel
     * @example
     */
    exports.popNew = (name, props, ok, cancel, process, back) => {
        exports.PageOpenDebug.BeforePageOpen && exports.PageOpenDebug.BeforePageOpen(name);
        const w = exports.create(name, props);
        const close = exports.pop(w, ok, cancel, process, back, props);
        const c = close.callback;
        close.callback = (w) => {
            // popNew创建的，关闭需要销毁
            backClose(w);
            exports.destory(w);
        };
        exports.PageOpenDebug.AfterPageOpen && exports.PageOpenDebug.AfterPageOpen(name);
        return close;
    };
    /**
     * @description 将2个close关联起来，1个界面被关闭时，关闭另外1个界面，一般要求界面1先打开
     * @example
     */
    exports.linkClose = (close1, close2) => {
        const c1 = close1.callback;
        const c2 = close2.callback;
        close1.callback = (w) => {
            c2(close2.widget);
            c1(w);
        };
        close2.callback = (w) => {
            c2(w);
            c1(close1.widget);
        };
    };
    /**
     * @description 用任务队列的方式弹出界面2，并与界面1关联起来，如果界面1已经关闭，则自动销毁界面2
     * @example
     */
    exports.popLink = (close1, name, props, ok, cancel, process, back) => {
        frame_mgr_1.getGlobal().setAfter(() => {
            task_mgr_1.set(() => {
                if (!close1.widget.parentNode) {
                    return;
                }
                exports.PageOpenDebug.BeforePageOpen && exports.PageOpenDebug.BeforePageOpen(name);
                const w = exports.create(name, props);
                exports.PageOpenDebug.AfterPageOpen && exports.PageOpenDebug.AfterPageOpen(name);
                if (!close1.widget.parentNode) {
                    exports.destory(w);
                    return;
                }
                const close2 = exports.pop(w, ok, cancel, process, back);
                close2.callback = (w) => {
                    backClose(w);
                    exports.destory(w);
                };
                exports.linkClose(close1, close2);
            }, undefined, 1000, 1);
        });
    };
    /**
     * @description 创建指定名称的组件
     * @example
     */
    exports.create = (name, props) => {
        const w = widget_1.factory(name);
        if (!w) {
            return;
        }
        if (props !== undefined) {
            w.setProps(props);
        }
        w.paint();
        return w;
    };
    /**
     * @description 创建指定名称的组件，根据组件上的配置，将组件加入到指定的组上，会延迟到帧调用时添加
     * @example
     */
    exports.open = (name, props) => {
        exports.PageOpenDebug.BeforePageOpen && exports.PageOpenDebug.BeforePageOpen(name);
        const w = widget_1.factory(name);
        if (!w) {
            return;
        }
        if (props !== undefined) {
            w.setProps(props);
        }
        w.paint();
        exports.add(w);
        exports.PageOpenDebug.AfterPageOpen && exports.PageOpenDebug.AfterPageOpen(name);
        return w;
    };
    /**
     * @description 将指定的组件，根据组件上的配置，将组件加入到指定的组上，会延迟到帧调用时添加
     * @example
     */
    exports.add = (w, props) => {
        // root.appendChild(getRealNode(w.tree));
        // paintCmd3(root, 'appendChild', [getRealNode(w.tree)]);
        // return;
        const cfg = w.getConfig();
        const name = cfg && cfg.group;
        const group = root_manager_1.RootManager.findGroup(name || 'main');
        if (!group) {
            return;
        }
        if (w.parentNode) {
            return;
        }
        group.arr.push(w);
        if (props !== undefined) {
            w.setProps(props);
            w.paint();
        }
        // tslint:disable-next-line:no-object-literal-type-assertion
        const node = {
            [virtaul_node_keyword_1.VNKeyWords.attrs]: {},
            [virtaul_node_keyword_1.VNKeyWords.attrSize]: 0,
            [virtaul_node_keyword_1.VNKeyWords.attrHash]: 0,
            [virtaul_node_keyword_1.VNKeyWords.link]: w,
            [virtaul_node_keyword_1.VNKeyWords.widget]: exports.rootWidget,
            [virtaul_node_keyword_1.VNKeyWords.childHash]: 0xffffffff,
            [virtaul_node_keyword_1.VNKeyWords.child]: null
        };
        w.parentNode = node;
        // TODO 计算进场动画时间和是否透明
        // paintCmd3(group.el, 'appendChild', [getRealNode(w.tree)]);
        group.el.appendChild(painter_1.getRealNode(w.tree));
        painter_1.paintAttach(w);
        root_manager_1.RootManager.updateGroupVisible();
        exports.listenerList({ type: 'add', widget: w, group: group });
    };
    /**
     * @description 将指定的组件移除，会延迟到帧调用时移除
     * @example
     */
    exports.remove = (w) => {
        if (!w.parentNode) {
            return;
        }
        w.parentNode = null;
        // paintCmd3(getRealNode(w.tree), 'remove', []);
        painter_1.getRealNode(w.tree).remove();
        painter_1.paintDetach(w);
        const cfg = w.getConfig();
        const name = cfg && cfg.group;
        const group = root_manager_1.RootManager.findGroup(name || 'main');
        if (!group) {
            return;
        }
        const i = group.arr.indexOf(w);
        if (i < 0) {
            return;
        }
        group.arr.splice(i, 1);
        root_manager_1.RootManager.updateGroupVisible();
        exports.listenerList({ type: 'remove', widget: w, group: group });
    };
    /**
     * @description 显示或隐藏组
     * @example
     */
    exports.show = (groupName, b) => {
        const group = root_manager_1.RootManager.findGroup(groupName || 'main');
        if (!group) {
            return;
        }
        root_manager_1.RootManager.visibleGroup(group, b);
    };
    /**
     * @description 将指定的组件移除并销毁
     * @example
     */
    exports.destory = (w) => {
        exports.remove(w);
        painter_1.delWidget(w);
    };
    /**
     * @description 返回调用，返回弹出界面的数量
     * @example
     */
    exports.backCall = () => {
        const h = exports.backList[exports.backList.length - 1];
        h.callback && h.callback(h.widget);
        exports.routerList.pop();
        routerListSerialize();
        return exports.backList.length;
    };
    /**
     * @description 尽量关闭所有的返回对象，返回最后留下的弹出界面的数量
     * @example
     */
    exports.closeBack = () => {
        let len = exports.backList.length;
        let i = exports.backCall();
        while (i && i < len) {
            len = i;
            i = exports.backCall();
            exports.routerList.pop();
        }
        routerListSerialize();
        return i;
    };
    /**
     * @description 指定范围(左上角x1y1, 右下角x2y2)外，禁止鼠标和触控事件，直到超时时间
     * @example
     */
    exports.forbidEvent = (timeout, rect) => {
        exports.forbidEventTime = timeout ? time_1.now() + timeout : 0;
        if (rect) {
            allowEventRect[0] = rect[0];
            allowEventRect[1] = rect[1];
            allowEventRect[2] = rect[2];
            allowEventRect[3] = rect[3];
        }
        else {
            allowEventRect[0] = allowEventRect[1] = allowEventRect[2] = allowEventRect[3] = 0;
        }
    };
    /**
     * @description 日志显示，仅处理在手机上，commonjs.debug打开，log级别为info,warn的日志
     * @example
     */
    exports.log = (level, msg, args1, args2, args3, args4, args5, args6, args7, args8, args9) => {
        // if (level < logLevel || !logContainer) {
        //     return;
        // }
        let s;
        if (args9 !== undefined) {
            // tslint:disable:max-line-length prefer-template
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + ', ' + util_1.toString(args4) + ', ' + util_1.toString(args5) + ', ' + util_1.toString(args6) + ', ' + util_1.toString(args7) + ', ' + util_1.toString(args8) + ', ' + util_1.toString(args9) + '\n';
        }
        else if (args8 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + ', ' + util_1.toString(args4) + ', ' + util_1.toString(args5) + ', ' + util_1.toString(args6) + ', ' + util_1.toString(args7) + ', ' + util_1.toString(args8) + '\n';
        }
        else if (args7 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + ', ' + util_1.toString(args4) + ', ' + util_1.toString(args5) + ', ' + util_1.toString(args6) + ', ' + util_1.toString(args7) + '\n';
        }
        else if (args6 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + ', ' + util_1.toString(args4) + ', ' + util_1.toString(args5) + ', ' + util_1.toString(args6) + '\n';
        }
        else if (args5 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + ', ' + util_1.toString(args4) + ', ' + util_1.toString(args5) + '\n';
        }
        else if (args4 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + ', ' + util_1.toString(args4) + '\n';
        }
        else if (args3 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + ', ' + util_1.toString(args3) + '\n';
        }
        else if (args2 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + ', ' + util_1.toString(args2) + '\n';
        }
        else if (args1 !== undefined) {
            s = util_1.toString(msg) + ', ' + util_1.toString(args1) + '\n';
        }
        else {
            s = util_1.toString(msg) + '\n';
        }
        logClearTime = time_1.now() + LogClearTimeout;
        const t = document.createTextNode(s);
        logs.unshift(t);
        painter_1.paintCmd3(exports.logContainer, 'appendChild', [t]);
        if (logs.length === 1) {
            painter_1.paintCmd3(exports.root, 'appendChild', [exports.logContainer]);
            setTimeout(clearLog, LogClearInterval);
        }
    };
    /**
     * @description 导出的监听器列表
     * @example
     */
    exports.listenerList = event_1.createHandlerList();
    // 日志清除掉超时时间，20秒，也就是说20秒内，如果有日志写入，则不清除日志
    const LogClearTimeout = 20000;
    // 日志清除的间隔时间，2秒
    const LogClearInterval = 2000;
    // 日志最多100条
    const LogLimit = 100;
    // 根元素
    exports.root = null;
    exports.setRoot = (e) => {
        exports.root = e;
    };
    // 根组件
    exports.rootWidget = null;
    exports.setRootWidget = (e) => {
        exports.rootWidget = e;
    };
    // 组对象表
    exports.groupMap = root_manager_1.RootManager.groupMap;
    // 返回记录
    exports.backList = [];
    // 路由记录
    exports.routerList = [];
    // 禁止返回
    exports.forbidBack = false;
    // 禁止默认滚动
    exports.preventScroll = false;
    // 日志
    const logs = [];
    // 日志的清理时间
    let logClearTime = 0;
    // 日志的dom容器
    exports.logContainer = null;
    exports.setLogContainer = (e) => {
        exports.logContainer = e;
    };
    // 根元素的缩放比例
    exports.rootScale = 1;
    // 根元素的xy坐标
    exports.rootX = 0;
    exports.rootY = 0;
    // 根元素的宽度和高度
    exports.rootWidth = 0;
    exports.rootHeight = 0;
    // 旧的高度
    exports.oldHeight = 0;
    // 手机模式弹出键盘的高度
    exports.keyBoardHeight = 0;
    // 禁止触控时间
    exports.forbidEventTime = 0;
    // 允许的矩形区域外，禁止触控
    exports.resetSize = (l, t, w, h) => {
        exports.rootX = l;
        exports.rootY = t;
        exports.rootWidth = w;
        exports.rootHeight = h;
    };
    const allowEventRect = [0, 0, 0, 0];
    // 序列化routerList
    const routerListSerialize = () => {
        if (exports.routerRecord) {
            localStorage.setItem('pi_router_list', JSON.stringify(exports.routerList));
        }
    };
    /**
     * @description 返回关闭
     * @example
     */
    const backClose = (w) => {
        exports.remove(w);
        w.ok = w.$ok = null;
        w.cancel = w.$cancel = null;
        w.process = w.$process = null;
        exports.backList.pop();
        exports.routerList.pop();
        routerListSerialize();
    };
    /**
     * @description 检查坐标是否在允许区域内
     * @example
     */
    const checkAllowRect = (x, y, rect) => {
        return (x > rect[0] && x < rect[2] && y > rect[1] && y < rect[3]);
    };
    /**
     * @description 负责监控页面大小变化，约束根元素在标准比例附近变化
     * @example
     */
    const browserAdaptive = () => {
        if (!exports.root) {
            return;
        }
        return;
    };
    /**
     * @description 日志清除
     * @example
     */
    const clearLog = () => {
        // 清除超过100条的日志
        let i = logs.length - 1;
        if (i >= LogLimit) {
            for (; i >= LogLimit; i--) {
                painter_1.paintCmd3(logs[i], 'remove', []);
            }
            logs.length = i + 1;
        }
        else {
            const t = time_1.now();
            if (t > logClearTime) {
                painter_1.paintCmd3(logs[i--], 'remove', []);
                logs.pop();
            }
        }
        if (i >= 0) {
            setTimeout(clearLog, LogClearInterval);
        }
        else {
            painter_1.paintCmd3(exports.logContainer, 'remove', []);
        }
    };
    // // ============================== 立即执行
    // // 在手机上才需要注册日志函数
    // commonjs.flags.mobile && setBroadcast(log);
    // 监听onresize
    window.onresize = browserAdaptive;
    // 取顶层窗口
    try {
        const win = top.window;
        // 注册系统返回事件
        win.onpopstate = () => {
            win.history.pushState({}, null);
            if (exports.forbidBack) {
                return;
            }
            if (exports.backList.length) {
                exports.backCall();
            }
            else {
                exports.listenerList({ type: 'back' });
            }
        };
        win.history.pushState({}, null);
        // tslint:disable-next-line:no-empty
    }
    catch (e) {
    }
});

/*
 * 根组件
 * 负责监控页面大小变化，约束根元素在标准比例附近变化
 * 负责提供组，组的定义在div元素的属性上
 * 负责将指定的组件放入到对应的组上，并计算该组件的进场动画的时间，进程动画完毕后，还负责根据是否透明的配置，将该组下的组件及组设置成隐藏，组件销毁时，要把被隐藏的组件显示出来。动画期间禁止操作
 */
_$pi.define("pi_gui/gui/gui_root/root", ["require", "exports", "../gui/r_style", "../gui/tools", "../gui_virtual/forelet", "../gui_virtual/painter", "../gui_virtual/virtaul_node_keyword", "../gui_virtual/virtual_node", "../gui_virtual/widget", "./root_manager", "./tool", "../gui/animation"], function (require, exports, r_style_1, tools_1, forelet_1, painter_1, virtaul_node_keyword_1, virtual_node_1, widget_1, root_manager_1, Tool, animation_1) {
    "use strict";
    
    // 是否记录页面路由信息
    exports.routerRecord = () => Tool.routerRecord;
    class Root extends widget_1.Widget {
        constructor() {
            super(...arguments);
            this.down = (e) => {
                tools_1.Tools.log('Root Down');
                if (this !== Root.primaryRoot) {
                    return;
                }
                Root.downList.forEach((f) => {
                    f(e);
                });
            };
            this.up = (e) => {
                tools_1.Tools.log('Root up');
                if (this !== Root.primaryRoot) {
                    return;
                }
                Root.upList.forEach((f) => {
                    f(e);
                });
            };
            this.move = (e) => {
                tools_1.Tools.log('Root move');
                if (this !== Root.primaryRoot) {
                    return;
                }
                Root.moveList.forEach((f) => {
                    f(e);
                });
            };
            this.click = (e) => {
                tools_1.Tools.log('Root move');
                if (this !== Root.primaryRoot) {
                    return;
                }
                Root.clickList.forEach((f) => {
                    f(e);
                });
            };
            this.dbclick = (e) => {
                tools_1.Tools.log('Root move');
                if (this !== Root.primaryRoot) {
                    return;
                }
                Root.dbclickList.forEach((f) => {
                    f(e);
                });
            };
            this.multipointer = (e) => {
                tools_1.Tools.log(`'Root multipointer' ${e.x}, ${e.y}`);
                if (this !== Root.primaryRoot) {
                    return;
                }
                Root.multipointerList.forEach((f) => {
                    f(e);
                });
            };
        }
        static addDownListener(f) {
            if (this.downList.indexOf(f) < 0) {
                this.downList.push(f);
            }
        }
        static addUpListener(f) {
            if (this.upList.indexOf(f) < 0) {
                this.upList.push(f);
            }
        }
        static addMoveListener(f) {
            if (this.moveList.indexOf(f) < 0) {
                this.moveList.push(f);
            }
        }
        static addWheelListener(f) {
            if (this.wheelList.indexOf(f) < 0) {
                this.wheelList.push(f);
            }
        }
        static addDBClickListener(f) {
            if (this.dbclickList.indexOf(f) < 0) {
                this.dbclickList.push(f);
            }
        }
        static addClickListener(f) {
            if (this.clickList.indexOf(f) < 0) {
                this.clickList.push(f);
            }
        }
        static addMultiPointerListener(f) {
            if (this.multipointerList.indexOf(f) < 0) {
                this.multipointerList.push(f);
            }
        }
        static removeDownListener(f) {
            const i = this.downList.indexOf(f);
            i >= 0 && this.downList.splice(i, 1);
        }
        static removeUpListener(f) {
            const i = this.upList.indexOf(f);
            i >= 0 && this.upList.splice(i, 1);
        }
        static removeMoveListener(f) {
            const i = this.moveList.indexOf(f);
            i >= 0 && this.moveList.splice(i, 1);
        }
        static removeWheelListener(f) {
            const i = this.wheelList.indexOf(f);
            i >= 0 && this.wheelList.splice(i, 1);
        }
        static removeDBClickListener(f) {
            const i = this.dbclickList.indexOf(f);
            i >= 0 && this.dbclickList.splice(i, 1);
        }
        static removeClickListener(f) {
            const i = this.clickList.indexOf(f);
            i >= 0 && this.clickList.splice(i, 1);
        }
        static removeMultiPointerListener(f) {
            const i = this.multipointerList.indexOf(f);
            i >= 0 && this.multipointerList.splice(i, 1);
        }
    }
    exports.Root = Root;
    Root.downList = [];
    Root.upList = [];
    Root.moveList = [];
    Root.wheelList = [];
    Root.dbclickList = [];
    Root.clickList = [];
    Root.multipointerList = [];
    // let div: HTMLDivElement;
    // const loggg  = (arg) => {
    //     if (!div) {
    //         div = document.createElement('div');
    //         document.body.appendChild(div);
    //         div.style.cssText = 'position:absolute;top:100px;color:#ff0;';
    //     }
    //     div.innerText = typeof arg === 'string' ? arg :  JSON.stringify(arg);
    // };
    /**
     * @description 导出给组件用的forelet
     * @example
     */
    exports.forelet = new forelet_1.Forelet();
    /**
     * @description 导出的监听器列表
     * @example
     */
    exports.listenerList = root_manager_1.RootManager.listenerList;
    /**
     * @description 根元素的显示兼容配置,
     * 1x2(500x1000 600x1200) 2, 25x48(500x960 750x1440) 1.92, 8x15(480x900 560x1050 640x1200) 1.875, 5x9(500x900 600x1080) 1.8, 9x16(450x800 540x960) 1.77.., 3x5(480x800 540x900) 1.66.., 5x8(500x800) 1.6
     * @example
     */
    exports.cfg = {
        width: 750, height: 1334, wscale: 0, hscale: 0.25, full: false
    };
    /**
     * @description 获得根元素
     * @example
     */
    exports.getRoot = () => {
        return Tool.root;
    };
    /**
     * @description 获得根元素的缩放比例
     * @example
     */
    exports.getScale = () => {
        return Tool.rootScale;
    };
    /**
     * @description 获得根元素的宽度
     * @example
     */
    exports.getWidth = () => {
        return Tool.rootWidth;
    };
    /**
     * @description 获得根元素的高度
     * @example
     */
    exports.getHeight = () => {
        return Tool.rootHeight;
    };
    /**
     * 获取键盘高度
     */
    exports.getKeyBoardHeight = () => {
        return Tool.keyBoardHeight;
    };
    /**
     * @description 指定范围(左上角x1y1, 右下角x2y2)外，禁止鼠标和触控事件，直到超时时间
     * @example
     */
    exports.forbidEvent = Tool.forbidEvent;
    /**
     * @description 获得是否禁止返回
     * @example
     */
    exports.isForbidBack = Tool.isForbidBack;
    /**
     * @description 设置是否禁止返回
     * @example
     */
    exports.setForbidBack = Tool.setForbidBack;
    /**
     * @description 获得是否禁止默认滚动
     * @example
     */
    exports.isPreventScroll = Tool.isPreventScroll;
    /**
     * @description 设置是否禁止默认滚动
     * @example
     */
    exports.setPreventScroll = Tool.setPreventScroll;
    /**
     * @description 弹出界面，返回关闭对象
     * @param back 为返回按钮的处理，Callback表示处理函数-必须调用w.cancel方法， cancel表示调用cancel函数，force表示强制不返回，next表示调用cancel函数继续调用返回，默认处理为cancel
     * @example
     */
    // export const pop = Tool.pop;
    /**
     * @description 弹出新界面，返回关闭对象
     * @param back 为返回按钮的处理，Callback表示处理函数-必须调用w.cancel方法， cancel表示调用cancel函数，force表示强制不返回，next表示调用cancel函数继续调用返回，默认处理为cancel
     * @example
     */
    exports.popNew = root_manager_1.RootManager.popNew;
    /**
     * @description 弹出新界面，返回关闭对象
     * @param back 为返回按钮的处理，Callback表示处理函数-必须调用w.cancel方法， cancel表示调用cancel函数，force表示强制不返回，next表示调用cancel函数继续调用返回，默认处理为cancel
     * @example
     */
    exports.openTip = root_manager_1.RootManager.openTip;
    /**
     * @description 将2个close关联起来，1个界面被关闭时，关闭另外1个界面，一般要求界面1先打开
     * @example
     */
    exports.linkClose = Tool.linkClose;
    /**
     * @description 用任务队列的方式弹出界面2，并与界面1关联起来，如果界面1已经关闭，则自动销毁界面2
     * @example
     */
    exports.popLink = Tool.popLink;
    /**
     * @description 创建指定名称的组件
     * @example
     */
    exports.create = Tool.create;
    /**
     * @description 创建指定名称的组件，根据组件上的配置，将组件加入到指定的组上，会延迟到帧调用时添加
     * @example
     */
    exports.open = root_manager_1.RootManager.open;
    /**
     * @description 将指定的组件，根据组件上的配置，将组件加入到指定的组上，会延迟到帧调用时添加
     * @example
     */
    // export const add = Tool.add;
    /**
     * @description 将指定的组件移除，会延迟到帧调用时移除
     * @example
     */
    // export const remove = Tool.remove;
    /**
     * @description 显示或隐藏组
     * @example
     */
    exports.show = Tool.show;
    /**
     * @description 将指定的组件移除并销毁
     * @example
     */
    exports.destory = root_manager_1.RootManager.destory;
    /**
     * @description 日志显示，仅处理在手机上，commonjs.debug打开，log级别为info,warn的日志
     * @example
     */
    exports.log = Tool.log;
    /**
     * @description 获取指定属性的父元素，如果遇到root根节点则返回undefined
     * @example
     */
    exports.getParentByAttr = (el, key, value) => {
        while (el !== null && el !== Tool.root) {
            const v = el.getAttribute(key);
            if (v !== null) {
                if ((!value) || v === value) {
                    return el;
                }
            }
            el = el.parentNode;
        }
    };
    /**
     * @description 返回最后一个弹出界面
     * @example
     */
    exports.lastBack = () => {
        const h = exports.backList[exports.backList.length - 1];
        return h ? h.widget : null;
    };
    /**
     * @description 返回调用，返回弹出界面的数量
     * @example
     */
    exports.backCall = Tool.backCall;
    /**
     * @description 尽量关闭所有的返回对象，返回最后留下的弹出界面的数量
     * @example
     */
    exports.closeBack = Tool.closeBack;
    // 返回记录
    exports.backList = Tool.backList;
    // 路由记录
    exports.routerList = Tool.routerList;
    const GUIInitHookList = [];
    exports.init = () => {
        animation_1.AnimationControl.changeStyleHook = virtual_node_1.changeVirtualNodeStyle;
        Root.primaryRoot = exports.create('pi_gui-gui-gui_root-root');
        painter_1.vdocument.body.appendChild(Root.primaryRoot.tree[virtaul_node_keyword_1.VNKeyWords.link]);
        r_style_1.RStyle.setAnimationCfgRequest(AnimationKeyFrameRequest);
        GUIInitHookList.forEach((f) => {
            f();
        });
    };
    exports.registerGUIInitHook = (f) => {
        GUIInitHookList.push(f);
    };
    const AnimationKeyFrameRequest = (ele, aname) => {
        if (!ele.virtual.w.r_sheet) {
            return undefined;
        }
        else {
            // r_sheet.value.keyframes 键名与构建器 对应
            return (ele.virtual.w).r_sheet.value.keyframes[aname];
        }
    };
    // ============================== 本地
    // ============================== 立即执行
    // 监听添加widget
    // tslint:disable-next-line:max-func-body-length
    exports.forelet.listener = (cmd, widget) => {
        if (cmd !== 'firstPaint') {
            return;
        }
        Tool.setRootWidget(widget);
        Tool.setRoot(painter_1.getRealNode(widget.tree));
        root_manager_1.RootManager.setRootWidget(widget);
        root_manager_1.RootManager.setRoot(painter_1.getRealNode(widget.tree));
        const arr = widget.tree[virtaul_node_keyword_1.VNKeyWords.children];
        for (const n of arr) {
            const e = painter_1.getRealNode(n);
            const name = virtual_node_1.getAttribute(n.a, 'group');
            if (!name) {
                continue;
            }
            root_manager_1.RootManager.addGroup(name, e);
            if (name === 'log') {
                Tool.setLogContainer(e);
            }
        }
        root_manager_1.RootManager.updateGroupVisible();
        // browserAdaptive();
    };
});
// setTimeout(() => { (<any>window).test24(); }, 2000);

/**
 * gui 节点样式数据解析器
 * * 样式数据被压缩为数组结构，解析为字符串表达
 */
_$pi.define("pi_gui/gui/gui/tools_explain", ["require", "exports", "./tools"], function (require, exports, tools_1) {
    "use strict";
    
    /**
     * style 数据解释器
     */
    // tslint:disable-next-line:no-unnecessary-class
    class ExplainStyle {
        static explain(key, data) {
            let res = '';
            if (data !== undefined && data !== null) {
                if (typeof data === 'string') {
                    res = data;
                }
                else {
                    res = this[key] ? this[key](data) : data;
                    // res = data;
                }
            }
            return res;
        }
        static _RGBA(data) {
            let res = '';
            if (typeof data === 'string') {
                res = data;
            }
            else {
                res = `#${this.toColorHex(data[0])}${this.toColorHex(data[1])}${this.toColorHex(data[2])}${this.toColorHex(data[3])}`;
            }
            return res;
        }
        static _LengthData(data) {
            let res = '';
            if (typeof data === 'string') {
                res = data;
            }
            else {
                switch (data[0]) {
                    case 0: {
                        res = `${data[1]}px`;
                        break;
                    }
                    case 1: {
                        res = `${data[1]}%`;
                        break;
                    }
                    case 2: {
                        res = `auto`;
                        break;
                    }
                    default:
                }
            }
            return res;
        }
        static _BoxData(data) {
            let res = '';
            data.forEach((v) => {
                res += this._LengthData(v);
            });
            return res;
        }
        static _Shadow(data) {
            let res = '';
            res += `${data[0]}px`;
            res += `${data[1]}px`;
            res += this._RGBA(data[2]);
            res += `${data[3]}px`;
            return res;
        }
        static _Gradient(data) {
            let res = '';
            const _type = data._t === tools_1.GradientTypes.linear ? 'linear-gradient' : 'radial-gradient';
            res += _type;
            return res;
        }
        static toColorHex(num) {
            const str = `0${(Math.round(num * 255)).toString(16)}`;
            return str.substr(str.length - 2, 2);
        }
        static toHex(num) {
            return num.toString(16);
        }
        static alignContent(data) {
            let res = '';
            res = YGAlign[data];
            return res;
        }
        static alignItems(data) {
            let res = '';
            res = YGAlign[data];
            return res;
        }
        static alignSelf(data) {
            let res = '';
            res = YGAlign[data];
            return res;
        }
        static background(data) {
            let res = '';
            res = this._RGBA(data);
            return res;
        }
        static backgroundColor(data) {
            let res = '';
            res = this._RGBA(data);
            return res;
        }
        static borderColor(data) {
            let res = '';
            res = this._RGBA(data);
            return res;
        }
        static borderImage(data) {
            let res = '';
            res = '';
            return res;
        }
        static borderRadius(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static borderWidth(data) {
            let res = '';
            res = '';
            return res;
        }
        static bottom(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static boxShadow(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static color(data) {
            let res = '';
            res = this._RGBA(data);
            return res;
        }
        static direction(data) {
            let res = '';
            res = '';
            return res;
        }
        static display(data) {
            let res = '';
            res = YGDisplay[data];
            return res;
        }
        static flexBasis(data) {
            let res = '';
            res = '';
            return res;
        }
        static flexDirection(data) {
            let res = '';
            res = YGFlexDirection[data];
            return res;
        }
        static flexGrow(data) {
            let res = '';
            res = data;
            return res;
        }
        static flexShrink(data) {
            let res = '';
            res = data;
            return res;
        }
        static flexWrap(data) {
            let res = '';
            res = YGWrap[data];
            return res;
        }
        static fontFamily(data) {
            let res = '';
            res = '';
            return res;
        }
        static fontSize(data) {
            let res = '';
            res = data;
            return res;
        }
        static fontStyle(data) {
            let res = '';
            res = FontStyle[data];
            return res;
        }
        static fontVariant(data) {
            let res = '';
            res = '';
            return res;
        }
        static fontWeight(data) {
            let res = '';
            res = data;
            return res;
        }
        static height(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static justifyContent(data) {
            let res = '';
            res = YGJustify[data];
            return res;
        }
        static left(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static letterSpacing(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static lineGradient(data) {
            let res = '';
            res = '';
            return res;
        }
        static lineHeight(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static margin(data) {
            let res = '';
            res = '';
            return res;
        }
        static marginBottom(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static marginLeft(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static marginRight(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static marginTop(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static maxHeight(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static maxWidth(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static minHeight(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static minWidth(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static opacity(data) {
            let res = '';
            res = data;
            return res;
        }
        static outlineColor(data) {
            let res = '';
            res = this._RGBA(data);
            return res;
        }
        static outlineOffset(data) {
            let res = '';
            res = '';
            return res;
        }
        static outlineStyle(data) {
            let res = '';
            res = '';
            return res;
        }
        static outlineWidth(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static oveflowWrap(data) {
            let res = '';
            res = '';
            return res;
        }
        static overflow(data) {
            let res = '';
            res = YGOverflow[data ? 1 : 0];
            return res;
        }
        static padding(data) {
            let res = '';
            res = '';
            return res;
        }
        static paddingBottom(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static paddingLeft(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static paddingRight(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static paddingTop(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static position(data) {
            let res = '';
            res = YGPositionType[data];
            return res;
        }
        static radioGradient(data) {
            let res = '';
            res = '';
            return res;
        }
        static right(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static rotate(data) {
            let res = '';
            res = '';
            return res;
        }
        static scale(data) {
            let res = '';
            res = '';
            return res;
        }
        static scroll(data) {
            let res = '';
            res = '';
            return res;
        }
        static textAlign(data) {
            let res = '';
            res = '';
            return res;
        }
        static textContent(data) {
            let res = '';
            res = '';
            return res;
        }
        static textDecoration(data) {
            let res = '';
            res = '';
            return res;
        }
        static textIndent(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static textOverflow(data) {
            let res = '';
            res = '';
            return res;
        }
        static textShadow(data) {
            let res = '';
            res = '';
            return res;
        }
        static textTransform(data) {
            let res = '';
            res = '';
            return res;
        }
        static top(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static transform(data) {
            let res = '';
            res = '';
            return res;
        }
        static transformOrigin(data) {
            let res = '';
            res = '';
            return res;
        }
        static translate(data) {
            let res = '';
            res = '';
            return res;
        }
        static translateX(data) {
            let res = '';
            res = '';
            return res;
        }
        static translateY(data) {
            let res = '';
            res = '';
            return res;
        }
        static unicodeBidi(data) {
            let res = '';
            res = '';
            return res;
        }
        static verticalAlign(data) {
            let res = '';
            res = '';
            return res;
        }
        static visibility(data) {
            let res = '';
            res = data ? 'visible' : 'hidden';
            return res;
        }
        static whiteSpace(data) {
            let res = '';
            res = '';
            return res;
        }
        static width(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static wordSpacing(data) {
            let res = '';
            res = this._LengthData(data);
            return res;
        }
        static zIndex(data) {
            let res = '';
            res = data;
            return res;
        }
        static animation(data) {
            let res = '';
            res = '';
            return res;
        }
        static borderImageSource(data) {
            let res = '';
            res = '';
            return res;
        }
        static borderImageClip(data) {
            let res = '';
            res = '';
            return res;
        }
        static borderImageRepeat(data) {
            let res = '';
            res = '';
            return res;
        }
        static borderImageSlice(data) {
            let res = '';
            res = '';
            return res;
        }
        static imageClip(data) {
            let res = '';
            res = '';
            return res;
        }
    }
    exports.ExplainStyle = ExplainStyle;
    /**
     *
     */
    var YGAlign;
    (function (YGAlign) {
        YGAlign[YGAlign["auto"] = 0] = "auto";
        YGAlign[YGAlign["flex-start"] = 1] = "flex-start";
        YGAlign[YGAlign["center"] = 2] = "center";
        YGAlign[YGAlign["flex-end"] = 3] = "flex-end";
        YGAlign[YGAlign["stretch"] = 4] = "stretch";
        YGAlign[YGAlign["baseline"] = 5] = "baseline";
        YGAlign[YGAlign["space-between"] = 6] = "space-between";
        YGAlign[YGAlign["space-around"] = 7] = "space-around";
    })(YGAlign = exports.YGAlign || (exports.YGAlign = {}));
    var YGDimension;
    (function (YGDimension) {
        YGDimension[YGDimension["width"] = 0] = "width";
        YGDimension[YGDimension["height"] = 1] = "height";
    })(YGDimension = exports.YGDimension || (exports.YGDimension = {}));
    var YGDirection;
    (function (YGDirection) {
        YGDirection[YGDirection["inherit"] = 0] = "inherit";
        YGDirection[YGDirection["LTR"] = 1] = "LTR";
        YGDirection[YGDirection["RTL"] = 2] = "RTL";
    })(YGDirection = exports.YGDirection || (exports.YGDirection = {}));
    var YGDisplay;
    (function (YGDisplay) {
        YGDisplay[YGDisplay["flex"] = 0] = "flex";
        YGDisplay[YGDisplay["none"] = 1] = "none";
    })(YGDisplay = exports.YGDisplay || (exports.YGDisplay = {}));
    var YGEdge;
    (function (YGEdge) {
        YGEdge[YGEdge["left"] = 0] = "left";
        YGEdge[YGEdge["top"] = 1] = "top";
        YGEdge[YGEdge["right"] = 2] = "right";
        YGEdge[YGEdge["bottom"] = 3] = "bottom";
        YGEdge[YGEdge["start"] = 4] = "start";
        YGEdge[YGEdge["end"] = 5] = "end";
        YGEdge[YGEdge["horizontal"] = 6] = "horizontal";
        YGEdge[YGEdge["vertical"] = 7] = "vertical";
        YGEdge[YGEdge["all"] = 8] = "all";
    })(YGEdge = exports.YGEdge || (exports.YGEdge = {}));
    var YGExperimentalFeature;
    (function (YGExperimentalFeature) {
        YGExperimentalFeature[YGExperimentalFeature["WebFlexBasis"] = 0] = "WebFlexBasis";
    })(YGExperimentalFeature = exports.YGExperimentalFeature || (exports.YGExperimentalFeature = {}));
    var YGFlexDirection;
    (function (YGFlexDirection) {
        YGFlexDirection[YGFlexDirection["column"] = 0] = "column";
        YGFlexDirection[YGFlexDirection["column-reverse"] = 1] = "column-reverse";
        YGFlexDirection[YGFlexDirection["row"] = 2] = "row";
        YGFlexDirection[YGFlexDirection["row-reverse"] = 3] = "row-reverse";
    })(YGFlexDirection = exports.YGFlexDirection || (exports.YGFlexDirection = {}));
    var YGJustify;
    (function (YGJustify) {
        YGJustify[YGJustify["flex-start"] = 0] = "flex-start";
        YGJustify[YGJustify["center"] = 1] = "center";
        YGJustify[YGJustify["flex-end"] = 2] = "flex-end";
        YGJustify[YGJustify["space-between"] = 3] = "space-between";
        YGJustify[YGJustify["space-around"] = 4] = "space-around";
        YGJustify[YGJustify["space-evenly"] = 5] = "space-evenly";
    })(YGJustify = exports.YGJustify || (exports.YGJustify = {}));
    var YGLogLevel;
    (function (YGLogLevel) {
        YGLogLevel[YGLogLevel["error"] = 0] = "error";
        YGLogLevel[YGLogLevel["warn"] = 1] = "warn";
        YGLogLevel[YGLogLevel["info"] = 2] = "info";
        YGLogLevel[YGLogLevel["debug"] = 3] = "debug";
        YGLogLevel[YGLogLevel["verbose"] = 4] = "verbose";
        YGLogLevel[YGLogLevel["fatal"] = 5] = "fatal";
    })(YGLogLevel = exports.YGLogLevel || (exports.YGLogLevel = {}));
    var YGMeasureMode;
    (function (YGMeasureMode) {
        YGMeasureMode[YGMeasureMode["undefined"] = 0] = "undefined";
        YGMeasureMode[YGMeasureMode["exactly"] = 1] = "exactly";
        YGMeasureMode[YGMeasureMode["atMost"] = 2] = "atMost";
    })(YGMeasureMode = exports.YGMeasureMode || (exports.YGMeasureMode = {}));
    var YGNodeType;
    (function (YGNodeType) {
        YGNodeType[YGNodeType["default"] = 0] = "default";
        YGNodeType[YGNodeType["text"] = 1] = "text";
    })(YGNodeType = exports.YGNodeType || (exports.YGNodeType = {}));
    var YGOverflow;
    (function (YGOverflow) {
        YGOverflow[YGOverflow["visible"] = 0] = "visible";
        YGOverflow[YGOverflow["hidden"] = 1] = "hidden";
        YGOverflow[YGOverflow["scroll"] = 2] = "scroll";
    })(YGOverflow = exports.YGOverflow || (exports.YGOverflow = {}));
    var YGPositionType;
    (function (YGPositionType) {
        YGPositionType[YGPositionType["relative"] = 0] = "relative";
        YGPositionType[YGPositionType["absolute"] = 1] = "absolute";
    })(YGPositionType = exports.YGPositionType || (exports.YGPositionType = {}));
    var YGPrintOptions;
    (function (YGPrintOptions) {
        YGPrintOptions[YGPrintOptions["Layout"] = 1] = "Layout";
        YGPrintOptions[YGPrintOptions["Style"] = 2] = "Style";
        YGPrintOptions[YGPrintOptions["Children"] = 4] = "Children";
    })(YGPrintOptions = exports.YGPrintOptions || (exports.YGPrintOptions = {}));
    var YGWrap;
    (function (YGWrap) {
        YGWrap[YGWrap["no-wrap"] = 0] = "no-wrap";
        YGWrap[YGWrap["wrap"] = 1] = "wrap";
        YGWrap[YGWrap["wrap-reverse"] = 2] = "wrap-reverse";
    })(YGWrap = exports.YGWrap || (exports.YGWrap = {}));
    var LengthUnitType;
    (function (LengthUnitType) {
        LengthUnitType[LengthUnitType["px"] = 0] = "px";
        LengthUnitType[LengthUnitType["%"] = 1] = "%";
        LengthUnitType[LengthUnitType["auto"] = 2] = "auto";
    })(LengthUnitType = exports.LengthUnitType || (exports.LengthUnitType = {}));
    var Opacity;
    (function (Opacity) {
        Opacity[Opacity["Opaque"] = 0] = "Opaque";
        Opacity[Opacity["Translucent"] = 1] = "Translucent";
        Opacity[Opacity["Transparent"] = 2] = "Transparent";
    })(Opacity = exports.Opacity || (exports.Opacity = {}));
    var RadialGradientShapes;
    (function (RadialGradientShapes) {
        RadialGradientShapes[RadialGradientShapes["circle"] = 0] = "circle";
        RadialGradientShapes[RadialGradientShapes["ellipse"] = 1] = "ellipse";
    })(RadialGradientShapes = exports.RadialGradientShapes || (exports.RadialGradientShapes = {}));
    var RadialGradientSize;
    (function (RadialGradientSize) {
        RadialGradientSize[RadialGradientSize["ClosestSide"] = 0] = "ClosestSide";
        RadialGradientSize[RadialGradientSize["FarthestSide"] = 1] = "FarthestSide";
        RadialGradientSize[RadialGradientSize["ClosestCorner"] = 2] = "ClosestCorner";
        RadialGradientSize[RadialGradientSize["Farthestcorner"] = 3] = "Farthestcorner";
    })(RadialGradientSize = exports.RadialGradientSize || (exports.RadialGradientSize = {}));
    var UndefinedType;
    (function (UndefinedType) {
        // decorate
        UndefinedType[UndefinedType["BorderColor"] = 0] = "BorderColor";
        UndefinedType[UndefinedType["BorderRadius"] = 1] = "BorderRadius";
        UndefinedType[UndefinedType["BoxShadowColor"] = 2] = "BoxShadowColor";
        UndefinedType[UndefinedType["BoxShadowH"] = 3] = "BoxShadowH";
        UndefinedType[UndefinedType["BoxShadowV"] = 4] = "BoxShadowV";
        // BoxShadowBlur, 暂不支持
        UndefinedType[UndefinedType["BackgroundColor"] = 5] = "BackgroundColor";
        //
        UndefinedType[UndefinedType["Opacity"] = 6] = "Opacity";
        UndefinedType[UndefinedType["Overflow"] = 7] = "Overflow";
        UndefinedType[UndefinedType["Visibility"] = 8] = "Visibility";
        // 变换
        UndefinedType[UndefinedType["TransformRotate"] = 9] = "TransformRotate";
        UndefinedType[UndefinedType["TransformScale"] = 10] = "TransformScale";
        UndefinedType[UndefinedType["TransformScaleX"] = 11] = "TransformScaleX";
        UndefinedType[UndefinedType["TransformScaleY"] = 12] = "TransformScaleY";
        UndefinedType[UndefinedType["TransformTranslate"] = 13] = "TransformTranslate";
        UndefinedType[UndefinedType["TransformTranslateX"] = 14] = "TransformTranslateX";
        UndefinedType[UndefinedType["TransformTranslateY"] = 15] = "TransformTranslateY";
        // 布局
        UndefinedType[UndefinedType["AlignContent"] = 16] = "AlignContent";
        UndefinedType[UndefinedType["JustifyContent"] = 17] = "JustifyContent";
        UndefinedType[UndefinedType["FlexDirection"] = 18] = "FlexDirection";
        UndefinedType[UndefinedType["FlexWrap"] = 19] = "FlexWrap";
        UndefinedType[UndefinedType["FlexGrow"] = 20] = "FlexGrow";
        UndefinedType[UndefinedType["FlexShrink"] = 21] = "FlexShrink";
        UndefinedType[UndefinedType["FlexBasis"] = 22] = "FlexBasis";
        UndefinedType[UndefinedType["AlignSelf"] = 23] = "AlignSelf";
        UndefinedType[UndefinedType["Left"] = 24] = "Left";
        UndefinedType[UndefinedType["Top"] = 25] = "Top";
        UndefinedType[UndefinedType["Right"] = 26] = "Right";
        UndefinedType[UndefinedType["Bottom"] = 27] = "Bottom";
        UndefinedType[UndefinedType["Width"] = 28] = "Width";
        UndefinedType[UndefinedType["Height"] = 29] = "Height";
        UndefinedType[UndefinedType["MaxWidth"] = 30] = "MaxWidth";
        UndefinedType[UndefinedType["MaxHeight"] = 31] = "MaxHeight";
        UndefinedType[UndefinedType["MinWidth"] = 32] = "MinWidth";
        UndefinedType[UndefinedType["MinHeight"] = 33] = "MinHeight";
        UndefinedType[UndefinedType["PaddingLeft"] = 34] = "PaddingLeft";
        UndefinedType[UndefinedType["PaddingTop"] = 35] = "PaddingTop";
        UndefinedType[UndefinedType["PaddingRight"] = 36] = "PaddingRight";
        UndefinedType[UndefinedType["PaddingBottom"] = 37] = "PaddingBottom";
        UndefinedType[UndefinedType["MarginLeft"] = 38] = "MarginLeft";
        UndefinedType[UndefinedType["MarginTop"] = 39] = "MarginTop";
        UndefinedType[UndefinedType["MarginRight"] = 40] = "MarginRight";
        UndefinedType[UndefinedType["MarginBottom"] = 41] = "MarginBottom";
    })(UndefinedType = exports.UndefinedType || (exports.UndefinedType = {}));
    /**
     */
    var VerticalAlign;
    (function (VerticalAlign) {
        VerticalAlign[VerticalAlign["Center"] = 0] = "Center";
        VerticalAlign[VerticalAlign["Top"] = 1] = "Top";
        VerticalAlign[VerticalAlign["Bootom"] = 2] = "Bootom";
        VerticalAlign[VerticalAlign["Undefined"] = 3] = "Undefined";
    })(VerticalAlign = exports.VerticalAlign || (exports.VerticalAlign = {}));
    /**
     */
    var TextDirection;
    (function (TextDirection) {
        TextDirection[TextDirection["Left"] = 0] = "Left";
        TextDirection[TextDirection["Right"] = 1] = "Right";
        TextDirection[TextDirection["Top"] = 2] = "Top";
        TextDirection[TextDirection["Bootom"] = 3] = "Bootom";
        TextDirection[TextDirection["Undefined"] = 4] = "Undefined";
    })(TextDirection = exports.TextDirection || (exports.TextDirection = {}));
    /**
     */
    var TextAlign;
    (function (TextAlign) {
        TextAlign[TextAlign["left"] = 0] = "left";
        TextAlign[TextAlign["right"] = 1] = "right";
        TextAlign[TextAlign["center"] = 2] = "center";
        TextAlign[TextAlign["justify"] = 3] = "justify";
        TextAlign[TextAlign["undefined"] = 4] = "undefined";
    })(TextAlign = exports.TextAlign || (exports.TextAlign = {}));
    /**
     */
    var WhiteSpace;
    (function (WhiteSpace) {
        WhiteSpace[WhiteSpace["normal"] = 0] = "normal";
        WhiteSpace[WhiteSpace["nowrap"] = 1] = "nowrap";
        WhiteSpace[WhiteSpace["pre-wrap"] = 2] = "pre-wrap";
        WhiteSpace[WhiteSpace["pre"] = 3] = "pre";
        WhiteSpace[WhiteSpace["pre-line"] = 4] = "pre-line";
        WhiteSpace[WhiteSpace["undefined"] = 5] = "undefined";
    })(WhiteSpace = exports.WhiteSpace || (exports.WhiteSpace = {}));
    /**
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["Normal"] = 0] = "Normal";
        FontStyle[FontStyle["Ttalic"] = 1] = "Ttalic";
        FontStyle[FontStyle["Oblique"] = 2] = "Oblique";
        FontStyle[FontStyle["Undefined"] = 3] = "Undefined";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     */
    var FontWeight;
    (function (FontWeight) {
        FontWeight[FontWeight["Normal"] = 600] = "Normal";
        FontWeight[FontWeight["Bold"] = 700] = "Bold";
        FontWeight[FontWeight["Bolder"] = 900] = "Bolder";
        FontWeight[FontWeight["Lighter"] = 300] = "Lighter";
        FontWeight[FontWeight["One"] = 100] = "One";
        FontWeight[FontWeight["Two"] = 200] = "Two";
        FontWeight[FontWeight["Three"] = 300] = "Three";
        FontWeight[FontWeight["Four"] = 400] = "Four";
        FontWeight[FontWeight["Five"] = 500] = "Five";
        FontWeight[FontWeight["Six"] = 600] = "Six";
        FontWeight[FontWeight["Seven"] = 700] = "Seven";
        FontWeight[FontWeight["Eight"] = 800] = "Eight";
        FontWeight[FontWeight["Nine"] = 900] = "Nine";
        FontWeight[FontWeight["Undefined"] = 500] = "Undefined";
    })(FontWeight = exports.FontWeight || (exports.FontWeight = {}));
    /**
     */
    var FontSizeType;
    (function (FontSizeType) {
        //   Medium,
        //   XXSmall,
        //   XSmall,
        //   Small,
        //   Large,
        //   XLarge,
        //   XXLarge,
        //   Smaller,
        //   Larger,
        FontSizeType[FontSizeType["Length"] = 0] = "Length";
        FontSizeType[FontSizeType["Percent"] = 1] = "Percent";
        //   Undefined,
    })(FontSizeType = exports.FontSizeType || (exports.FontSizeType = {}));
    var ClipPathBasicShapeType;
    (function (ClipPathBasicShapeType) {
        ClipPathBasicShapeType[ClipPathBasicShapeType["Polygon"] = 0] = "Polygon";
        ClipPathBasicShapeType[ClipPathBasicShapeType["Circle"] = 1] = "Circle"; // 暂不支持
    })(ClipPathBasicShapeType = exports.ClipPathBasicShapeType || (exports.ClipPathBasicShapeType = {}));
    var ClipPathGeometryBoxType;
    (function (ClipPathGeometryBoxType) {
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["MarginBox"] = 0] = "MarginBox";
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["BorderBox"] = 1] = "BorderBox";
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["PaddingBox"] = 2] = "PaddingBox";
        ClipPathGeometryBoxType[ClipPathGeometryBoxType["ContentBox"] = 3] = "ContentBox";
    })(ClipPathGeometryBoxType = exports.ClipPathGeometryBoxType || (exports.ClipPathGeometryBoxType = {}));
    var BorderImageRepeat;
    (function (BorderImageRepeat) {
        BorderImageRepeat[BorderImageRepeat["stretch"] = 0] = "stretch";
        BorderImageRepeat[BorderImageRepeat["repeat"] = 1] = "repeat";
        BorderImageRepeat[BorderImageRepeat["round"] = 2] = "round";
        BorderImageRepeat[BorderImageRepeat["space"] = 3] = "space"; // 源图像的边缘区域被平铺（重复）以填充每个边界之间的间隙。可以缩小瓷砖以实现适当的配合。
    })(BorderImageRepeat = exports.BorderImageRepeat || (exports.BorderImageRepeat = {}));
});

/**
 * GUI 调试器
 * * 节点树面板
 * * 属性面板
 * * 数据打印面板
 */
_$pi.define("pi_gui/gui/gui/inspector", ["require", "exports", "./tools", "./tools_explain"], function (require, exports, tools_1, tools_explain_1) {
    "use strict";
    
    class Inspector {
        constructor(gui, rootNode) {
            /**
             * 目标变更的监听列表
             */
            this.changeTargetListeners = [];
            this.gui = gui;
            this.rootNode = rootNode || gui.body;
            this.createDocument();
            this.createTree();
            this.createStylePanel();
            this.createRustPanel();
            gui.afterDisplayDebugLayer = NodeDisplay.displayCall;
        }
        doRefresh(rootNode) {
            this.rootNode = rootNode || this.rootNode;
            this.nodeTree.destroy();
            this.createTree();
        }
        /**
         * 变更目标节点
         * @param ele 目标节点
         */
        doChangeTarget(ele) {
            this.gui.eventMgr.debugFocus(ele);
            this.changeTargetListeners.forEach((f) => {
                f(ele);
            });
        }
        /**
         * 变更目标节点
         * @param ele 目标节点
         */
        callChangeTarget(ele) {
            this.changeTargetListeners.forEach((f) => {
                f(ele);
            });
        }
        addChangeTargetListen(f) {
            if (this.changeTargetListeners.indexOf(f) < 0) {
                this.changeTargetListeners.push(f);
            }
        }
        /**
         * 创建节点树
         */
        createTree() {
            this.nodeTree = new NodeTree(this, this.rootNode);
        }
        /**
         * 创建 style 面板
         */
        createStylePanel() {
            this.stylePanel = new StylePanel(this);
        }
        /**
         * 创建 rust 面板
         */
        createRustPanel() {
            this.rustPanel = new RustPanel(this, this.gui);
        }
        /**
         * 创建 上下文 面板
         */
        createDocument() {
            const windowCreationOptionsList = {
                width: '300px',
                height: '300px',
                top: 0,
                right: 0
            };
            const windowCreationOptions = Object.keys(windowCreationOptionsList)
                .map((key) => `${key}'='${(windowCreationOptionsList)[key]}`)
                .join(',');
            const popupWindow = window.open(``, `GUIInspector`, windowCreationOptions);
            Inspector.document = popupWindow.document;
            Inspector.document.body.style.cssText = 'backgroundColor: #404040; margin: 0;padding: 0;width: 300px;height: 300px;';
            this.dom = Inspector.document;
        }
    }
    exports.Inspector = Inspector;
    class NodeTree {
        constructor(ins, rootNode) {
            this.visible = true;
            /**
             * 变更目标节点
             * @param ele 目标节点
             */
            this.doChangeTarget = (ele) => {
                this.inspector.doChangeTarget(ele);
                this.root.afterChangeTarget(ele);
            };
            /**
             * 变更目标节点
             * @param ele 目标节点
             */
            this.callChangeTarget = (ele) => {
                this.inspector.callChangeTarget(ele);
                this.root.afterChangeTarget(ele);
            };
            this.trigger = (e) => {
                this.visible = !this.visible;
                this.btn.innerText = this.visible ? `隐藏` : `显示`;
                this.root.host.style.display = this.visible ? 'inline-block' : 'none';
            };
            this.inspector = ins;
            this.rootNode = rootNode;
            this.createHost();
            this.createBtn();
            this.createTree();
        }
        destroy() {
            this.inspector.dom.body.removeChild(this.host);
        }
        /**
         * 创建面板
         */
        createHost() {
            this.host = Inspector.document.createElement('div');
            this.host.style.cssText = `position:absolute;width:50%;height:100%;left:0;border:1px solid #666;opacity:0.8;background-color:#9ed33c;overflow:auto;`;
            Inspector.document.body.appendChild(this.host);
        }
        /**
         * 创建面板 - 树结构
         */
        createTree() {
            this.root = new NodeDisplay(this, this.rootNode);
            this.host.appendChild(this.root.host);
            this.root.host.style.width = '10000%';
        }
        createBtn() {
            this.btn = Inspector.document.createElement('div');
            this.btn.style.cssText = `width:100px;height:30px;background-color:#dddd00`;
            this.btn.innerText = this.visible ? `隐藏` : `显示`;
            this.host.appendChild(this.btn);
            this.btn.onclick = this.trigger;
        }
    }
    class NodeDisplay {
        constructor(nodeTree, ele) {
            this.childs = [];
            this.afterChangeTarget = (ele) => {
                this.head.afterSelect(ele);
                this.childs.forEach((v, i) => {
                    v.afterChangeTarget(ele);
                });
            };
            this.expend = (e) => {
                if (this.head) {
                    if (this.head.isExpend) {
                        this.content.style.display = 'block';
                    }
                    else {
                        this.content.style.display = 'none';
                    }
                }
            };
            this.nodeTree = nodeTree;
            this.ele = ele;
            this.createHost();
            this.createHead();
            this.createContent();
            this.createChildren();
            this.expend({});
            NodeDisplay.NodeDisplayMap.set(ele.uniqueID, this);
        }
        doChangeTarget() {
            this.nodeTree.doChangeTarget(this.ele);
        }
        createHost() {
            this.host = Inspector.document.createElement('div');
            this.host.style.cssText = `position:relative;width:auto;height:auto;`;
        }
        createHead() {
            this.head = new NodeName(this, this.ele);
            this.host.appendChild(this.head.host);
        }
        createContent() {
            this.content = Inspector.document.createElement('div');
            this.content.style.cssText = `position:relative;height:auto;margin-left:10px;`;
            this.host.appendChild(this.content);
        }
        createChildren() {
            const childs = this.ele.childNodes;
            if (childs) {
                childs.forEach((v, i) => {
                    const node = new NodeDisplay(this.nodeTree, v);
                    this.content.appendChild(node.host);
                    this.childs.push(node);
                    node.parent = this;
                });
            }
        }
    }
    NodeDisplay.NodeDisplayMap = new Map();
    NodeDisplay.displayCall = (ele) => {
        if (!ele.isDestroy) {
            const nodeDisplay = NodeDisplay.NodeDisplayMap.get(ele.uniqueID);
            nodeDisplay.nodeTree.callChangeTarget(ele);
            nodeDisplay.head.doExpend({});
        }
    };
    class NodeName {
        constructor(node, ele) {
            this.isSelect = false;
            this.afterSelect = (ele) => {
                if (this.ele === ele) {
                    this.host.style.backgroundColor = '#e03030';
                }
                else {
                    this.host.style.backgroundColor = '#5591dc';
                }
            };
            this.select = (e) => {
                this.node.doChangeTarget();
            };
            this.expend = (e) => {
                this.isExpend = !this.isExpend;
                this.node.expend(e);
                this.flag.innerText = this.isExpend ? '\u25cb' : '\u25cf';
                if (this.isExpend) {
                    this.doExpend(e);
                }
            };
            this.doExpend = (e) => {
                this.isExpend = true;
                this.node.expend(e);
                this.flag.innerText = this.isExpend ? '\u25cb' : '\u25cf';
                if (this.isExpend && this.node.parent) {
                    this.node.parent.head.doExpend(e);
                }
            };
            this.node = node;
            this.ele = ele;
            this.isExpend = false;
            this.createHost();
            this.createFlag();
            this.createTitle();
        }
        createHost() {
            this.host = Inspector.document.createElement('div');
            this.host.style.cssText = `position:relative;height:24px;font-size:20px;border:1px solid #ddd;background-color:#5591dc;`;
        }
        createTitle() {
            let titleStr = '';
            titleStr += ` - ${this.ele._type}: `;
            titleStr += `<span style="color:#813c85;">${this.ele.uniqueID}</span> -(lv: ${this.ele.level} ${this.ele.level === 0 ? '- body' : ''})`;
            if (this.ele.attributes && this.ele.attributes.w_tag) {
                titleStr += ` - <span style="color:#1a029c;font-weight:800;">${this.ele.attributes.w_tag}</span>`;
            }
            if (this.ele.attributes && this.ele.attributes.group !== undefined) {
                titleStr += ` - ${this.ele.attributes.group}`;
            }
            if (this.ele.virtual && this.ele.virtual.wc) {
                titleStr += ` - wclass="${this.ele.virtual.wc}"`;
            }
            if (this.ele.attributes.debug !== undefined) {
                titleStr += ` - ${this.ele.attributes.debug}`;
            }
            this.title = Inspector.document.createElement('div');
            this.title.style.cssText = 'display:inline-block;background-color:#82dfef;';
            // tslint:disable-next-line:no-inner-html
            this.title.innerHTML = titleStr;
            this.host.appendChild(this.title);
            this.title.onclick = this.select;
            this.title.style.cursor = 'pointer';
        }
        createFlag() {
            this.flag = Inspector.document.createElement('span');
            this.flag.style.cssText = 'display:inline-block;color:#ffffff;background-color:#f04b22;letter-spacing:8px;text-indent:8px;';
            this.flag.innerText = this.isExpend ? '\u25cb' : '\u25cf';
            this.flag.setAttribute('disenabled', 'disenabled');
            this.host.appendChild(this.flag);
            this.flag.onclick = this.expend;
            this.flag.style.cursor = 'pointer';
        }
    }
    class StylePanel {
        constructor(ins) {
            this.styleMap = new Map();
            this.visible = true;
            this.addChangeTargetListeners = [];
            this.trigger = (e) => {
                this.visible = !this.visible;
                this.btn.innerText = this.visible ? `隐藏` : `显示`;
                this.content.style.display = this.visible ? 'block' : 'none';
            };
            /**
             * 变更目标节点
             */
            this.changeTarget = (target) => {
                this.target = target;
                this.refreshDisplay();
            };
            this.inspector = ins;
            this.createHost();
            this.createBtn();
            this.createContent();
            this.createList();
            this.inspector.addChangeTargetListen(this.changeTarget);
        }
        /**
         * 手动修改后 将修改应用到 节点上
         */
        changeTargetStyle(key, value) {
            if (!this.target) {
                return;
            }
            this.target.style[key] = value;
            if (this.target.virtual) {
                this.target.virtual.style[key] = value;
            }
        }
        /**
         * 添加目标变更时的监听
         */
        addChangeTargetListen(f) {
            if (this.addChangeTargetListeners.indexOf(f) < 0) {
                this.addChangeTargetListeners.push(f);
            }
        }
        /**
         * 创建面板
         */
        createHost() {
            this.host = Inspector.document.createElement('div');
            this.host.style.cssText = `position:absolute;width:50%;height:50%;right:0;border:1px solid #666;opacity:0.8;background-color:#1e9eb3;overflow:auto;`;
            Inspector.document.body.appendChild(this.host);
        }
        /**
         * 创建面板 - 内容
         */
        createContent() {
            this.content = Inspector.document.createElement('div');
            this.content.style.cssText = `width:auto;height:500px;right:0;background-color:#1e9eb3;display:flex;flex-direction:column;flex-wrap:wrap;`;
            this.host.appendChild(this.content);
        }
        /**
         * 创建面板 - 条目
         */
        createList() {
            styleList.forEach((v, i) => {
                const attr = new AttrComp(this, v);
                this.styleMap.set(v, attr);
                this.content.appendChild(attr.host);
            });
        }
        /**
         * 目标变更后刷新 面板显示
         */
        refreshDisplay() {
            if (!this.target.virtual) {
                return;
            } // body
            if (!this.target.virtual.style) {
                this.target.virtual.style = {};
            }
            const style = this.target.style;
            styleList.forEach((v, i) => {
                const attr = this.styleMap.get(v);
                if (attr) {
                    attr.refreshDisplay(tools_explain_1.ExplainStyle.explain(v, style[v]));
                }
            });
        }
        createBtn() {
            this.btn = Inspector.document.createElement('div');
            this.btn.style.cssText = `width:100px;height:30px;background-color:#dddd00`;
            this.btn.innerText = this.visible ? `隐藏` : `显示`;
            this.host.appendChild(this.btn);
            this.btn.onclick = this.trigger;
        }
    }
    class AttrComp {
        constructor(panel, name) {
            this.change = (e) => {
                if (this.value === this.dat1.value) {
                    return;
                }
                if (this.value !== this.dat1.value) {
                    if (this.dat1.value === undefined) {
                        return;
                    }
                    if (this.dat1.value === 'undefined') {
                        return;
                    }
                }
                this.value = this.dat1.value;
                if (this.title === 'backgroundColor' || this.title === 'color') {
                    this.dat1.style.backgroundColor = this.value;
                }
                this.panel.changeTargetStyle(this.title, this.value);
            };
            this.blur = (e) => {
                this.isActive = false;
                this.change(e);
            };
            this.focus = (e) => {
                this.isActive = true;
            };
            this.title = name;
            this.panel = panel;
            this.isActive = false;
            this.createHost();
            this.createDat0();
            this.createDat1();
        }
        refreshDisplay(value) {
            this.value = value;
            this.dat1.value = value;
            if (this.title === 'backgroundColor' || this.title === 'color') {
                this.dat1.style.backgroundColor = this.value;
            }
        }
        createHost() {
            this.host = Inspector.document.createElement('div');
            this.host.style.cssText = `width:400px;margin:0;padding:0;height:25px;left:0;border:1px solid #666;font-size:16px;display:flex;`;
        }
        createDat0() {
            this.dat0 = Inspector.document.createElement('div');
            this.dat0.style.cssText = `margin:0;padding:0;width:50%;height:25px;left:0;display:inline-flex;text-align:right;justify-content:flex-end;`;
            this.dat0.innerText = `${this.title}：`;
            this.host.appendChild(this.dat0);
        }
        createDat1() {
            this.dat1 = Inspector.document.createElement('input');
            this.dat1.style.cssText = `margin:0;padding:0;width:50%;height:25px;right:0;display:inline;font-size:12px;`;
            this.host.appendChild(this.dat1);
            // this.dat1.onchange = this.change;
            this.dat1.onfocus = this.focus;
            this.dat1.onblur = this.blur;
        }
    }
    // tslint:disable-next-line:no-unnecessary-class
    class RustPanel {
        constructor(ins, doc) {
            this.changeTarget = (target) => {
                this.target = target;
                // this.data   = RDocument.nodeInfo(this.doc.uniqueID, target.uniqueID);
                this.changeDisplay();
                tools_1.Tools.log(target);
            };
            this.init(ins, doc);
            ins.addChangeTargetListen(this.changeTarget);
        }
        changeDisplay() {
            let value = '';
            // 一般节点的 attributes 数据
            this.data = this.target.attributes;
            Object.keys(this.data).forEach((v, i) => {
                if (v[0] !== '_') {
                    value += `${v}: ${this.data[v]}\n`;
                }
            });
            // 文本节点的 文本内容
            if (this.target.nodeValue) {
                value += `nodeValue: ${this.target.nodeValue}\n`;
            }
            this.content.value = value;
        }
        init(ins, doc) {
            this.ins = ins;
            this.doc = doc;
            this.dom = document.createElement('div');
            this.dom.style.cssText = 'position:absolute;width:50%;height:50%;right:0;bottom:0;background-color:#9fcf0099;overflow-y:auto;';
            this.ins.dom.body.appendChild(this.dom);
            this.createContent();
        }
        createContent() {
            this.content = document.createElement('textarea');
            this.content.style.cssText = 'position:absolute;width:100%;height:100%;background-color:#aaaaaa99;';
            this.dom.appendChild(this.content);
        }
    }
    const styleList = [
        'alignContent',
        'alignItems',
        'alignSelf',
        'background',
        'backgroundColor',
        'borderColor',
        'borderImage',
        'borderRadius',
        'borderWidth',
        'bottom',
        'boxShadow',
        'color',
        'direction',
        'display',
        'flexBasis',
        'flexDirection',
        'flexGrow',
        'flexShrink',
        'flexWrap',
        'fontFamily',
        'fontSize',
        'fontStyle',
        'fontVariant',
        'fontWeight',
        'height',
        'justifyContent',
        'left',
        'letterSpacing',
        'lineGradient',
        'lineHeight',
        'margin',
        // 'marginBottom',
        // 'marginLeft',
        // 'marginRight',
        // 'marginTop',
        'maxHeight',
        'maxWidth',
        'minHeight',
        'minWidth',
        'opacity',
        'outlineColor',
        'outlineOffset',
        'outlineStyle',
        'outlineWidth',
        'oveflowWrap',
        'overflow',
        'padding',
        // 'paddingBottom',
        // 'paddingLeft',
        // 'paddingRight',
        // 'paddingTop',
        'position',
        'radioGradient',
        'right',
        'rotate',
        'scale',
        'scroll',
        'textAlign',
        'textContent',
        'textDecoration',
        'textIndent',
        'textOverflow',
        'textShadow',
        'textTransform',
        'top',
        'transform',
        'transformOrigin',
        // 'translate',
        // 'translateX',
        // 'translateY',
        // 'unicodeBidi',
        'verticalAlign',
        'visibility',
        'whiteSpace',
        'width',
        'wordSpacing',
        'zIndex',
        'animation',
        'borderImageSource',
        'borderImageClip',
        'borderImageRepeat',
        'borderImageSlice',
        'imageClip',
        'pointerEvent',
        'objectFit'
    ];
    window.Inspector = Inspector;
});

// /**
//  * @description 全局渲染管理模块
//  * @example 
//  * 负责管理所有的渲染函数，每帧调用，计算fps。所有涉及到重布局(reflow)重绘(repaint)的操作（修改Dom结构，或者修改CSS相关属性。对于Canvas对象，执行某个操作，比如画一条线，也属于对Dom结构的改变）都应该放到渲染函数内执行。
//  * RequestAnimaitonFrame会将JS产生的动画以及CSS产生的动画，放到同一个Reflow和Repaint的循环中。setTimeout并不能保证这一点。
//  * 为了保证界面的流畅，操作的立即响应和显示出效果，可以不控制帧数。场景渲染可以单独控帧。
//  * 可以根据即时帧率来判断当前的CPU使用率。
//  */
_$pi.define("pi_gui/widget/frame_mgr", ["require", "exports"], function (require, exports) {
    "use strict";
});
// // ============================== 导入
// import { now as timeNow } from '../../pi_sys/modules/lang/time';
// import { cc, log } from '../../pi_sys/feature/log';
// import { call } from '../../pi_sys/modules/util/util';
// /**
//  * @description 设置全局渲染帧函数的回调函数
//  * @example
//  */
// export const setInterval = (callback): number => {
// 	if (!callback) {
// 		return;
// 	}
// 	let start;
// 	// 计算真实的渲染消耗
// 	const timeout = () => {
// 		callback.realCostTime = timeNow() - start;
// 	};
// 	const request = () => {
// 		start = timeNow();
// 		callback();
// 		// clearInterval需要的时间戳是不断变化的，故而需要每次更改timeRef ---lgz
// 		callback.timeRef = requestFrame(request);
// 		setTimeout(timeout, 0);
// 	};
// 	return callback.timeRef = requestFrame(request);
// };
// /**
//  * @description 取消全局渲染帧函数
//  * @example
//  */
// export const clearInterval = (ref: number) => {
// 	cancelFrame(ref);
// };
// /**
//  * @description 创建帧管理器
//  * @example
//  */
// // tslint:disable-next-line:max-func-body-length
// export const create = () => {
// 	// 上次花费时间，本次帧时间，帧次数
// 	let frameCost = 0;
// 	let frameTime = 0;
// 	let frameCount = 0;
// 	// 默认的间隔时间
// 	let frameInterval = 16;
// 	// 下次调用时间
// 	let frameNext = 0;
// 	// 渲染标志，为true表示当前正在渲染
// 	let inRender = false;
// 	// 本次调用的列表
// 	let cur = [];
// 	// 下次调用的列表
// 	let next = [];
// 	// 单次调用前列表
// 	let before = [];
// 	// 单次调用前列表
// 	let before1 = [];
// 	// 永久调用列表
// 	let permanent: any[] = [];
// 	// 单次调用后列表
// 	let after = [];
// 	// 单次调用后列表
// 	let after1 = [];
// 	// 统计间隔 默认1s
// 	let statInterval = 1000;
// 	// 下次统计时间
// 	let statNext = 0;
// 	// 统计的回调函数
// 	let statCallback;
// 	// 当前统计 {时间跨度, 每间隔帧统计{帧次数, 累计花费时间, 最慢一帧所在帧次数, 最慢一帧花费时间}, 每间隔调用统计{调用次数, 累计花费时间, 最慢一帧所在帧次数, 最慢一帧花费时间, 最慢函数所在帧次数, 最慢函数花费时间, 最慢函数}}
// 	// tslint:disable:max-line-length
// 	const curStat = { time: 0, frame: { count: 0, cost: 0, slowIndex: 0, slowCost: 0 }, call: { count: 0, cost: 0, slowIndex: 0, slowCost: 0, slowFuncIndex: 0, slowFuncCost: 0, slowFunc: null } };
// 	// 上次统计
// 	const lastStat = { time: 0, frame: { count: 0, cost: 0, slowIndex: 0, slowCost: 0 }, call: { count: 0, cost: 0, slowIndex: 0, slowCost: 0, slowFuncIndex: 0, slowFuncCost: 0, slowFunc: null } };
// 	// 统计慢时间
// 	const statSlow = (stat, start, end) => {
// 		const cost = end - start;
// 		stat.count++;
// 		stat.cost += cost;
// 		if (cost > stat.slowCost) {
// 			stat.slowCost = cost;
// 			stat.slowIndex = frameCount;
// 		}
// 		return cost;
// 	};
// 	// 统计函数
// 	const statFunc = (stat, func, start, end) => {
// 		const cost = end - start;
// 		if (cost > stat.slowFuncCost) {
// 			stat.slowFuncCost = cost;
// 			stat.slowFuncIndex = frameCount;
// 			stat.slowFunc = func;
// 		}
// 	};
// 	// 统计切换
// 	const statChange = (now, curStat, lastStat) => {
// 		if (now < statNext) {
// 			return;
// 		}
// 		lastStat.time = now - curStat.time;
// 		curStat.time = now;
// 		lastStat.frame.count = curStat.frame.count;
// 		curStat.frame.count = 0;
// 		lastStat.frame.cost = curStat.frame.cost;
// 		curStat.frame.cost = 0;
// 		lastStat.frame.slowIndex = curStat.frame.slowIndex;
// 		lastStat.frame.slowCost = curStat.frame.slowCost;
// 		curStat.frame.slowCost = 0;
// 		lastStat.call.count = curStat.call.count;
// 		curStat.call.count = 0;
// 		lastStat.call.cost = curStat.call.cost;
// 		curStat.call.cost = 0;
// 		lastStat.call.slowIndex = curStat.call.slowIndex;
// 		lastStat.call.slowCost = curStat.call.slowCost;
// 		curStat.call.slowCost = 0;
// 		lastStat.frame.slowFuncIndex = curStat.frame.slowFuncIndex;
// 		lastStat.frame.slowFuncCost = curStat.frame.slowFuncCost;
// 		curStat.frame.slowFuncCost = 0;
// 		lastStat.frame.slowFunc = curStat.frame.slowFunc;
// 		statNext = now + statInterval;
// 	};
// 	// 帧函数
// 	let frame: any;
// 	frame = () => {
// 		const now = timeNow();
// 		inRender = true;
// 		statChange(now, curStat, lastStat);
// 		frameCount++;
// 		frameTime = now;
// 		let i;
// 		let func;
// 		let end;
// 		let start = now;
// 		const stat = curStat.call;
// 		let arr = cur;
// 		cur = next;
// 		next = arr;
// 		// 下次调用
// 		for (i = arr.length - 1; i > 0; i -= 2) {
// 			func = arr[i - 1];
// 			end = funCall(func, arr[i]);
// 			statFunc(stat, func, start, end);
// 			start = end;
// 		}
// 		arr.length = 0;
// 		if (now > frameNext) {
// 			// 一次性前调用
// 			arr = before;
// 			before = before1;
// 			before1 = arr;
// 			for (i = arr.length - 1; i > 0; i -= 2) {
// 				func = arr[i - 1];
// 				end = funCall(func, arr[i]);
// 				statFunc(stat, func, start, end);
// 				start = end;
// 			}
// 			arr.length = 0;
// 			// 永久调用
// 			arr = permanent;
// 			for (i = arr.length - 1; i > 0; i -= 2) {
// 				func = arr[i - 1];
// 				end = funCall(func, arr[i]);
// 				statFunc(stat, func, start, end);
// 				start = end;
// 			}
// 			arr = after;
// 			after = after1;
// 			after1 = arr;
// 			// 一次性后调用
// 			for (i = arr.length - 1; i > 0; i -= 2) {
// 				func = arr[i - 1];
// 				end = funCall(func, arr[i]);
// 				statFunc(stat, func, start, end);
// 				start = end;
// 			}
// 			arr.length = 0;
// 			frameNext = now >= frameNext + frameInterval ? now + 1 : frameNext + frameInterval;
// 			frameCost = statSlow(curStat.frame, now, end);
// 		}
// 		statSlow(stat, now, end);
// 		inRender = false;
// 		curStat.frame.count === 1 && statCallback && statCallback(lastStat);
// 	};
// 	/**
// 	 * @description 获得上次花费时间，可以用来计算即时帧率
// 	 * @example
// 	 */
// 	frame.getCost = () => {
// 		return frameCost;
// 	};
// 	/**
// 	 * @description 获得本次帧时间
// 	 * @example
// 	 */
// 	frame.getTime = () => {
// 		return frameTime;
// 	};
// 	/**
// 	 * @description 获得当前帧次数
// 	 * @example
// 	 */
// 	frame.getCount = () => {
// 		return frameCount;
// 	};
// 	/**
// 	 * @description 获得下次的调用时间
// 	 * @example
// 	 */
// 	frame.getNextTime = () => {
// 		return frameNext;
// 	};
// 	/**
// 	 * @description 获得帧间隔
// 	 * @example
// 	 */
// 	frame.getInterval = () => {
// 		return frameInterval;
// 	};
// 	/**
// 	 * @description 设置帧间隔
// 	 * @example
// 	 */
// 	frame.setInterval = (interval: number) => {
// 		frameInterval = interval;
// 	};
// 	/**
// 	 * @description 添加一个永久调用函数和参数（参数必须为数组）
// 	 * @example
// 	 */
// 	frame.setPermanent = (func: Function, args?: any[]) => {
// 		func && permanent.push(func, args);
// 	};
// 	/**
// 	 * @description 判断是否为一个永久调用函数
// 	 * @example
// 	 */
// 	frame.isPermanent = (func: Function) => {
// 		for (const index in permanent) {
// 			if (permanent[index] === func) {
// 				return true;
// 			}
// 		}
// 		return false;
// 	};
// 	/**
// 	 * @description 移除一个永久调用函数
// 	 * @example
// 	 */
// 	frame.clearPermanent = (func: Function) => {
// 		const i = permanent.indexOf(func);
// 		if (i >= 0) {
// 			permanent = permanent.slice();
// 			permanent.splice(i, 2);
// 			return true;
// 		}
// 		return false;
// 	};
// 	/**
// 	 * @description 添加一个一次性调用函数和参数（参数必须为数组）
// 	 * @example
// 	 */
// 	frame.setBefore = (func: Function, args?: any[]) => {
// 		func && before.push(func, args || []);
// 	};
// 	/**
// 	 * @description 添加一个一次性调用函数和参数（参数必须为数组）
// 	 * @example
// 	 */
// 	frame.setAfter = (func: Function, args?: any[]) => {
// 		func && after.push(func, args);
// 	};
// 	/**
// 	 * @description 添加一个一次性调用函数和参数（参数必须为数组）
// 	 * @example
// 	 */
// 	frame.setNext = (func: Function, args?: any[]) => {
// 		func && next.push(func, args);
// 	};
// 	/**
// 	 * @description 设置统计回调和统计间隔
// 	 * @example
// 	 */
// 	frame.setStat = (callback: Function, interval: number) => {
// 		statCallback = callback;
// 		statInterval = interval;
// 	};
// 	/**
// 	 * @description 获得当前的统计信息
// 	 * @example
// 	 */
// 	frame.getCurStat = () => {// json
// 		return curStat;
// 	};
// 	/**
// 	 * @description 获得最近的统计信息
// 	 * @example
// 	 */
// 	frame.getLastStat = () => {// json
// 		return lastStat;
// 	};
// 	return frame;
// };
// /**
//  * @description 获取全局帧管理器
//  * @example
//  */
// export const getGlobal = (): any => {
// 	if (!mgr) {
// 		mgr = create();
// 		setInterval(mgr);
// 	}
// 	return mgr;
// };
// /**
//  * @description 清除全局帧管理器
//  * @example
//  */
// export const clearGlobal = () => {
// 	if (mgr) {
// 		setInterval(mgr);
// 		mgr = null;
// 	}
// };
// const normalrRequestFrameImpl = (callback) => {
// 	return setTimeout(callback, ((1000 / 60) + 0.5) << 0);
// };
// // 获取raf函数，处理兼容性
// const requestFrameImpl = window.requestAnimationFrame || (<any>window).mozRequestAnimationFrame || window.webkitRequestAnimationFrame || (<any>window).msRequestAnimationFrame || normalrRequestFrameImpl;
// // tslint:disable:no-unnecessary-callback-wrapper
// export const requestFrame = callBack => requestFrameImpl(callBack);
// // 获取raf取消函数，处理兼容性
// const cancelFrameImpl = window.cancelAnimationFrame || (<any>window).mozCancelAnimationFrame || window.webkitCancelAnimationFrame || (<any>window).msCancelAnimationFrame || clearTimeout;
// export const cancelFrame = callBack => cancelFrameImpl(callBack);
// // ============================== 本地
// // 全局帧管理器
// let mgr: any;
// // 函数调用
// const funCall = (func, args) => {
// 	try {
// 		call(func, args);
// 	} catch (ex) {
// 		cc.warn() && log('frame, ex: ', ex, ', func: ', func);
// 	}
// 	return timeNow();
// };
// // ============================== 立即执行

// // 导入 =================================
// import { FileLoad, /*load, store*/ } from '../../../pi_sys/load/bin';
// import { Json } from '../../../pi_sys/modules/lang/type';
// import { utf8Decode } from '../../../pi_sys/modules/util/util';
// import { loadDir } from '../widget/util';
// import { bin2Json } from './readJsonBin';
_$pi.define("pi_gui/gui/gui_font/msdf_font", ["require", "exports"], function (require, exports) {
    "use strict";
});
// // 本地 =================================
// // 是否在微信小游戏环境中
// const isWXMiniGame = load.isWXMiniGame();
// const replaceImagePath = isWXMiniGame ?
//     pi_modules['pi/minigame/adapter'].exports.replaceImagePath :
//     undefined;
// interface CharInfoMap {
//     dir: string;
//     frequencyChar: string[];
//     otherChar: string[];
//     otherJsonFile: string[];
// }
// interface CanvasInfo {
//     canvas: HTMLCanvasElement;
//     width: number;
//     height: number;
//     curlineHeight: number;
//     curXOffset: number;
//     curYOffset: number;
// }
// interface FontMap {
//     canvasInfo: CanvasInfo;
//     chars: Json;
//     common: Json;
//     fontName: string;
// }
// // const charsetMap = {
// //     frequency: undefined,
// //     other: undefined
// // };
// const allFontMap = new Map<string, FontMap>(); // <fontName, fontMap>
// const allCharsetMap = new Map<string, Json>(); // <fontName, CharsetMap>
// const allCharInfoMap = new Map<string, CharInfoMap>(); // <fontName, CharInfoMap>
// const getFontMap = (fontName: string) => {
//     let fontMap: FontMap;
//     if (allFontMap.has(fontName)) {
//         fontMap = allFontMap.get(fontName);
//     } else {
//         fontMap = {
//             canvasInfo: {
//                 canvas: undefined,
//                 curlineHeight: 0,
//                 curXOffset: 0,
//                 curYOffset: 0,
//                 width: defaultWidth,
//                 height: defaultHeight
//             },
//             chars: {},
//             common: undefined,
//             fontName: fontName
//         };
//         initFontCanvas(fontMap);
//         allFontMap.set(fontName, fontMap);
//     }
//     return fontMap;
// };
// const getCharsetMap = (fontName: string) => {
//     let charsetMap;
//     if (allCharsetMap.has(fontName)) {
//         charsetMap = allCharsetMap.get(fontName);
//     } else {
//         charsetMap = { frequency: undefined };
//         allCharsetMap.set(fontName, charsetMap);
//     }
//     return charsetMap;
// };
// const getCharInfoMap = (fontName: string) => {
//     let charInfoMap: CharInfoMap;
//     if (allCharInfoMap.has(fontName)) {
//         charInfoMap = allCharInfoMap.get(fontName);
//     } else {
//         charInfoMap = {
//             dir: '',
//             frequencyChar: [],
//             otherChar: [],
//             otherJsonFile: []
//         };
//         fontName && allCharInfoMap.set(fontName, charInfoMap);
//     }
//     return charInfoMap;
// };
// /**
//  * 获取字体总配置文件文件
//  * 默认不同字体放在不同文件夹下，每个文件夹下也只有一个字体
//  * @param dir 构建出的字体相关文件所在文件夹
//  * @param callback 成功回调
//  * @example getJsonConfig('dist/', (charsetMap) => {}, (err) => {})
//  */
// const getJsonConfig = (dir: string, callback: (chars: any) => {}, errCallback: Function) => {
//     const charInfoMap = getCharInfoMap('');
//     if (!dir) {
//         dir = '';
//     } else if (!dir.endsWith('/')) {
//         dir += '/';
//     }
//     fetchFontCharInfo(dir, (info) => {
//         fetchFontJsonBin(dir, info, (data) => {
//             const [charset, fontName] = dealBinFiles(dir, data);
//             if (charset.frequency) {
//                 loadImages(charset.frequency.pages, fontName, (imgs) => {
//                     charset.frequency.pages = imgs;
//                     dealImgOfCharset(charset.frequency);
//                     callback(charset);
//                 }, errCallback);
//             } else {
//                 callback(charset);
//             }
//         }, errCallback);
//     }, errCallback);
//     charInfoMap.dir = dir;
// };
// const dealImgOfCharset = (charset: any, fontMap?: FontMap) => {
//     const { pages, chars } = charset;
//     Object.keys(chars).forEach((id) => {
//         const char = chars[id];
//         const idx = char.page;
//         if (typeof idx === 'object') return;
//         char.page = pages[idx];
//         fontMap && fontMap.chars[id] && (fontMap.chars[id].page = pages[idx]);
//     });
// };
// const fetchFontCharInfo = (dir: string, callback: Function, errCallback?: Function) => {
//     if (!callback) return new Error('no callback');
//     if (!dir.endsWith('/')) { dir += '/'; }
//     const path = `${dir}char_info.json`;
//     loadDir([path], {}, {}, { json: 'download' }, (data) => {
//         const getJsonBin = (data: ArrayBuffer) => {
//             const jsonString = utf8Decode(data);
//             const info = JSON.parse(jsonString);
//             callback(info);
//         };
//         if (!data[path]) {
//             const lstore = load.getStore();
//             store.read(lstore, path, (data) => {
//                 getJsonBin(data);
//             }, (err) => {
//                 errCallback && errCallback(err);
//             });
//             return;
//         }
//         getJsonBin(data[path]);
//     }, (err) => {
//         errCallback && errCallback(err);
//     });
// };
// /**
//  * 从store中读取文件
//  */
// const readStore = (fileList: string[], callback: Function, errCallback?: Function) => {
//     const lstore = load.getStore();
//     const wait = [];
//     fileList.forEach((file) => {
//         const p = new Promise((resolve, reject) => {
//             store.read(lstore, file, (data) => {
//                 resolve(data);
//             }, (err) => {
//                 reject(err);
//             });
//         });
//         wait.push(p);
//     });
//     Promise.all(wait).then((data) => {
//         callback(data);
//     }).catch((err) => {
//         errCallback(err);
//     });
// };
// /**
//  * 下载字体的二进制配置文件
//  */
// const fetchFontJsonBin = (dir: string, info: any, callback: Function, errCallback: Function) => {
//     const jsonBinFiles = [];
//     Object.keys(info).forEach((k) => {
//         jsonBinFiles.push(`${dir}${k}.json.bin`);
//     });
//     jsonBinFiles.push(`${dir}frequency.json.bin`);
//     loadDir(jsonBinFiles, {}, {}, { bin: 'download' }, (data) => {
//         if (Object.keys(data).length !== jsonBinFiles.length) {
//             callback(data);
//             return;
//         }
//         readStore(jsonBinFiles, (arrbufArr) => {
//             const json = {};
//             jsonBinFiles.forEach((file, idx) => {
//                 json[file] = arrbufArr[idx];
//             });
//             callback(json);
//         }, (err) => {
//             errCallback(err);
//         });
//     }, (err) => {
//         errCallback(err);
//     });
// };
// /**
//  * 读取二进制文件的内容并作相应处理
//  */
// const dealBinFiles = (dir: string, data: any) => {
//     let map: Json;
//     let name: string;
//     Object.keys(data).forEach((k) => {
//         const buf = data[k];
//         k = k.replace(dir, '').replace('.json.bin', '');
//         const char = bin2Json(buf);
//         const fontName = char.info.face;
//         const charsetMap = getCharsetMap(fontName);
//         const charsetInfo = { chars: {}, pages: [] };
//         char.chars.forEach((c) => {
//             if (!c) return;
//             charsetInfo.chars[c.id] = c;
//         });
//         charsetInfo.pages.push(...char.pages);
//         charsetMap[k] = charsetInfo;
//         const charInfoMap = getCharInfoMap(fontName);
//         charInfoMap.dir === dir || (charInfoMap.dir = dir);
//         const { charset } = char.info;
//         if (k === 'frequency') {
//             charInfoMap.frequencyChar = charset;
//             map = charsetMap;
//             name = fontName;
//         } else {
//             charInfoMap.otherJsonFile.push(k);
//             charInfoMap.otherChar.push(...charset);
//         }
//     });
//     return [map, name];
// };
// /**
//  * 加载字体json文件里pages中的图片文件
//  */
// const loadImages = (imgs: string[], fontName: string, callback: Function, errCallback: Function) => {
//     let count = 0;
//     let reportedError = false;
//     const len = imgs.length;
//     const imageNodes = [];
//     const charInfoMap = getCharInfoMap(fontName);
//     imgs = imgs.map((img) => charInfoMap.dir + img);
//     loadDir(imgs, {}, {}, { png: 'download' }, (data) => {
//         imgs.forEach((img, idx) => {
//             const node = new Image();
//             node.onload = () => {
//                 ++count;
//                 if (count !== len) return;
//                 callback(imageNodes);
//             };
//             imageNodes[idx] = node;
//             node.onerror = (err) => {
//                 if (!reportedError) return;
//                 reportedError = true;
//                 errCallback(err, img);
//             };
//             if (replaceImagePath) {
//                 replaceImagePath(img, (url) => {
//                     node.src = url
//                 }, errCallback);
//             } else if (data[img]) {
//                 const blob = new Blob([data[img]]);
//                 node.src = URL.createObjectURL(blob);
//             } else {
//                 const lstore = load.getStore();
//                 store.read(lstore, img, (arrBuf) => {
//                     const blob = new Blob([arrBuf]);
//                     node.src = URL.createObjectURL(blob);
//                 }, (err) => {
//                     errCallback(err, img);
//                 });
//             }
//         });
//     }, errCallback);
// };
// /**
//  * 按照字符串顺序返回字符串在canvas上的位置信息
//  */
// const getCharsPosition = (str: string|number[], fontMap: FontMap) => {
//     const pos = [];
//     const { chars } = fontMap;
//     let charArr: number[]|string[];
//     if (typeof str === 'string') {
//         charArr = str.split('');
//     } else {
//         charArr = str;
//     }
//     charArr.forEach((char, idx) => {
//         const charCode = typeof char === 'string' ? char.charCodeAt(0) : char;
//         const info = chars[charCode];
//         if (info) {
//             pos[idx] = info;
//         } else {
//             pos[idx] = {
//                 id: charCode,
//                 advance: 0,
//                 x: 0,
//                 y: 0,
//                 xoffset: 0,
//                 yoffset: 0,
//                 width: 0,
//                 height: 0
//             };
//         }
//     });
//     return pos;
// };
// /**
//  * 将需要的文字绘制到特定canvas上
//  * @param str       要用到的字符组成的字符串或字符unicode码的数组
//  * @param callback  生成完成回调(canvas: HTMLCanvasElement, updatedCharCodeArr: Uint32Array)
//  * @example buildFont('string I want use', 'fontName', (canvas, [renderCharCode: Uint32Array]) => {}) => [CharInfo]
//  */
// const buildFont = (
//     str: string|number[], fontName: string,
//     callback: (canvas:HTMLCanvasElement, chars: ArrayBuffer) => void,
//     errCallback?: Function
// ) => {
//     let resizeCanvas = false;
//     let needFetchImage = false;
//     const waitChars: number[] = [];
//     const failChars: number[] = [];
//     const fontMap = getFontMap(fontName);
//     const tmpFontMap = <FontMap>deepCopy(fontMap);
//     tmpFontMap.canvasInfo.canvas = fontMap.canvasInfo.canvas;
//     const doRender = () => {
//         renderCanvas(waitChars, tmpFontMap, resizeCanvas);
//         allFontMap.set(fontName, tmpFontMap);
//         const arrbuf = new ArrayBuffer(waitChars.length * 4);
//         const u32 = new Uint32Array(arrbuf);
//         waitChars.forEach((code, idx) => {
//             u32[idx] = code;
//         });
//         callback(tmpFontMap.canvasInfo.canvas, u32);
//     };
//     const charArr = typeof str === 'string' ? str.split('') : str;
//     charArr.forEach((char) => {
//         let charset: any;
//         // const code = typeof char === 'string' ? char.charCodeAt(0) : char;
//         let code: number;
//         if (typeof char === 'string') {
//             code = char.charCodeAt(0);
//         } else {
//             code = char;
//             char = String.fromCharCode(code);
//         }
//         if (tmpFontMap && tmpFontMap.chars[code]) return;
//         const charsetMap = getCharsetMap(fontName);
//         const charInfoMap = getCharInfoMap(fontName);
//         if (charInfoMap.frequencyChar.indexOf(char) > -1) {
//             charset = charsetMap.frequency;
//         } else if (charInfoMap.otherChar.indexOf(char) > -1) {
//             const fileName = getCharInWhichJson(char, charInfoMap.otherJsonFile);
//             charset = charsetMap[fileName];
//             if (typeof charset.pages[0] === 'string') {
//                 needFetchImage = true;
//                 loadImages(charset.pages, fontName, (imgs) => {
//                     charset.pages = imgs;
//                     dealImgOfCharset(charset, tmpFontMap);
//                     doRender();
//                 }, errCallback);
//             }
//         } else {
//             failChars.push(code);
//             return;
//         }
//         const result = calcCharPos(code, tmpFontMap, charset);
//         // 不再扩大canvas
//         if (result === null) {
//             failChars.push(code);
//         } else {
//             waitChars.push(code);
//         }
//         if (result) { resizeCanvas = result; }
//     });
//     if (!needFetchImage) {
//         doRender();
//     }
//     return getCharsPosition(str, tmpFontMap);
// };
// const renderCanvas = (charCodeArr: number[], fontMap: FontMap, resizeCanvas: boolean) => {
//     const { chars, canvasInfo } = fontMap;
//     const { canvas } = canvasInfo;
//     if (!resizeCanvas) {
//         charCodeArr.forEach((charCode) => {
//             const { width, height, x, y, page, oix, oiy } = chars[charCode];
//             const ctx = canvas.getContext('2d');
//             ctx.drawImage(page, oix, oiy, width, height, x, y, width, height);
//         });
//         return;
//     }
//     const tmpCanvas = document.createElement('canvas');
//     tmpCanvas.id = canvas.id;
//     tmpCanvas.width = canvasInfo.width;
//     tmpCanvas.height = canvasInfo.height;
//     const ctx = tmpCanvas.getContext('2d');
//     Object.keys(chars).forEach((id) => {
//         const { width, height, x, y, page, oix, oiy } = chars[id];
//         if (!page || typeof page === 'number') return;
//         ctx.drawImage(page, oix, oiy, width, height, x, y, width, height);
//     });
//     canvasInfo.canvas = tmpCanvas;
// };
// /**
//  * 深拷贝
//  */
// const deepCopy = (src: Json) => {
//     const result = {};
//     Object.keys(src).forEach((k) => {
//         if (typeof src[k] === 'object') {
//             result[k] = deepCopy(src[k]);
//         } else {
//             result[k] = src[k];
//         }
//     });
//     return result;
// };
// const calcCharPos = (char: string|number, fontMap: FontMap, charset: Json) => {
//     let resizeCanvas = false;
//     const charCode = typeof char === 'string' ? char.charCodeAt(0) : char;
//     const { canvasInfo, chars } = fontMap;
//     const { width, height } = canvasInfo;
//     const charInfo = charset.chars[charCode] || chars[charCode];
//     const newline = charInfo.width + canvasInfo.curXOffset > width;
//     let contextHeight = charInfo.height + canvasInfo.curYOffset;
//     if (newline) {
//         contextHeight += canvasInfo.curlineHeight;
//     }
//     if (height < contextHeight) {
//         // 不再扩大canvas
//         return null;
//         // 需扩大并重新绘制canvas，重新计算所有字符位置
//         canvasInfo.width *= 2;
//         canvasInfo.height *= 2;
//         canvasInfo.curXOffset = 0;
//         canvasInfo.curYOffset = 0;
//         canvasInfo.curlineHeight = 0;
//         resizeCanvas = true;
//         Object.keys(chars).forEach((c) => {
//             calcCharPos(chars[c].id, fontMap, charset);
//         });
//     }
//     let x = 0, y = 0;
//     if (newline) {
//         x = 0;
//         y = canvasInfo.curYOffset + canvasInfo.curlineHeight;
//         canvasInfo.curlineHeight = charInfo.height;
//         canvasInfo.curXOffset = charInfo.width;
//         canvasInfo.curYOffset = y;
//     } else {
//         x = canvasInfo.curXOffset;
//         y = canvasInfo.curYOffset;
//         canvasInfo.curXOffset += charInfo.width;
//     }
//     if (canvasInfo.curlineHeight < charInfo.height) {
//         canvasInfo.curlineHeight = charInfo.height;
//     }
//     const oix = charInfo.oix === undefined ? charInfo.x : charInfo.oix;
//     const oiy = charInfo.oiy === undefined ? charInfo.y : charInfo.oiy;
//     const item = { ...charInfo,  x, y, oix, oiy };
//     chars[charCode] = item;
//     return resizeCanvas;
// };
// /**
//  * 查找字符在那个不常用json文件内
//  * @param char      要查找的字符串
//  * @param jsonFiles 不常用字符串json文件名列表，其格式为"start_end"
//  *                  其中start为该json文件中最小的unicode编码值，end为最大值
//  */
// const getCharInWhichJson = (char: string, jsonFiles: string[]) => {
//     const charCode = char.charCodeAt(0);
//     let fileName = '';
//     for (const file of jsonFiles) {
//         const [s, e] = file.split('_');
//         const start = parseInt(s, 10);
//         const end = parseInt(e, 10);
//         if (charCode >= start && charCode <= end) {
//             fileName = file;
//             break;
//         }
//     }
//     return fileName;
// };
// /**
//  * 初始化绘制字体的canvas
//  * @param width     宽(最好为2的幂)
//  * @param height    高(最好为2的幂)
//  */
// const initFontCanvas = (fontMap: FontMap) => {
//     const { width, height } = fontMap.canvasInfo;
//     const id = `__${fontMap.fontName}_fontCanvas__`;
//     let canvas = <HTMLCanvasElement>document.getElementById(id);
//     if (!canvas) {
//         canvas = document.createElement('canvas');
//         canvas.id = id;
//     }
//     canvas.width = width;
//     canvas.height = height;
//     if (fontMap && fontMap.canvasInfo && fontMap.canvasInfo.canvas) return;
//     fontMap.canvasInfo.canvas = canvas;
// };
// // 导出 =============================
// export { buildFont, getJsonConfig };
// // 立即执行 =========================
// // canvas默认宽高
// const defaultWidth = 1024;
// const defaultHeight = 1024;
// // 调试用
// (<any>window).allCharsetMap = allCharsetMap;
// (<any>window).allCharInfoMap = allCharInfoMap;
// (<any>window).allFontMap = allFontMap;
// // (<any>window).buildFont = buildFont;
// // (<any>window).getJsonConfig = getJsonConfig;

_$pi.define("pi_gui/widget/scroller/scroller", ["require", "exports", "../../widget/event", "../../../pi_sys/modules/util/frame_mgr", "../../widget/painter", "./dom", "./ease", "./util"], function (require, exports, event_1, frame_mgr_1, painter_1, dom_1, ease_1, util_1) {
    "use strict";
    
    // ====================================== 常量声明
    const TOUCH_EVENT = 1;
    const scrollerInstanceMap = new Map();
    // ====================================== 导出
    exports.pluginBind = (w, vNode, args, oldArgs) => {
        const scrollerInstance = scrollerInstanceMap.get(args.options.id);
        const bScroller = new BScroll(w, vNode, args.options);
        scrollerInstanceMap.set(args.options.id, bScroller);
        /* if (!scrollerInstance) {
            const bScroller = new BScroll(w, vNode, <Options>args.options);
            scrollerInstanceMap.set(args.options.id, bScroller);
        } else {
            scrollerInstance.update(<Options>args.options, vNode);
            console.log(`id : ${args.options.id}已经存在, 直接可用`);
        } */
    };
    class BScroll {
        constructor(w, vNode, options) {
            this.x = 0;
            this.y = 0;
            this.directionX = 0;
            this.directionY = 0;
            this.parentWidget = w;
            const tempAttach = w.attach;
            w.attach = () => {
                tempAttach();
                this.update(options, vNode);
            };
            const tempAfterupdate = w.afterUpdate;
            w.afterUpdate = () => {
                tempAfterupdate();
                this.refresh();
            };
            // cache style for better performance    
        }
        // tslint:disable:typedef no-object-literal-type-assertion
        update(options, vNode) {
            this.wrapper = painter_1.getRealNode(vNode);
            this.scroller = painter_1.getRealNode(vNode).children[0];
            this.options = {
                startX: 0,
                startY: 0,
                scrollX: false,
                scrollY: true,
                directionLockThreshold: 5,
                momentum: true,
                bounce: true,
                swipeTime: 2500,
                bounceTime: 700,
                swipeBounceTime: 1200,
                deceleration: 0.001,
                momentumLimitTime: 300,
                momentumLimitDistance: 15,
                resizePolling: 60,
                preventDefault: true,
                preventDefaultException: {
                    tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/
                },
                bindToWrapper: true,
                HWCompositing: true,
                useTransition: true,
                useTransform: true,
                probeType: 3
            };
            util_1.extend(this.options, options);
            this.translateZ = this.options.HWCompositing && dom_1.hasPerspective ? ' translateZ(0)' : '';
            this.options.useTransition = this.options.useTransition && dom_1.hasTransition;
            this.options.useTransform = this.options.useTransform && dom_1.hasTransform;
            this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
            this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;
            // If you want eventPassthrough I have to lock one of the axes
            this.options.scrollX = this.options.eventPassthrough === 'horizontal' ? false : this.options.scrollX;
            this.options.scrollY = this.options.eventPassthrough === 'vertical' ? false : this.options.scrollY;
            // With eventPassthrough we also need lockDirection mechanism
            this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
            this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;
            if (this.options.tap === true) {
                this.options.tap = 'tap';
            }
            this._init();
            this.refresh();
            this.scrollTo(this.options.startX, this.options.startY);
            this.enable();
        }
        // tslint:disable:function-name
        _init() {
            this.x = 0;
            this.y = 0;
            this.directionX = 0;
            this.directionY = 0;
            this._addEvents();
        }
        _addEvents() {
            const eventOperation = dom_1.addEvent;
            this._handleEvents(eventOperation);
        }
        _removeEvents() {
            const eventOperation = dom_1.removeEvent;
            this._handleEvents(eventOperation);
        }
        _handleEvents(eventOperation) {
            const target = this.options.bindToWrapper ? this.wrapper : window;
            eventOperation(window, 'orientationchange', this);
            eventOperation(window, 'resize', this);
            if (this.options.click) {
                eventOperation(this.wrapper, 'click', this);
            }
            if (!this.options.disableMouse) {
                eventOperation(this.wrapper, 'mousedown', this);
                eventOperation(target, 'mousemove', this);
                eventOperation(target, 'mousecancel', this);
                eventOperation(target, 'mouseup', this);
            }
            if (dom_1.hasTouch && !this.options.disableTouch) {
                eventOperation(this.wrapper, 'touchstart', this);
                eventOperation(target, 'touchmove', this);
                eventOperation(target, 'touchcancel', this);
                eventOperation(target, 'touchend', this);
            }
            eventOperation(this.scroller, dom_1.style.transitionEnd, this);
        }
        _start(e) {
            // tslint:disable:variable-name
            const _eventType = dom_1.eventType[e.type];
            if (_eventType !== TOUCH_EVENT) {
                if (e.button !== 0) {
                    return;
                }
            }
            if (!this.enabled || this.destroyed || (this.initiated && this.initiated !== _eventType)) {
                return;
            }
            this.initiated = _eventType;
            if (this.options.preventDefault && !util_1.isBadAndroid && !dom_1.preventDefaultException(e.target, this.options.preventDefaultException)) {
                e.preventDefault();
            }
            this.moved = false;
            this.distX = 0;
            this.distY = 0;
            this.directionX = 0;
            this.directionY = 0;
            this.directionLocked = 0;
            this._transitionTime();
            this.startTime = +new Date();
            if (this.options.useTransition && this.isInTransition) {
                this.isInTransition = false;
                const pos = this.getComputedPosition();
                this._translate(pos.x, pos.y);
                if (this.parentWidget.tree) {
                    event_1.notify(this.parentWidget.tree, 'ev-scroller-scrollend', { id: this.options.id, x: this.x, y: this.y, instance: this });
                }
            }
            const point = e.touches ? e.touches[0] : e;
            this.startX = this.x;
            this.startY = this.y;
            this.absStartX = this.x;
            this.absStartY = this.y;
            this.pointX = point.pageX;
            this.pointY = point.pageY;
            if (this.parentWidget.tree) {
                event_1.notify(this.parentWidget.tree, 'ev-scroller-beforescrollstart', { id: this.options.id, x: this.x, y: this.y, instance: this });
            }
        }
        // tslint:disable-next-line:cyclomatic-complexity
        _move(e) {
            if (!this.enabled || this.destroyed || dom_1.eventType[e.type] !== this.initiated) {
                return;
            }
            if (this.options.preventDefault) {
                e.preventDefault();
            }
            const point = e.touches ? e.touches[0] : e;
            let deltaX = point.pageX - this.pointX;
            let deltaY = point.pageY - this.pointY;
            this.pointX = point.pageX;
            this.pointY = point.pageY;
            this.distX += deltaX;
            this.distY += deltaY;
            const absDistX = Math.abs(this.distX);
            const absDistY = Math.abs(this.distY);
            const timestamp = +new Date();
            // We need to move at least 15 pixels for the scrolling to initiate
            if (timestamp - this.endTime > this.options.momentumLimitTime &&
                (absDistY < this.options.momentumLimitDistance && absDistX < this.options.momentumLimitDistance)) {
                return;
            }
            // If you are scrolling in one direction lock the other
            if (!this.directionLocked && !this.options.freeScroll) {
                if (absDistX > absDistY + this.options.directionLockThreshold) {
                    this.directionLocked = 'h'; // lock horizontally
                }
                else if (absDistY >= absDistX + this.options.directionLockThreshold) {
                    this.directionLocked = 'v'; // lock vertically
                }
                else {
                    this.directionLocked = 'n'; // no lock
                }
            }
            if (this.directionLocked === 'h') {
                if (this.options.eventPassthrough === 'vertical') {
                    e.preventDefault();
                }
                else if (this.options.eventPassthrough === 'horizontal') {
                    this.initiated = false;
                    return;
                }
                deltaY = 0;
            }
            else if (this.directionLocked === 'v') {
                if (this.options.eventPassthrough === 'horizontal') {
                    e.preventDefault();
                }
                else if (this.options.eventPassthrough === 'vertical') {
                    this.initiated = false;
                    return;
                }
                deltaX = 0;
            }
            deltaX = this.hasHorizontalScroll ? deltaX : 0;
            deltaY = this.hasVerticalScroll ? deltaY : 0;
            let newX = this.x + deltaX;
            let newY = this.y + deltaY;
            // Slow down or stop if outside of the boundaries
            if (newX > 0 || newX < this.maxScrollX) {
                if (this.options.bounce) {
                    newX = this.x + deltaX / 3;
                }
                else {
                    newX = newX > 0 ? 0 : this.maxScrollX;
                }
            }
            if (newY > 0 || newY < this.maxScrollY) {
                if (this.options.bounce) {
                    newY = this.y + deltaY / 3;
                }
                else {
                    newY = newY > 0 ? 0 : this.maxScrollY;
                }
            }
            // this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
            // this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;
            this._move1(e, newX, newY, timestamp);
        }
        _move1(e, newX, newY, timestamp) {
            if (!this.moved) {
                this.moved = true;
                if (this.parentWidget.tree) {
                    event_1.notify(this.parentWidget.tree, 'ev-scroller-scrollstart', { id: this.options.id, x: this.x, y: this.y, instance: this });
                }
            }
            this._translate(newX, newY);
            if (timestamp - this.startTime > this.options.momentumLimitTime) {
                this.startTime = timestamp;
                this.startX = this.x;
                this.startY = this.y;
                if (this.options.probeType === 1) {
                    event_1.notify(this.parentWidget.tree, 'ev-scroller-scroll', { id: this.options.id, x: this.x, y: this.y, instance: this });
                }
            }
            if (this.options.probeType > 1) {
                event_1.notify(this.parentWidget.tree, 'ev-scroller-scroll', { id: this.options.id, x: this.x, y: this.y, instance: this });
            }
            const scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft;
            const scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
            const pX = this.pointX - scrollLeft;
            const pY = this.pointY - scrollTop;
            if (pX > document.documentElement.clientWidth - this.options.momentumLimitDistance || pX < this.options.momentumLimitDistance ||
                pY < this.options.momentumLimitDistance || pY > document.documentElement.clientHeight - this.options.momentumLimitDistance) {
                this._end(e);
            }
        }
        // tslint:disable-next-line:cyclomatic-complexity
        _end(e) {
            if (!this.enabled || this.destroyed || dom_1.eventType[e.type] !== this.initiated) {
                return;
            }
            this.initiated = false;
            if (this.options.preventDefault && !dom_1.preventDefaultException(e.target, this.options.preventDefaultException)) {
                e.preventDefault();
            }
            if (this.parentWidget.tree) {
                event_1.notify(this.parentWidget.tree, 'ev-scroller-touchend', { id: this.options.id, x: this.x, y: this.y, instance: this });
            }
            // reset if we are outside of the boundaries
            if (this.resetPosition(this.options.bounceTime, ease_1.ease.bounce)) {
                return;
            }
            this.isInTransition = false;
            // ensures that the last position is rounded
            let newX = Math.round(this.x);
            let newY = Math.round(this.y);
            // we scrolled less than 15 pixels
            if (!this.moved) {
                if (this.options.tap) {
                    dom_1.tap(e, this.options.tap);
                }
                if (this.options.click) {
                    dom_1.click(e);
                }
                if (this.parentWidget.tree) {
                    event_1.notify(this.parentWidget.tree, 'ev-scroller-scrollcancel', { id: this.options.id, x: this.x, y: this.y, instance: this });
                }
                return;
            }
            this.scrollTo(newX, newY);
            const deltaX = newX - this.absStartX;
            const deltaY = newY - this.absStartY;
            this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
            this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;
            this.endTime = +new Date();
            const duration = this.endTime - this.startTime;
            const absDistX = Math.abs(newX - this.startX);
            const absDistY = Math.abs(newY - this.startY);
            // fastclick
            if (duration < this.options.momentumLimitTime && absDistX < this.options.momentumLimitDistance &&
                absDistY < this.options.momentumLimitDistance) {
                if (this.parentWidget.tree) {
                    event_1.notify(this.parentWidget.tree, 'ev-scroller-flick', { id: this.options.id, x: this.x, y: this.y, instance: this });
                }
                return;
            }
            let time = 0;
            // start momentum animation if needed
            if (this.options.momentum && duration < this.options.momentumLimitTime &&
                (absDistY > this.options.momentumLimitDistance || absDistX > this.options.momentumLimitDistance)) {
                const momentumX = this.hasHorizontalScroll ? util_1.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ?
                    this.wrapperWidth : 0, this.options)
                    : { destination: newX, duration: 0 };
                const momentumY = this.hasVerticalScroll ? util_1.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ?
                    this.wrapperHeight : 0, this.options)
                    : { destination: newY, duration: 0 };
                newX = momentumX.destination;
                newY = momentumY.destination;
                time = Math.max(momentumX.duration, momentumY.duration);
                this.isInTransition = 1;
            }
            let easing = ease_1.ease.swipe;
            if (newX !== this.x || newY !== this.y) {
                // change easing function when scroller goes out of the boundaries
                if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
                    easing = ease_1.ease.swipeBounce;
                }
                this.scrollTo(newX, newY, time, easing);
                return;
            }
            if (this.parentWidget.tree) {
                event_1.notify(this.parentWidget.tree, 'ev-scroller-scrollend', { id: this.options.id, x: this.x, y: this.y, instance: this });
            }
        }
        _resize() {
            if (!this.enabled) {
                return;
            }
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.refresh();
            }, this.options.resizePolling);
        }
        _startProbe() {
            frame_mgr_1.cancelFrame(this.probeTimer);
            this.probeTimer = frame_mgr_1.requestFrame(probe);
            // tslint:disable:no-this-assignment
            const me = this;
            // tslint:disable:only-arrow-functions
            function probe() {
                const pos = me.getComputedPosition();
                if (me.parentWidget.tree) {
                    event_1.notify(me.parentWidget.tree, 'ev-scroller-scroll', { id: me.options.id, x: pos.x, y: pos.y, instance: me });
                }
                if (me.isInTransition) {
                    me.probeTimer = frame_mgr_1.requestFrame(probe);
                }
            }
        }
        _transitionTime(time = 0) {
            // tslint:disable:prefer-template
            painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionDuration, time + 'ms');
            // this.scroller.style[style.transitionDuration] = time + 'ms';
            if (!time && util_1.isBadAndroid) {
                painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionDuration, '0.001s');
                // this.scroller.style[style.transitionDuration] = '0.001s';					
                frame_mgr_1.requestFrame(() => {
                    if (this.scroller.style[dom_1.style.transitionDuration] === '0.0001ms') {
                        painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionDuration, '0s');
                        // this.scroller.style[style.transitionDuration] = '0s';
                    }
                });
            }
        }
        _transitionTimingFunction(easing) {
            // console.log(`easing is ${easing}`);
            painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionTimingFunction, easing);
            // this.scroller.style[style.transitionTimingFunction] = easing;
        }
        _transitionEnd(e) {
            if (e.target !== this.scroller || !this.isInTransition) {
                return;
            }
            this._transitionTime();
            if (!this.resetPosition(this.options.bounceTime, ease_1.ease.bounce)) {
                this.isInTransition = false;
                if (this.parentWidget.tree) {
                    event_1.notify(this.parentWidget.tree, 'ev-scroller-scrollend', { id: this.options.id, x: this.x, y: this.y, instance: this });
                }
            }
        }
        _translate(x, y) {
            if (this.options.useTransform) {
                painter_1.paintCmd3(this.scroller.style, dom_1.style.transform, 'translate(' + x + 'px,' + y + 'px)' + this.translateZ);
                // this.scroller.style[style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;
            }
            else {
                x = Math.round(x);
                y = Math.round(y);
                painter_1.paintCmd3(this.scroller.style, 'left', x + 'px');
                painter_1.paintCmd3(this.scroller.style, 'top', y + 'px');
                // this.scroller.style.left = x+"px";
                // this.scroller.style.top = y+"px";
            }
            this.x = x;
            this.y = y;
        }
        enable() {
            this.enabled = true;
        }
        disable() {
            this.enabled = false;
        }
        refresh() {
            const rf = this.wrapper.offsetHeight;
            // tslint:disable:radix
            this.wrapperWidth = parseInt(this.wrapper.style.width) || this.wrapper.clientWidth;
            this.wrapperHeight = parseInt(this.wrapper.style.height) || this.wrapper.clientHeight;
            this.scrollerWidth = parseInt(this.scroller.style.width) || this.scroller.clientWidth;
            this.scrollerHeight = parseInt(this.scroller.style.height) || this.scroller.clientHeight;
            this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
            this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
            this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
            this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;
            if (!this.hasHorizontalScroll) {
                this.maxScrollX = 0;
                this.scrollerWidth = this.wrapperWidth;
            }
            if (!this.hasVerticalScroll) {
                this.maxScrollY = 0;
                this.scrollerHeight = this.wrapperHeight;
            }
            this.endTime = 0;
            this.directionX = 0;
            this.directionY = 0;
            this.wrapperOffset = dom_1.offset(this.wrapper);
            if (this.parentWidget.tree) {
                event_1.notify(this.parentWidget.tree, 'ev-scroller-refresh', { id: this.options.id, x: this.x, y: this.y, instance: this });
            }
            this.resetPosition();
        }
        resetPosition(time = 0, easeing = ease_1.ease.bounce) {
            let x = this.x;
            if (!this.hasHorizontalScroll || x > 0) {
                x = 0;
            }
            else if (x < this.maxScrollX) {
                x = this.maxScrollX;
            }
            let y = this.y;
            if (!this.hasVerticalScroll || y > 0) {
                y = 0;
            }
            else if (y < this.maxScrollY) {
                y = this.maxScrollY;
            }
            if (x === this.x && y === this.y) {
                return false;
            }
            this.scrollTo(x, y, time, easeing);
            return true;
        }
        scrollTo(x, y, time, easing) {
            if (!easing) {
                // easing = ease.bounce
                easing = ease_1.ease.swipe;
            }
            this.isInTransition = this.options.useTransition && time > 0 && (x !== this.x || y !== this.y);
            if (!time || this.options.useTransition) {
                this._transitionTimingFunction(easing.style);
                this._transitionTime(time);
                this._translate(x, y);
                if (time && this.options.probeType === 3) {
                    this._startProbe();
                }
            }
        }
        getComputedPosition() {
            let matrix = window.getComputedStyle(this.scroller, null);
            let x;
            let y;
            if (this.options.useTransform) {
                matrix = matrix[dom_1.style.transform].split(')')[0].split(', ');
                x = +(matrix[12] || matrix[4]);
                y = +(matrix[13] || matrix[5]);
            }
            else {
                x = +matrix.left.replace(/[^-\d.]/g, '');
                y = +matrix.top.replace(/[^-\d.]/g, '');
            }
            return {
                x,
                y
            };
        }
        destroy() {
            this._removeEvents();
            this.destroyed = true;
            if (this.parentWidget.tree) {
                event_1.notify(this.parentWidget.tree, 'ev-scroller-destroy', { id: this.options.id, x: this.x, y: this.y, instance: this });
            }
        }
        handleEvent(e) {
            switch (e.type) {
                case 'touchstart':
                case 'mousedown':
                    this._start(e);
                    break;
                case 'touchmove':
                case 'mousemove':
                    this._move(e);
                    break;
                case 'touchend':
                case 'mouseup':
                case 'touchcancel':
                case 'mousecancel':
                    this._end(e);
                    break;
                case 'orientationchange':
                case 'resize':
                    this._resize();
                    break;
                case 'transitionend':
                case 'webkitTransitionEnd':
                case 'oTransitionEnd':
                case 'MSTransitionEnd':
                    this._transitionEnd(e);
                    break;
                case 'click':
                    if (this.enabled && !e._constructed && !(/(SELECT|INPUT|TEXTAREA)/i).test(e.target.tagName)) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    break;
                default:
            }
        }
    }
    exports.BScroll = BScroll;
});

// // 模块描述
// /*
// 负责显示逻辑，是数据和原始dom间的桥梁
// 组件支持嵌套，并且tpl中的自定义元素支持相对路径。 
// 组件名的规则：可以使用英文小写字母加'_'和''。 '-'表示路径分隔，'$'只能在最后，1个'$'表示本目录开始查找，N个'$'表示上溯N-1个父目录开始查找。如果没有'$'表示从根目录下开始查找
// 举例：
// <role_show$ style=""></role_show$>表示本目录下的role_show组件，
// <role_show$$ style=""> </role_show$$>表示父目录下的role_show组件，
// <role_show-zb_show$$ style=""></role_show-zb_show$$>表示父目录下role_show目录下的zb_show组件
// <app-base-btn style=""></app-base-btn>表示根目录开始，app/base目录下的btn组件
// */
// // tslint:disable-next-line:no-reference
// /// <reference path="../render3d/babylon/babylon.d.ts"/>
_$pi.define("pi_gui/widget/widget_gui", ["require", "exports"], function (require, exports) {
    "use strict";
});
// // ============================== 导入
// import { Json } from '../lang/type';
// import { IAnimationCfg, IAnimData } from '../render3d/babylon/gui_anim_base';
// import { GUIAnimController } from '../render3d/babylon/gui_anim_controller';
// import { EventType, IGUIEvent, IGUIEventCfg, IGUIStyleCfg } from '../render3d/babylon/gui_base';
// import { GUICreator } from '../render3d/babylon/gui_creator';
// import { RootManager } from '../ui/root_gui';
// import { HandlerTable } from '../util/event';
// import { logLevel } from '../util/log';
// import { ResTab } from '../util/res_mgr';
// import { setValue } from '../util/util';
// import { Forelet } from './forelet_gui';
// import { Sheet } from './style';
// import { WIDGET_ONOFF_TIME } from './widget_manager';
// // ============================== 导出
// // tslint:disable-next-line:interface-name
// export interface WidgetPopCfg {
//     /**
//      * 打开的界面名称
//      */
//     name: string;
//     /**
//      * 打开操作的发起界面
//      */
//     fromW: Widget;
//     /**
//      * 被打开的界面
//      */
//     popW: Widget;
//     backCall: Function;
//     closeCall: Function;
//     cancelCall: Function;
// }
// // tslint:disable-next-line:interface-name
// export interface IWidgetGUICfg {
//     /**
//      * 基本节点类型名称
//      */
//     // tslint:disable-next-line:no-reserved-keywords
//     type?: string;
//     /**
//      * 子组件名称
//      */
//     w_tag?: string;
//     /**
//      * 节点样式设置
//      */
//     style?: IGUIStyleCfg;
//     /**
//      * 节点事件配置
//      * 
//      * * events: { click: [函数名,参数,事件配置] }
//      */
//     events?: IGUIEventCfg;
//     /**
//      * 向子组件节点传入的数据
//      */
//     it?: any;
//     // it1?: any;
//     /**
//      * 子节点数组
//      */
//     children?: IWidgetGUICfg[];
//     w_class?: string[];
//     /**
//      * 节点动画数据配置
//      */
//     animations?: IAnimationCfg[];
//     /**
//      * * 节点是否为静态节点，内容不会变化
//      * * 作为子组件，组件节点的更新是否不依赖父节点传入的数据
//      */
//     isStatic?: boolean;
// }
// /**
//  * 界面打开关闭动画配置
//  */
// // tslint:disable-next-line:interface-name
// export  interface IWidgetONOFFAnim {
//     vCenter_cfg?: number[];
//     vCenter_math?: string | Function | number[];
//     hCenter_cfg?: number[];
//     hCenter_math?: string | Function | number[];
//     alpha_cfg?: number[];
//     alpha_math?: string | Function | number[];
//     scale_cfg?: number[];
//     scale_math?: string | Function | number[];
//     time?: number;
// }
// // ============================== 导出
// export let level = logLevel;
// /**
//  * @description tpl定义
//  */
// // tslint:disable-next-line:interface-name
// export interface Tpl {
//     value: Function;
//     path: string; // 路径
//     wpath: string; // 组件路径
// }
// export const DestroyFlag = {
//     normal: 0,
//     readyForLoop: 1,
//     destroyed: 2
// };
// /**
//  * @description 组件
//  * @example
//  * 组件，包含样式和模板的js类,
//  * 注意区分 widget实例和widget节点
//  * widget节点的link属性指向了widget实例
//  */
// export class Widget extends HandlerTable {
//     /**
//      * 由父组件设置的组件属性
//      */
//     // public props: Json; 
//     public get props() {
//         if (!this._props) {
//             console.error('_props undefined!?');
//         }
//         return this._props;
//     }
//     public set props(value: Json) {
//         if (value.__ob__ === undefined) {
//             console.error('cannot set props');
//         }
//     }
//     /**
//      * 由forelet设置的组件状态
//      */
//     // public state: Json; 
//     public get state() {
//         if (!this._state) {
//             console.error('_state undefined!? 使用 isDestroyed 判断是否已销毁。');
//         }
//         return this._state;
//     }
//     public set state(value: Json) {
//         console.error('cannot set state');
//     }
//     public set isDestroyed(value: number) {
//         this._isDestroyed = value;
//         this.children.forEach(w => {
//             w.isDestroyed = DestroyFlag.readyForLoop;
//         });
//     }
//     public get isDestroyed() {
//         return this._isDestroyed;
//     }
//     public static ImageResTab: ResTab = new ResTab();
//     public static DebugCmd: boolean = false;
//     /**
//      * 组件的名称
//      */
//     public name: string; 
//     /*
//      * 组件的样式
//      */
//     public sheet: { value: Sheet }; 
//     /**
//      * 所对应的初始配置
//      */
//     public config: { value: Json }; 
//     /**
//      * 对应的forelet
//      */
//     public forelet: Forelet; 
//     /**
//      * 组件所对应的 GUI 节点描述树
//      */
//     public tree: any; 
//     /**
//      * 父组件所定义 组件节点属性
//      */
//     public style: any;
//     /**
//      * 父 GUI 节点
//      */
//     public parentNode: BABYLON.GUI.Container; 
//     /**
//      * 父 GUI 节点
//      */
//     public parent: Widget; 
//     /**
//      * 子组件列表
//      */
//     public children: Widget[]; 
//     /**
//      * 是否在dom树中
//      */
//     public inDomTree: boolean = false; 
//     /**
//      * 资源表
//      */
//     public resTab: ResTab; 
//     /**
//      * 资源缓冲时间，默认3秒
//      */
//     public resTimeout: number; 
//     /**
//      * 样式查询缓存
//      */
//     public styleCache: Sheet; 
//     /**
//      * 组件根节点
//      */
//     public control: BABYLON.GUI.Container;
//     /**
//      * 被其他组件打开的记录
//      */
//     public popFrom: WidgetPopCfg;
//     /**
//      * 打开其他界面的记录
//      */
//     public popMap: Map<string, WidgetPopCfg> = new Map();
//     /**
//      * 自定义通信事件
//      */
//     public guiEventMap: Map<string, Function> = new Map();
//     /**
//      * 是否为中间容器
//      */
//     public isTempContainer: boolean = false;
//     /**
//      * 动画列表
//      */
//     public animationMap: Map<BABYLON.GUI.Control, Map<string, IAnimationCfg>> = new Map();
//     /**
//      * 打开动画
//      */
//     public openAnim: IAnimData;
//     /**
//      * 关闭动画
//      */
//     public closeAnim: IAnimData;
//     /**
//      * 页面是否可操作
//      */
//     public isEnable: boolean;
//     /**
//      * 页面 不可视的延时句柄
//      */
//     public disVisibleHandler: any;
//     /**
//      * 组件自己控制的 可见与不可见
//      */
//     public visible: boolean;
//     public isReady: boolean = false;
//     public updateID: number = 0;
//     public destroyID: number = 0;
//     private _isDestroyed: number = DestroyFlag.normal;
//     /**
//      * 由父组件设置的组件属性
//      */
//     private _props: Json; 
//     /**
//      * 由forelet | 自身数据设置的组件状态
//      */
//     private _state: Json; 
//     private _cmdList: string[] = [];
//     constructor() {
//         super();
//         this.resTimeout = 60000;
//         this.resTab = new ResTab();
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.name   = undefined;
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.sheet  = undefined;
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.config = undefined;
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.forelet = undefined;
//         this._props  = {};
//         this._state  = {};
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.tree   = undefined;
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.parentNode = undefined;
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.parent     = undefined;
//         this.children   = [];
//         this.styleCache = new Map();
//         // tslint:disable-next-line:no-unnecessary-field-initialization
//         this.control    = undefined;
//         this.visible    = true;
//         this.setOnOffAnim();
//         this._logCmd('Constructor');
//     }
//     /**
//      *  组件 gui 描述的创建方法
//      */
//     // tslint:disable-next-line:no-empty
//     public _guiCfgCreator = (it: any, it1: any): any => {};
//     /**
//      * 创建后调用，一般在渲染循环外调用
//      */
//     public create(): void {
//         this.forelet && this.forelet.addWidget(this);
//         this._logCmd('create');
//     }
//     /**
//      * 第一次计算后调用，此时创建了真实的dom，但并没有加入到dom树上，一般在渲染循环外调用
//      */
//     public firstPaint(): void {
//         this.forelet && this.forelet.eventWidget(this, 'firstPaint');
//         if (this.openAnim !== undefined) {
//             this._disEnable();
//             this.openAnim.control = this.control;
//             this.openAnim.callBack = this._enableCall;
//             GUIAnimController.addAnimData(this.openAnim);
//         }
//         this._logCmd('firstPaint');
//     }
//     /**
//      * 销毁时调用，一般在渲染循环外调用
//      */
//     public destroy() {
//         if (this.isDestroyed === DestroyFlag.destroyed) return;
//         this.isDestroyed = DestroyFlag.destroyed;
//         this.clearAnimationMap();
//         if (this.closeAnim !== undefined) {
//             this._disEnable();
//             this.closeAnim.control = this.control;
//             this.closeAnim.callBack = this._destroy;
//             GUIAnimController.addAnimData(this.closeAnim);
//         } else {
//             this._destroy();
//         }
//         this._logCmd('destroy');
//     }
//     public dispose = () => {
//         this._dispose();
//         this._logCmd('dispose');
//     }
//     /**
//      * 添加到dom树后调用，在渲染循环内调用
//      */
//     // tslint:disable:no-empty
//     public attach(): void {
//         this.inDomTree = true;
//         this._logCmd('attach');
//     }
//     /**
//      * 页面 底层框架调用 不可视
//      */
//     public disVisibleCall = () => {
//         if (this.control) {
//             this.control && GUICreator.setControlAttr(this.control, 'isVisible', false); 
//         }
//     }
//     /**
//      * 页面 底层框架调用 可视
//      */
//     public visibleCall = () => {
//         clearTimeout(this.disVisibleHandler); 
//         this.control && GUICreator.setControlAttr(this.control, 'isVisible', true); 
//     }
//     /**
//      * 设置 - 界面 - 关闭 - 打开 时的动画
//      * @param openAnim 打开动画配置
//      * @param closeAnim 关闭动画配置
//      */
//     public setOnOffAnim(openAnim?: IWidgetONOFFAnim, closeAnim?: IWidgetONOFFAnim) {
//         if (openAnim) {
//             this.openAnim = <any>openAnim;
//             this.openAnim.time = openAnim.time === undefined ? WIDGET_ONOFF_TIME : openAnim.time;
//             this.openAnim.isLoop = false;
//         }
//         if (closeAnim) {
//             this.closeAnim = <any>closeAnim;
//             this.closeAnim.time = closeAnim.time === undefined ? WIDGET_ONOFF_TIME : closeAnim.time;
//             this.closeAnim.isLoop = false;
//         }
//     }
//     /**
//      * 更新到dom树前调用，一般在渲染循环外调用
//      */
//     public beforeUpdate(): void {
//         this.forelet && this.forelet.eventWidget(this, 'update');
//     }
//     /**
//      * 更新到dom树后调用，在渲染循环内调用
//      */
//     public afterUpdate(): void {
//     }
//     /**
//      * 从dom树上移除前调用，一般在渲染循环内调用
//      */
//     public detach(): void {
//     }
//     /**
//      * 获得样式数据
//      */
//     public getSheet(): Sheet {
//         return this.sheet && this.sheet.value;
//     }
//     /**
//      * 获得配置数据
//      */
//     public getConfig(): Json {
//         return this.config && this.config.value;
//     }
//     /**
//      * 获得渲染数据
//      */
//     public getProps(): Json {
//         return this.props;
//     }
//     /**
//      * 设置属性，默认外部传入的props是完整的props，重载可改变行为
//      * @param props 新数据
//      * @param oldProps 老数据
//      */
//     public setProps(props: Json, oldProps?: Json): void {
//         if (props !== undefined) {
//             this.updateProps(props);
//         }
//     }
//     /**
//      * 更新属性，默认外部传入的props是更新命令，必须为Json对象，键的结构类似"a.b.c"，重载可改变行为
//      */
//     public updateProps(props: Json, oldProps?: Json): void {
//         if (!props) {
//             return;
//         }
//         for (const k in props) {
//             setValue(this.props, k, props[k]);
//         }
//         this._logCmd('updateProps');
//     }
//     /**
//      * 获得渲染数据
//      */
//     public getState(): Json {
//         return this.state;
//     }
//     /**
//      * 设置状态
//      */
//     public setState(state: Json): void {
//         if (state) {
//             for (const k in state) {
//                 setValue(this.state, k, state[k]);
//             }
//         }
//         this._logCmd('setState');
//     }
//     /**
//      * 绘制方法，
//      * @param reset 表示新旧数据差异很大，不做差异计算，直接生成dom
//      */
//     public paint(reset?: boolean): void {
//         RootManager.paintWidget(this, reset);
//         this._logCmd('paint');
//     }
//     /**
//      * 只会被调用一次
//      * @param reset 表示新旧数据差异很大，不做差异计算，直接生成dom
//      */
//     public guiCreate(): void {
//         this._guiCreate();
//         this._logCmd('guiCreate');
//     }
//     /**
//      * 组件销毁前必须调用
//      * 清除动画
//      */
//     public clearAnimationMap() {
//         this.animationMap.forEach((animMap, control) => {
//             this.delControlAnimCfgs(control);
//         });
//         this.animationMap.clear();
//         this._logCmd('clearAnimationMap');
//     }
//     /**
//      * 添加节点动画的记录
//      * @param control 目标节点
//      * @param animCfg 节点动画配置
//      */
//     public addAnimCfg(control: BABYLON.GUI.Control, animCfg: IAnimationCfg) {
//         let  animMap: Map<string, IAnimationCfg>;
//         animMap = this.animationMap.get(control);
//         if (animMap === undefined) {
//             animMap = new Map();
//             this.animationMap.set(control, animMap);
//         }
//         if (animCfg.name !== undefined) {
//             animMap.set(animCfg.name, animCfg);
//         } else {
//             console.warn(`${animCfg} 动画 name 属性未设置。`);
//         }
//     }
//     /**
//      * 添加节点动画的记录
//      * @param control 目标节点
//      * @param animCfg 节点动画配置
//      */
//     public addControlAnimMap(control: BABYLON.GUI.Control) {
//         let  animMap: Map<string, IAnimationCfg>;
//         animMap = this.animationMap.get(control);
//         if (animMap === undefined) {
//             animMap = new Map();
//             this.animationMap.set(control, animMap);
//         }
//         return animMap;
//     }
//     public readAnimCfgMap(control: BABYLON.GUI.Control) {
//         let  animMap: Map<string, IAnimationCfg>;
//         animMap = this.animationMap.get(control);
//         return animMap;
//     }
//     /**
//      * 删除节点动画配置
//      * @param control 目标节点
//      */
//     public delControlAnimCfgs(control: BABYLON.GUI.Control) {
//         const  animMap: Map<string, IAnimationCfg> = this.animationMap.get(control);
//         if (animMap !== undefined) {
//             animMap.forEach(animCfg => {
//                 this._stopAnim(animCfg);
//             });
//             animMap.clear();
//             this._delControlAnim(control);
//         }
//     }
//     /**
//      * 激活节点动画
//      * @param control 目标节点 
//      */
//     public activeControlAnim(control: BABYLON.GUI.Control, animName: string) {
//         const animMap = this.animationMap.get(control);
//         if (animMap !== undefined) {
//             const animCfg = animMap.get(animName);
//             if (animCfg !== undefined) {
//                 const oldCB  = animCfg.animData.callBack;
//                 animCfg.animData.callBack = () => {
//                     this._removeControlAnimCfg(animCfg.control, animName);
//                     oldCB && oldCB();
//                 };
//                 GUIAnimController.addAnimData(animCfg.animData);
//             }
//         }
//     }
//     /**
//      * 停止节点动画
//      * @param control 目标节点 
//      */
//     public stopControlAnim(control: BABYLON.GUI.Control, animName: string) {
//         const animMap = this.animationMap.get(control);
//         if (animMap !== undefined) {
//             const animCfg = animMap.get(animName);
//             if (animCfg !== undefined) {
//                 this._stopAnim(animCfg); 
//                 animMap.delete(animName);
//             }
//         }
//     }
//     /**
//      * 自己自身逻辑控制可见
//      */
//     public toVisible = () => {
//         this.visible = true;
//         this.control.isVisible = true;
//         RootManager.updateGroupVisible();
//     }
//     /**
//      * 自己自身逻辑控制不可见
//      */
//     public toDisVisible = () => {
//         this.visible = false;
//         this.control.isVisible = false;
//         RootManager.updateGroupVisible();
//     }
//     /**
//      * 界面可操作
//      */
//     public enable() {
//         this.control && (this.control.isEnabled = true);
//         this.isEnable = true;
//     }
//     private _removeControlAnimCfg(control: BABYLON.GUI.Control, animName: string) {
//         const animMap = this.animationMap.get(control);
//         if (animMap !== undefined) {
//             const animCfg = animMap.get(animName);
//             if (animCfg !== undefined) {
//                 this._stopAnim(animCfg); 
//                 animMap.delete(animName);
//             }
//         }
//     }
//     /**
//      * 停止目标动画的执行
//      * @param animCfg 目标动画
//      */
//     // tslint:disable-next-line:function-name
//     private _stopAnim(animCfg: IAnimationCfg) {
//         if (animCfg.animData !== undefined && animCfg.animData.isDisposed === false) {
//             animCfg.animData.dispose();
//         } 
//     }
//     /**
//      * 移除动画配置
//      * @param animCfg 目标动画配置 
//      */
//     // tslint:disable-next-line:function-name
//     private _delControlAnim(control: BABYLON.GUI.Control) {
//         if (control !== undefined) {
//             this.animationMap.delete(control);
//         } 
//     }
//     /**
//      * 只会被调用一次
//      * @param reset 表示新旧数据差异很大，不做差异计算，直接生成dom
//      */
//     // tslint:disable-next-line:function-name
//     private _guiCreate(): void {
//         RootManager.createWidgetTree(this);
//         this._guiCreate = undefined;
//         this.isReady = true;
//         this._logCmd('_guiCreate');
//     }
//     private _logCmd(cmd: string) {
//         if (Widget.DebugCmd) {
//             this._cmdList.push(cmd);
//         }
//     }
//     /**
//      * 开启动画结束回调
//      */
//     private _enableCall = () => {
//         this.enable();
//     }
//     /**
//      * 界面不可操作
//      */
//     private _disEnable = () => {
//         this.isEnable = false;
//         this.control && (this.control.isEnabled = false);
//     }
//     /**
//      * 界面销毁
//      */
//     private _destroy = () => {
//         RootManager.destroy(this);
//         this._logCmd('_destroy');
//     }
//     private _dispose() {
//         let res: boolean = false;
//         this.tree = undefined;
//         if (this.resTab) {
//             this.resTab.timeout = this.resTimeout;
//             this.resTab.release();
//         }
//         this.forelet && this.forelet.removeWidget(this);
//         res = true;
//         this.name   = undefined;
//         this.sheet  = undefined;
//         this.config = undefined;
//         this.forelet = undefined;
//         this._props  = undefined;
//         this._state  = undefined;
//         this.tree   = undefined;
//         this.parentNode = undefined;
//         this.parent     = undefined;
//         this.children   = undefined;
//         this.resTab     = undefined;
//         this.resTimeout = 0;
//         this.styleCache = undefined;
//         this.control    = undefined;
//         this.animationMap = undefined;
//         this.openAnim = undefined;
//         this.closeAnim = undefined;
//         this._logCmd('_dispose');
//         return res;
//     }
// }

_$pi.define("pi_gui/widget/scroller/scroller_bk", ["require", "exports", "../../widget/event", "../../widget/painter", "../../widget/widget", "./dom", "./ease", "./util"], function (require, exports, event_1, painter_1, widget_1, dom_1, ease_1, util_1) {
    "use strict";
    
    // ====================================== 常量声明
    const TOUCH_EVENT = 1;
    // ====================================== 导出
    class BScroll extends widget_1.Widget {
        constructor() {
            super(...arguments);
            this.x = 0;
            this.y = 0;
            this.directionX = 0;
            this.directionY = 0;
            // tslint:disable:typedef
            // tslint:disable:no-object-literal-type-assertion
            this.currentPage = {};
            this.pages = [];
            // tslint:disable:variable-name
            this._events = {};
            this.props = {
                id: null,
                child: null,
                childProps: null,
                options: {
                    startX: 0,
                    startY: 0,
                    scrollX: false,
                    scrollY: true,
                    directionLockThreshold: 5,
                    momentum: true,
                    bounce: true,
                    selectedIndex: 0,
                    rotate: 25,
                    wheel: false,
                    snap: false,
                    snapLoop: false,
                    snapThreshold: 0.1,
                    swipeTime: 2500,
                    bounceTime: 700,
                    adjustTime: 400,
                    swipeBounceTime: 1200,
                    deceleration: 0.001,
                    momentumLimitTime: 300,
                    momentumLimitDistance: 15,
                    resizePolling: 60,
                    preventDefault: true,
                    preventDefaultException: {
                        tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/
                    },
                    HWCompositing: true,
                    useTransition: true,
                    useTransform: true,
                    eventPassthrough: null,
                    tap: null,
                    bindToWrapper: null,
                    click: null,
                    disableMouse: null,
                    disableTouch: null,
                    scrollerStyle: [],
                    snapStepX: null,
                    snapStepY: null,
                    probeType: null,
                    snapSpeed: null,
                    itemHeight: null
                }
            };
        }
        // ============================================================== 公共函数
        setProps(props, oldProps) {
            super.updateProps(props, oldProps);
            this.translateZ = this.props.options.HWCompositing && dom_1.hasPerspective ? ' translateZ(0)' : '';
            this.props.options.useTransition = this.props.options.useTransition && dom_1.hasTransition;
            this.props.options.useTransform = this.props.options.useTransform && dom_1.hasTransform;
            this.props.options.eventPassthrough = this.props.options.eventPassthrough === true ? 'vertical' : this.props.options.eventPassthrough;
            this.props.options.preventDefault = !this.props.options.eventPassthrough && this.props.options.preventDefault;
            // If you want eventPassthrough I have to lock one of the axes
            this.props.options.scrollX = this.props.options.eventPassthrough === 'horizontal' ? false : this.props.options.scrollX;
            this.props.options.scrollY = this.props.options.eventPassthrough === 'vertical' ? false : this.props.options.scrollY;
            // With eventPassthrough we also need lockDirection mechanism
            this.props.options.freeScroll = this.props.options.freeScroll && !this.props.options.eventPassthrough;
            this.props.options.directionLockThreshold = this.props.options.eventPassthrough ? 0 : this.props.options.directionLockThreshold;
            if (this.props.options.tap === true) {
                this.props.options.tap = 'tap';
            }
        }
        firstPaint() {
            this.wrapper = painter_1.getRealNode(this.tree);
            this.scroller = this.wrapper.children[0];
            this._init();
            if (this.props.options.snap) {
                this._initSnap();
            }
            this.refresh();
            if (!this.props.options.snap) {
                this.scrollTo(this.props.options.startX, this.props.options.startY);
            }
            this.enable();
            for (const key in this.props.options.scrollerStyle) {
                painter_1.paintCmd3(this.scroller.style, key, this.props.options.scrollerStyle[key]);
            }
        }
        refresh() {
            const rf = this.wrapper.offsetHeight;
            // tslint:disable:radix
            this.wrapperWidth = parseInt(this.wrapper.style.width) || this.wrapper.clientWidth;
            this.wrapperHeight = parseInt(this.wrapper.style.height) || this.wrapper.clientHeight;
            this.scrollerWidth = parseInt(this.scroller.style.width) || this.scroller.clientWidth;
            this.scrollerHeight = parseInt(this.scroller.style.height) || this.scroller.clientHeight;
            if (this.props.options.wheel) {
                this.items = this.scroller.children;
                this.props.options.itemHeight = this.itemHeight = this.items.length ? this.items[0].clientHeight : 0;
                if (this.selectedIndex === undefined) {
                    this.selectedIndex = this.props.options.selectedIndex;
                }
                this.props.options.startY = -this.selectedIndex * this.itemHeight;
                this.maxScrollX = 0;
                this.maxScrollY = -this.itemHeight * (this.items.length - 1);
            }
            else {
                this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
                this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
            }
            this.hasHorizontalScroll = this.props.options.scrollX && this.maxScrollX < 0;
            this.hasVerticalScroll = this.props.options.scrollY && this.maxScrollY < 0;
            if (!this.hasHorizontalScroll) {
                this.maxScrollX = 0;
                this.scrollerWidth = this.wrapperWidth;
            }
            if (!this.hasVerticalScroll) {
                this.maxScrollY = 0;
                this.scrollerHeight = this.wrapperHeight;
            }
            this.endTime = 0;
            this.directionX = 0;
            this.directionY = 0;
            this.wrapperOffset = dom_1.offset(this.wrapper);
            event_1.notify(this.parentNode, 'ev-scroller-refresh', { id: this.props.id });
            this.resetPosition();
        }
        enable() {
            this.enabled = true;
        }
        disable() {
            this.enabled = false;
        }
        goToPage(x, y, time, easing = ease_1.ease.bounce) {
            if (x >= this.pages.length) {
                x = this.pages.length - 1;
            }
            else if (x < 0) {
                x = 0;
            }
            if (y >= this.pages[x].length) {
                y = this.pages[x].length - 1;
            }
            else if (y < 0) {
                y = 0;
            }
            const posX = this.pages[x][y].x;
            const posY = this.pages[x][y].y;
            time = time === undefined ? this.props.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;
            this.currentPage = {
                x: posX,
                y: posY,
                pageX: x,
                pageY: y
            };
            this.scrollTo(posX, posY, time, easing);
        }
        resetPosition(time = 0, easeing = ease_1.ease.bounce) {
            let x = this.x;
            if (!this.hasHorizontalScroll || x > 0) {
                x = 0;
            }
            else if (x < this.maxScrollX) {
                x = this.maxScrollX;
            }
            let y = this.y;
            if (!this.hasVerticalScroll || y > 0) {
                y = 0;
            }
            else if (y < this.maxScrollY) {
                y = this.maxScrollY;
            }
            if (x === this.x && y === this.y) {
                return false;
            }
            this.scrollTo(x, y, time, easeing);
            return true;
        }
        getComputedPosition() {
            let matrix = window.getComputedStyle(this.scroller, null);
            let x;
            let y;
            if (this.props.options.useTransform) {
                matrix = matrix[dom_1.style.transform].split(')')[0].split(', ');
                x = +(matrix[12] || matrix[4]);
                y = +(matrix[13] || matrix[5]);
            }
            else {
                x = +matrix.left.replace(/[^-\d.]/g, '');
                y = +matrix.top.replace(/[^-\d.]/g, '');
            }
            return {
                x,
                y
            };
        }
        scrollTo(x, y, time, easing) {
            if (!easing) {
                easing = ease_1.ease.bounce;
            }
            this.isInTransition = this.props.options.useTransition && time > 0 && (x !== this.x || y !== this.y);
            if (!time || this.props.options.useTransition) {
                this._transitionTimingFunction(easing.style);
                this._transitionTime(time);
                this._translate(x, y);
                console.log('scrollTo');
                if (time && this.props.options.probeType === 3) {
                    this._startProbe();
                }
                if (this.props.options.wheel) {
                    if (y > 0) {
                        this.selectedIndex = 0;
                    }
                    else if (y < this.maxScrollY) {
                        this.selectedIndex = this.items.length - 1;
                    }
                    else {
                        this.selectedIndex = Math.abs(y / this.itemHeight) | 0;
                    }
                }
            }
        }
        scrollToElement(el, time, offsetX, offsetY, easing) {
            if (!el) {
                return;
            }
            el = el.nodeType ? el : this.scroller.querySelector(el);
            if (this.props.options.wheel && el.className !== 'wheel-item') {
                return;
            }
            const pos = dom_1.offset(el);
            pos.left -= this.wrapperOffset.left;
            pos.top -= this.wrapperOffset.top;
            // if offsetX/Y are true we center the element to the screen
            if (offsetX === true) {
                offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
            }
            if (offsetY === true) {
                offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
            }
            pos.left -= offsetX || 0;
            pos.top -= offsetY || 0;
            pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
            pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;
            if (this.props.options.wheel) {
                pos.top = Math.round(pos.top / this.itemHeight) * this.itemHeight;
            }
            time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;
            this.scrollTo(pos.left, pos.top, time, easing);
        }
        // ============================================================== 私有函数
        // tslint:disable:function-name
        _init() {
            this._addEvents();
        }
        // tslint:disable-next-line:max-func-body-length
        _initSnap() {
            this.currentPage = {};
            if (this.props.options.snapLoop) {
                const children = this.scroller.children;
                if (children.length > 0) {
                    dom_1.prepend(children[children.length - 1].cloneNode(true), this.scroller);
                    this.scroller.appendChild(children[1].cloneNode(true));
                }
            }
            if (typeof this.props.options.snap === 'string') {
                this.props.options.snap = this.scroller.querySelectorAll(this.props.options.snap);
            }
            this.on('refresh', () => {
                this.pages = [];
                if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
                    return;
                }
                const stepX = this.props.options.snapStepX || this.wrapperWidth;
                const stepY = this.props.options.snapStepY || this.wrapperHeight;
                let x = 0;
                let y;
                let cx;
                let cy;
                let i = 0;
                let l;
                let m = 0;
                let n;
                let el;
                let rect;
                if (this.props.options.snap === true) {
                    cx = Math.round(stepX / 2);
                    cy = Math.round(stepY / 2);
                    while (x > -this.scrollerWidth) {
                        this.pages[i] = [];
                        l = 0;
                        y = 0;
                        while (y > -this.scrollerHeight) {
                            this.pages[i][l] = {
                                x: Math.max(x, this.maxScrollX),
                                y: Math.max(y, this.maxScrollY),
                                width: stepX,
                                height: stepY,
                                cx: x - cx,
                                cy: y - cy
                            };
                            y -= stepY;
                            l++;
                        }
                        x -= stepX;
                        i++;
                    }
                }
                else {
                    el = this.props.options.snap;
                    l = el.length;
                    n = -1;
                    for (; i < l; i++) {
                        rect = dom_1.getRect(el[i]);
                        if (i === 0 || rect.left <= dom_1.getRect(el[i - 1]).left) {
                            m = 0;
                            n++;
                        }
                        if (!this.pages[m]) {
                            this.pages[m] = [];
                        }
                        x = Math.max(-rect.left, this.maxScrollX);
                        y = Math.max(-rect.top, this.maxScrollY);
                        cx = x - Math.round(rect.width / 2);
                        cy = y - Math.round(rect.height / 2);
                        this.pages[m][n] = {
                            x: x,
                            y: y,
                            width: rect.width,
                            height: rect.height,
                            cx: cx,
                            cy: cy
                        };
                        if (x > this.maxScrollX) {
                            m++;
                        }
                    }
                }
                const initPage = this.props.options.snapLoop ? 1 : 0;
                this.goToPage(this.currentPage.pageX || initPage, this.currentPage.pageY || 0, 0);
                // Update snap threshold if needed
                if (this.props.options.snapThreshold % 1 === 0) {
                    this.snapThresholdX = this.props.options.snapThreshold;
                    this.snapThresholdY = this.props.options.snapThreshold;
                }
                else {
                    this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.props.options.snapThreshold);
                    this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.props.options.snapThreshold);
                }
            });
            this.on('scrollEnd', () => {
                if (this.props.options.snapLoop) {
                    if (this.currentPage.pageX === 0) {
                        this.goToPage(this.pages.length - 2, this.currentPage.pageY, 0);
                    }
                    if (this.currentPage.pageX === this.pages.length - 1) {
                        this.goToPage(1, this.currentPage.pageY, 0);
                    }
                }
            });
            this.on('flick', () => {
                const time = this.props.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);
                this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
            });
        }
        _transitionTimingFunction(easing) {
            this.props.options.scrollerStyle[dom_1.style.transitionTimingFunction] = easing;
            painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionTimingFunction, this.props.options.scrollerStyle[dom_1.style.transitionTimingFunction]);
            // paintCmd3(this.scroller, "style" , this.props.options.scrollerStyle);
            if (this.props.options.wheel && !util_1.isBadAndroid) {
                for (let i = 0; i < this.items.length; i++) {
                    this.items[i].style[dom_1.style.transitionTimingFunction] = easing;
                    painter_1.paintCmd3(this.items[i].style, dom_1.style.transitionTimingFunction, this.items[i].style[dom_1.style.transitionTimingFunction]);
                }
            }
        }
        _transitionEnd(e) {
            if (e.target !== this.scroller || !this.isInTransition) {
                return;
            }
            this._transitionTime();
            if (!this.resetPosition(this.props.options.bounceTime, ease_1.ease.bounce)) {
                this.isInTransition = false;
                event_1.notify(this.parentNode, 'ev-scroller-scrollend', { id: this.props.id, x: this.x, y: this.y });
            }
        }
        _transitionTime(time = 0) {
            // paintCmd3(this.scroller, "style" , this.props.options.scrollerStyle);
            // tslint:disable:prefer-template
            this.props.options.scrollerStyle[dom_1.style.transitionDuration] = time + 'ms';
            painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionDuration, this.props.options.scrollerStyle[dom_1.style.transitionDuration]);
            // paintCmd3(this.scroller, "style" , this.props.options.scrollerStyle);
            if (this.props.options.wheel && !util_1.isBadAndroid) {
                for (let i = 0; i < this.items.length; i++) {
                    this.items[i].style[dom_1.style.transitionDuration] = time + 'ms';
                    painter_1.paintCmd3(this.items[i].style, dom_1.style.transitionDuration, this.items[i].style[dom_1.style.transitionDuration]);
                }
            }
            if (!time && util_1.isBadAndroid) {
                this.props.options.scrollerStyle[dom_1.style.transitionDuration] = '0.001s';
                painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionDuration, this.props.options.scrollerStyle[dom_1.style.transitionDuration]);
                requestAnimationFrame(() => {
                    if (this.props.options.scrollerStyle[dom_1.style.transitionDuration] === '0.0001ms') {
                        this.props.options.scrollerStyle[dom_1.style.transitionDuration] = '0s';
                        painter_1.paintCmd3(this.scroller.style, dom_1.style.transitionDuration, this.props.options.scrollerStyle[dom_1.style.transitionDuration]);
                    }
                });
            }
        }
        _translate(x, y) {
            if (this.props.options.useTransform) {
                console.log(`this.props.options.scrollerStyle[style.transform] : ${this.props.options.scrollerStyle[dom_1.style.transform]}`);
                this.props.options.scrollerStyle[dom_1.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;
                painter_1.paintCmd3(this.scroller.style, dom_1.style.transform, this.props.options.scrollerStyle[dom_1.style.transform]);
            }
            else {
                x = Math.round(x);
                y = Math.round(y);
                this.props.options.scrollerStyle.left = x + 'px';
                painter_1.paintCmd3(this.scroller.style, 'left', this.props.options.scrollerStyle.left);
                this.props.options.scrollerStyle.top = y + 'px';
                painter_1.paintCmd3(this.scroller.style, 'top', this.props.options.scrollerStyle.top);
            }
            if (this.props.options.wheel && !util_1.isBadAndroid) {
                for (let i = 0; i < this.items.length; i++) {
                    const deg = this.props.options.rotate * (y / this.itemHeight + i);
                    this.items[i].style[dom_1.style.transform] = 'rotateX(' + deg + 'deg)';
                    painter_1.paintCmd3(this.items[i].style, dom_1.style.transform, this.items[i].style[dom_1.style.transform]);
                }
            }
            this.x = x;
            this.y = y;
        }
        _startProbe() {
            cancelAnimationFrame(this.probeTimer);
            this.probeTimer = requestAnimationFrame(probe);
            // tslint:disable:no-this-assignment
            const me = this;
            function probe() {
                const pos = me.getComputedPosition();
                event_1.notify(me.parentNode, 'ev-scroller-scroll', { id: this.props.id, x: pos.x, y: pos.y });
                if (me.isInTransition) {
                    me.probeTimer = requestAnimationFrame(probe);
                }
            }
        }
        _addEvents() {
            this._handleEvents(dom_1.addEvent);
        }
        _removeEvents() {
            this._handleEvents(dom_1.addEvent);
        }
        _handleEvents(eventOperation) {
            const target = this.props.options.bindToWrapper ? this.wrapper : window;
            eventOperation(window, 'orientationchange', this);
            eventOperation(window, 'resize', this);
            if (this.props.options.click) {
                eventOperation(this.wrapper, 'click', this);
            }
            if (!this.props.options.disableMouse) {
                eventOperation(this.wrapper, 'mousedown', this);
                eventOperation(target, 'mousemove', this);
                eventOperation(target, 'mousecancel', this);
                eventOperation(target, 'mouseup', this);
            }
            if (dom_1.hasTouch && !this.props.options.disableTouch) {
                eventOperation(this.wrapper, 'touchstart', this);
                eventOperation(target, 'touchmove', this);
                eventOperation(target, 'touchcancel', this);
                eventOperation(target, 'touchend', this);
            }
            eventOperation(this.scroller, dom_1.style.transitionEnd, this);
        }
        _start(e) {
            const _eventType = dom_1.eventType[e.type];
            if (_eventType !== TOUCH_EVENT) {
                if (e.button !== 0) {
                    return;
                }
            }
            if (!this.enabled || this.destroyed || (this.initiated && this.initiated !== _eventType)) {
                return;
            }
            this.initiated = _eventType;
            if (this.props.options.preventDefault && !util_1.isBadAndroid &&
                !dom_1.preventDefaultException(e.target, this.props.options.preventDefaultException)) {
                e.preventDefault();
            }
            this.moved = false;
            this.distX = 0;
            this.distY = 0;
            this.directionX = 0;
            this.directionY = 0;
            this.directionLocked = 0;
            this._transitionTime();
            this.startTime = +new Date();
            if (this.props.options.wheel) {
                this.target = e.target;
            }
            if (this.props.options.useTransition && this.isInTransition) {
                this.isInTransition = false;
                const pos = this.getComputedPosition();
                this._translate(pos.x, pos.y);
                console.log('_start');
                if (this.props.options.wheel) {
                    this.target = this.items[Math.round(-pos.y / this.itemHeight)];
                }
                else {
                    event_1.notify(this.parentNode, 'ev-scroller-scrollend', { id: this.props.id, x: this.x, y: this.y });
                }
            }
            const point = e.touches ? e.touches[0] : e;
            this.startX = this.x;
            this.startY = this.y;
            this.absStartX = this.x;
            this.absStartY = this.y;
            this.pointX = point.pageX;
            this.pointY = point.pageY;
            event_1.notify(this.parentNode, 'ev-scroller-beforescrollstart', { id: this.props.id });
        }
        // tslint:disable:cyclomatic-complexity
        // tslint:disable-next-line:max-func-body-length
        _move(e) {
            if (!this.enabled || this.destroyed || dom_1.eventType[e.type] !== this.initiated) {
                return;
            }
            if (this.props.options.preventDefault) {
                e.preventDefault();
            }
            const point = e.touches ? e.touches[0] : e;
            let deltaX = point.pageX - this.pointX;
            let deltaY = point.pageY - this.pointY;
            this.pointX = point.pageX;
            this.pointY = point.pageY;
            this.distX += deltaX;
            this.distY += deltaY;
            const absDistX = Math.abs(this.distX);
            const absDistY = Math.abs(this.distY);
            const timestamp = +new Date();
            // We need to move at least 15 pixels for the scrolling to initiate
            // tslint:disable:max-line-length
            if (timestamp - this.endTime > this.props.options.momentumLimitTime && (absDistY < this.props.options.momentumLimitDistance && absDistX < this.props.options.momentumLimitDistance)) {
                return;
            }
            // If you are scrolling in one direction lock the other
            if (!this.directionLocked && !this.props.options.freeScroll) {
                if (absDistX > absDistY + this.props.options.directionLockThreshold) {
                    this.directionLocked = 'h'; // lock horizontally
                }
                else if (absDistY >= absDistX + this.props.options.directionLockThreshold) {
                    this.directionLocked = 'v'; // lock vertically
                }
                else {
                    this.directionLocked = 'n'; // no lock
                }
            }
            if (this.directionLocked === 'h') {
                if (this.props.options.eventPassthrough === 'vertical') {
                    e.preventDefault();
                }
                else if (this.props.options.eventPassthrough === 'horizontal') {
                    this.initiated = false;
                    return;
                }
                deltaY = 0;
            }
            else if (this.directionLocked === 'v') {
                if (this.props.options.eventPassthrough === 'horizontal') {
                    e.preventDefault();
                }
                else if (this.props.options.eventPassthrough === 'vertical') {
                    this.initiated = false;
                    return;
                }
                deltaX = 0;
            }
            deltaX = this.hasHorizontalScroll ? deltaX : 0;
            deltaY = this.hasVerticalScroll ? deltaY : 0;
            let newX = this.x + deltaX;
            let newY = this.y + deltaY;
            // Slow down or stop if outside of the boundaries
            if (newX > 0 || newX < this.maxScrollX) {
                if (this.props.options.bounce) {
                    newX = this.x + deltaX / 3;
                }
                else {
                    newX = newX > 0 ? 0 : this.maxScrollX;
                }
            }
            if (newY > 0 || newY < this.maxScrollY) {
                if (this.props.options.bounce) {
                    newY = this.y + deltaY / 3;
                }
                else {
                    newY = newY > 0 ? 0 : this.maxScrollY;
                }
            }
            // this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
            // this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;
            if (!this.moved) {
                this.moved = true;
                event_1.notify(this.parentNode, 'ev-scroller-scrollstart', { id: this.props.id });
            }
            this._translate(newX, newY);
            console.log('_move');
            if (timestamp - this.startTime > this.props.options.momentumLimitTime) {
                this.startTime = timestamp;
                this.startX = this.x;
                this.startY = this.y;
                if (this.props.options.probeType === 1) {
                    event_1.notify(this.parentNode, 'ev-scroller-scroll', { id: this.props.id, x: this.x, y: this.y });
                }
            }
            if (this.props.options.probeType > 1) {
                event_1.notify(this.parentNode, 'ev-scroller-scroll', { id: this.props.id, x: this.x, y: this.y });
            }
            const scrollLeft = document.documentElement.scrollLeft || window.pageXOffset || document.body.scrollLeft;
            const scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
            const pX = this.pointX - scrollLeft;
            const pY = this.pointY - scrollTop;
            if (pX > document.documentElement.clientWidth - this.props.options.momentumLimitDistance || pX < this.props.options.momentumLimitDistance || pY < this.props.options.momentumLimitDistance || pY > document.documentElement.clientHeight - this.props.options.momentumLimitDistance) {
                this._end(e);
            }
        }
        // tslint:disable-next-line:max-func-body-length
        _end(e) {
            if (!this.enabled || this.destroyed || dom_1.eventType[e.type] !== this.initiated) {
                return;
            }
            this.initiated = false;
            if (this.props.options.preventDefault && !dom_1.preventDefaultException(e.target, this.props.options.preventDefaultException)) {
                e.preventDefault();
            }
            event_1.notify(this.parentNode, 'ev-scroller-touchend', { id: this.props.id, x: this.x, y: this.y });
            // reset if we are outside of the boundaries
            if (this.resetPosition(this.props.options.bounceTime, ease_1.ease.bounce)) {
                return;
            }
            this.isInTransition = false;
            // ensures that the last position is rounded
            let newX = Math.round(this.x);
            let newY = Math.round(this.y);
            // we scrolled less than 15 pixels
            if (!this.moved) {
                if (this.props.options.wheel) {
                    if (this.target && this.target.className === 'wheel-scroll') {
                        const index = Math.abs(Math.round(newY / this.itemHeight));
                        const _offset = Math.round((this.pointY + dom_1.offset(this.target).top - this.itemHeight / 2) / this.itemHeight);
                        this.target = this.items[index + _offset];
                    }
                    this.scrollToElement(this.target, this.props.options.adjustTime, true, true, ease_1.ease.swipe);
                }
                else {
                    if (this.props.options.tap) {
                        dom_1.tap(e, this.props.options.tap);
                    }
                    if (this.props.options.click) {
                        dom_1.click(e);
                    }
                }
                event_1.notify(this.parentNode, 'ev-scroller-scrollcancel', { id: this.props.id });
                return;
            }
            this.scrollTo(newX, newY);
            const deltaX = newX - this.absStartX;
            const deltaY = newY - this.absStartY;
            this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
            this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;
            this.endTime = +new Date();
            const duration = this.endTime - this.startTime;
            const absDistX = Math.abs(newX - this.startX);
            const absDistY = Math.abs(newY - this.startY);
            // fastclick
            if (this._events.flick && duration < this.props.options.momentumLimitTime && absDistX < this.props.options.momentumLimitDistance && absDistY < this.props.options.momentumLimitDistance) {
                event_1.notify(this.parentNode, 'ev-scroller-flick', { id: this.props.id });
                return;
            }
            let time = 0;
            // start momentum animation if needed
            if (this.props.options.momentum && duration < this.props.options.momentumLimitTime && (absDistY > this.props.options.momentumLimitDistance || absDistX > this.props.options.momentumLimitDistance)) {
                const momentumX = this.hasHorizontalScroll ? util_1.momentum(this.x, this.startX, duration, this.maxScrollX, this.props.options.bounce ? this.wrapperWidth : 0, this.props.options)
                    : { destination: newX, duration: 0 };
                const momentumY = this.hasVerticalScroll ? util_1.momentum(this.y, this.startY, duration, this.maxScrollY, this.props.options.bounce ? this.wrapperHeight : 0, this.props.options)
                    : { destination: newY, duration: 0 };
                newX = momentumX.destination;
                newY = momentumY.destination;
                time = Math.max(momentumX.duration, momentumY.duration);
                this.isInTransition = 1;
            }
            else {
                if (this.props.options.wheel) {
                    newY = Math.round(newY / this.itemHeight) * this.itemHeight;
                    time = this.props.options.adjustTime;
                }
            }
            let easing = ease_1.ease.swipe;
            if (this.props.options.snap) {
                const snap = this._nearestSnap(newX, newY);
                this.currentPage = snap;
                time = this.props.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
                newX = snap.x;
                newY = snap.y;
                this.directionX = 0;
                this.directionY = 0;
                easing = ease_1.ease.bounce;
            }
            if (newX !== this.x || newY !== this.y) {
                // change easing function when scroller goes out of the boundaries
                if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
                    easing = ease_1.ease.swipeBounce;
                }
                this.scrollTo(newX, newY, time, easing);
                return;
            }
            if (this.props.options.wheel) {
                this.selectedIndex = Math.abs(this.y / this.itemHeight) | 0;
            }
            event_1.notify(this.parentNode, 'ev-scroller-scrollend', { id: this.props.id, x: this.x, y: this.y });
        }
        _nearestSnap(x, y) {
            if (!this.pages.length) {
                return { x: 0, y: 0, pageX: 0, pageY: 0 };
            }
            let i = 0;
            // Check if we exceeded the snap threshold
            if (Math.abs(x - this.absStartX) <= this.snapThresholdX &&
                Math.abs(y - this.absStartY) <= this.snapThresholdY) {
                return this.currentPage;
            }
            if (x > 0) {
                x = 0;
            }
            else if (x < this.maxScrollX) {
                x = this.maxScrollX;
            }
            if (y > 0) {
                y = 0;
            }
            else if (y < this.maxScrollY) {
                y = this.maxScrollY;
            }
            let l = this.pages.length;
            for (; i < l; i++) {
                if (x >= this.pages[i][0].cx) {
                    x = this.pages[i][0].x;
                    break;
                }
            }
            l = this.pages[i].length;
            let m = 0;
            for (; m < l; m++) {
                if (y >= this.pages[0][m].cy) {
                    y = this.pages[0][m].y;
                    break;
                }
            }
            if (i === this.currentPage.pageX) {
                i += this.directionX;
                if (i < 0) {
                    i = 0;
                }
                else if (i >= this.pages.length) {
                    i = this.pages.length - 1;
                }
                x = this.pages[i][0].x;
            }
            if (m === this.currentPage.pageY) {
                m += this.directionY;
                if (m < 0) {
                    m = 0;
                }
                else if (m >= this.pages[0].length) {
                    m = this.pages[0].length - 1;
                }
                y = this.pages[0][m].y;
            }
            return {
                x,
                y,
                pageX: i,
                pageY: m
            };
        }
        _resize() {
            if (!this.enabled) {
                return;
            }
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.refresh();
            }, this.props.options.resizePolling);
        }
        // ============================================================== 事件处理
        // tslint:disable:no-reserved-keywords
        on(type, fn, context = this) {
            if (!this._events[type]) {
                this._events[type] = [];
            }
            this._events[type].push([fn, context]);
        }
        once(type, fn, context = this) {
            let fired = false;
            function magic() {
                this.off(type, magic);
                if (!fired) {
                    fired = true;
                    fn.apply(context, arguments);
                }
            }
            this.on(type, magic);
        }
        off(type, fn) {
            const _events = this._events[type];
            if (!_events) {
                return;
            }
            let count = _events.length;
            while (count--) {
                if (_events[count][0] === fn) {
                    _events[count][0] = undefined;
                }
            }
        }
        trigger(type, ...args) {
            const events = this._events[type];
            if (!events) {
                return;
            }
            const len = events.length;
            const eventsCopy = [...events];
            for (let i = 0; i < len; i++) {
                const event = eventsCopy[i];
                const [fn, context] = event;
                if (fn) {
                    fn.apply(context, [].slice.call(arguments, 1));
                }
            }
        }
        handleEvent(e) {
            switch (e.type) {
                case 'touchstart':
                case 'mousedown':
                    this._start(e);
                    break;
                case 'touchmove':
                case 'mousemove':
                    this._move(e);
                    break;
                case 'touchend':
                case 'mouseup':
                case 'touchcancel':
                case 'mousecancel':
                    this._end(e);
                    break;
                case 'orientationchange':
                case 'resize':
                    this._resize();
                    break;
                case 'transitionend':
                case 'webkitTransitionEnd':
                case 'oTransitionEnd':
                case 'MSTransitionEnd':
                    this._transitionEnd(e);
                    break;
                case 'click':
                    if (this.enabled && !e._constructed && !(/(SELECT|INPUT|TEXTAREA)/i).test(e.target.tagName)) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    break;
                default:
            }
        }
    }
    exports.BScroll = BScroll;
});
